## **new 的核心作用**
-- 在堆上动态分配内存
`new` 负责：
✅ 在**堆区**（Heap）申请一块指定大小的内存空间。  
✅ 自动根据指定类型初始化这块内存。  
✅ 返回该内存空间的**指针**，以便程序访问

##  **new 的语法**
### 1️⃣ **分配单个元素**
```cpp
int *p = new int;      // 分配一个 int 类型的内存空间 
*p = 10;                // 向该内存空间赋值
```
>  `new int` 在堆上申请了一块 `int` 类型大小的内存，并将其地址赋值给指针 `p`。 
>  `*p = 10` 则将 `10` 存储到该内存空间中。
---

### 2️⃣ **分配并初始化单个元素**
```cpp
int *p = new int(10);  // 在堆上分配并初始化为 10 
cout << *p << endl;    // 输出 10
```
>  这种方式更简洁，尤其在对象的构造函数初始化时很实用。
---
 > 1与2的区别只是2初始化了

### 3️⃣ **分配数组**
```cpp
int *arr = new int[5];  // 分配5个int类型的空间 
for (int i = 0; i < 5; i++) {     
	arr[i] = i * 2;     
	cout << arr[i] << " ";  // 输出：0 2 4 6 8 
}
```
>  `new int[5]` 创建了 5 个连续的 `int` 元素，并将首地址赋值给 `arr`。  
>  访问时使用 `arr[i]` 即可，像普通数组一样操作。

## **new 的注意事项**
### 1️⃣ **内存泄漏**
`new` 分配的内存在使用完毕后，必须使用 `delete` 或 `delete[]` 手动释放。否则会导致**内存泄漏**。
```cpp
int *p = new int(20);   
delete p;               // 释放单个元素  

int *arr = new int[5]; 
delete[] arr;           // 释放数组（注意 [] ）
```
在释放了内存之后，该指针会变成**野指针**（只是释放了所指向的内存区域，但指针仍然指向原地址，因为该地址不再合法，所以就是Dangling Pointer了）
为了避免该问题，**释放后应立即将指针置为`nullptr`**

---

### 2️⃣ **忘记 `delete` 会引发内存泄漏**
```cpp
void leak() 
{     
	int *p = new int(100);  // ✅ 动态分配     
	// ❌ 忘记 delete，导致内存泄漏 
}  // 函数结束时，p 指向的内存无法再被访问
```
---

### 3️⃣ **空指针检查**
`new` 在分配失败时会抛出 `std::bad_alloc` 异常，因此推荐在使用时进行异常处理：
```cpp
try 
{     
	int *p = new int[100000000000];  // 可能因内存不足而失败 
} catch (bad_alloc &e) 
{     
	cout << "内存分配失败: " << e.what() << endl; 
}
```