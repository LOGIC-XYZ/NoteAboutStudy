**归约** -- 把一个序列（容器、数组）里的元素，通过一个二元运算符 **逐步合并成单个值**。

比如：
- `sum = 1 + 2 + 3 + 4` （把所有数加起来 → “求和”归约）
- `product = 1 * 2 * 3 * 4` （把所有数乘起来 → “求积”归约）
- `max = 最大(1,2,3,4)` （把所有数取最大 → “最大值”归约）
- `concat = "a" + "b" + "c"` （把字符串拼接 → “拼接”归约）

## 常用归约函数
### `std::accumulate`
- 头文件 `<numeric>`
- 顺序执行，C++11 就有。
- 灵活，可自定义二元运算。
```cpp
int sum = accumulate(v.begin(), v.end(), 0);              // 求和
int product = accumulate(v.begin(), v.end(), 1, multiplies<int>()); // 求积
int mx = accumulate(v.begin(), v.end(), INT_MIN, [](int a, int b){ return max(a,b); }); // 最大值
```

### `std::reduce`
- 头文件 `<numeric>`
- 默认和 `accumulate` 一样，但支持 **并行执行**（`std::execution`）。
- 要求二元运算必须是 **结合律**（比如 `+`、`*`、`max`），否则结果可能不确定。
```cpp
#include <execution>
int sum = reduce(execution::par, v.begin(), v.end(), 0); // 并行求和
```

### 对照表
|函数|功能|自定义运算|并行化支持|C++ 版本|头文件|
|---|---|---|---|---|---|
|`std::accumulate`|顺序累加，初始值+二元运算|✅ 支持|❌|C++98|`<numeric>`|
|`std::reduce`|累加/归约（默认 +），可并行|✅ 但必须满足结合律|✅|C++17|`<numeric>`|
|`std::transform_reduce`|先映射（transform）再归约|✅|✅|C++17|`<numeric>`|
|`std::inner_product`|内积（点积）：Σ (a[i]*b[i])|✅|❌|C++98|`<numeric>`|
|`std::count`, `std::count_if`|统计满足条件的个数|条件表达式|❌|C++98|`<algorithm>`|
|`std::all_of` / `any_of` / `none_of`|逻辑归约：是否所有/任意/没有满足条件|条件表达式|❌|C++11|`<algorithm>`|
|`std::min_element` / `std::max_element`|求最小值/最大值|可自定义比较|❌|C++98|`<algorithm>`|
|`std::minmax_element`|同时求 min 和 max|✅|❌|C++98|`<algorithm>`|
|`std::gcd` / `std::lcm`|计算最大公约数 / 最小公倍数|❌|❌|C++17|`<numeric>`|
#### 用法示例
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v{1,2,3,4,5};

    // 1. accumulate: 求和
    int sum = accumulate(v.begin(), v.end(), 0);

    // 2. reduce: 并行归约（需要 C++17 + <execution>）
    int sum2 = reduce(v.begin(), v.end(), 0);

    // 3. transform_reduce: 求平方和
    int squareSum = transform_reduce(v.begin(), v.end(), 0,
                                     plus<>(), [](int x){ return x*x; });

    // 4. inner_product: 向量点积
    vector<int> w{5,4,3,2,1};
    int dot = inner_product(v.begin(), v.end(), w.begin(), 0);

    // 5. all_of: 是否全部大于 0
    bool allPositive = all_of(v.begin(), v.end(), [](int x){ return x > 0; });

    // 6. minmax_element: 一次求最小最大
    auto [mn, mx] = minmax_element(v.begin(), v.end());

    cout << "sum=" << sum << " dot=" << dot 
         << " min=" << *mn << " max=" << *mx << endl;
}
```
