属于[[02 - study/Data Structures and  Algorithms/动态规划/背包问题]]的变种

# 零钱兑换问题Ⅰ - 最少用几枚硬币
**Q**：给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i−1]$ ，目标金额为 $amt$ ，**每种硬币可以重复选取**，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 −1 。

## DP思路
**零钱兑换可以看作完全背包问题的一种特殊情况**，两者具有以下联系与不同点。
- 两道题可以相互转换，“物品”对应“硬币”、“物品重量”对应“硬币面值”、“背包容量”对应“目标金额”。
- 优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量。
- 完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解。

### 思考每轮的决策，定义状态，从而得到 dp 表
状态 $[i,a]$ 对应的子问题为：**前 $i$ 种硬币能够凑出金额 $a$ 的最少硬币数量**，记为 $dp[i,a]$ 。
二维 $dp$ 表的尺寸为 $(n+1)×(amt+1)$ 。

### 找出最优子结构，进而推导出状态转移方程
本题与完全背包问题的状态转移方程存在以下两点差异。
- 本题要求最小值，因此需将运算符 max() 更改为 min() 。
- 优化主体是硬币数量而非商品价值，因此在选中硬币时执行 +1 即可。（加上的是这一轮新加入的那枚硬币）
$$dp[i,a]=min(dp[i−1,a],dp[i,a−coins[i−1]]+1)$$

### 确定边界条件和状态转移顺序
当目标金额为 0 时，凑出它的最少硬币数量为 0 ，即首列所有 $dp[i,0]$ 都等于 0 。
当无硬币时，**无法凑出任意 >0 的目标金额**，即是无效解。为使状态转移方程中的 min() 函数能够识别并过滤无效解，我们考虑使用 +∞ 来表示它们，即令首行所有 $dp[0,a]$ 都等于 +∞ 。

### 代码实现
采用数字 $amt+1$ 来表示无效解，因为凑出 $amt$ 的硬币数量最多为 $amt$ 。最后返回前，判断 $dp[n,amt]$ 是否等于 $amt+1$ ，若是则返回 −1 ，代表无法凑出目标金额。（前提：硬币最小面额为 1）
```cpp
int coinChangeDP(vector<int> &coins, int amt) {
    int n = coins.size();
    int MAX = amt + 1;
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(amt + 1, 0));
    // 状态转移：首行首列
    for (int a = 1; a <= amt; a++) {
        dp[0][a] = MAX;
    }
    // 状态转移：其余行和列
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[i][a] = dp[i - 1][a];
            } else {
                // 不选和选硬币 i 这两种方案的较小值
                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);
            }
        }
    }
    return dp[n][amt] != MAX ? dp[n][amt] : -1;
}
```
#### 空间优化
和完全背包问题一致
```cpp
int coinChangeDPComp(vector<int> &coins, int amt) {
    int n = coins.size();
    int MAX = amt + 1;
    // 初始化 dp 表
    vector<int> dp(amt + 1, MAX);
    dp[0] = 0;
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[a] = dp[a];
            } else {
                // 不选和选硬币 i 这两种方案的较小值
                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);
            }
        }
    }
    return dp[amt] != MAX ? dp[amt] : -1;
}
```

# 零钱兑换问题Ⅱ - 目标金额有几种组合可以组成
**Q**：给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i−1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，**问凑出目标金额的硬币组合数量**。

## DP思路
本题目标是求组合数量，因此子问题变为：**前 $i$ 种硬币能够凑出金额 $a$ 的组合数量**。而 $dp$ 表仍然是尺寸为 $(n+1)×(amt+1)$ 的二维矩阵。

当前状态的组合数量等于不选当前硬币与选当前硬币这两种决策的组合数量之和。状态转移方程为：$$dp[i,a]=dp[i−1,a]+dp[i,a−coins[i−1]]$$
当目标金额为 0 时，无须选择任何硬币即可凑出目标金额，因此应将首列所有 $dp[i,0]$ 都初始化为 1 。当无硬币时，无法凑出任何 >0 的目标金额，因此首行所有 $dp[0,a]$ 都等于 0 。
按照**逐个硬币向外扩展**，即**先遍历硬币，再遍历金额**。

## 代码实现
```cpp
int coinChangeIIDP(vector<int> &coins, int amt) {
    int n = coins.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(amt + 1, 0));
    // 初始化首列
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[i][a] = dp[i - 1][a];
            } else {
                // 不选和选硬币 i 这两种方案之和
                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];
            }
        }
    }
    return dp[n][amt];
}
```
### 空间优化
```cpp
int coinChangeIIDPComp(vector<int> &coins, int amt) {
    int n = coins.size();
    // 初始化 dp 表
    vector<int> dp(amt + 1, 0);
    dp[0] = 1;
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[a] = dp[a];
            } else {
                // 不选和选硬币 i 这两种方案之和
                dp[a] = dp[a] + dp[a - coins[i - 1]];
            }
        }
    }
    return dp[amt];
}
```

## 与爬楼梯的区别
|维度|零钱兑换 II|爬楼梯|
|---|---|---|
|**目标**|用硬币组合成金额，总共有多少种组合方式|从 0 楼爬到 n 楼，总共有多少种爬法|
|**硬币/步长选择**|给定 `coins` 数组，每种硬币可重复选|每次可以走 1 步或 2 步（固定）|
|**去重策略**|按硬币顺序来避免重复组合|无需特别去重，天然不会重复|
|**是否考虑顺序**|**不考虑顺序**（1+2 和 2+1 视为同一组合）|**考虑顺序**（1+2 和 2+1 是不同爬法）|
|**转移逻辑**|`dp[i] += dp[i - coin]`，每种硬币遍历金额|`dp[i] = dp[i-1] + dp[i-2]`|
|**本质模型**|组合型完全背包问题|顺序型路径计数问题|
（当然如果爬楼梯不考虑顺序就是完全背包问题了。）