**排序算法**（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。

## 评价维度
**运行效率**：期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。

**就地性**：原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。

**稳定性**：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。
```
# 输入数据是按照姓名排序好的
# (name, age)
  ('A', 19)
  ('B', 18)
  ('C', 21)
  ('D', 19)
  ('E', 23)

# 假设使用非稳定排序算法按年龄排序列表，
# 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变，
# 输入数据按姓名排序的性质丢失
  ('B', 18)
  ('D', 19)
  ('A', 19)
  ('C', 21)
  ('E', 23)
```

**自适应性**：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。

**是否基于比较**：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达 O(n) ，但其通用性相对较差。

# 排序典型算法
- [[02 - study/Data Structures and  Algorithms/排序/选择排序]]
- [[02 - study/Data Structures and  Algorithms/排序/冒泡排序]]
- [[02 - study/Data Structures and  Algorithms/排序/插入排序]]
- [[02 - study/Data Structures and  Algorithms/排序/快速排序]]
- [[02 - study/Data Structures and  Algorithms/排序/归并排序]]
- [[02 - study/Data Structures and  Algorithms/排序/堆排序]]
- [[02 - study/Data Structures and  Algorithms/排序/桶排序]]
- [[02 - study/Data Structures and  Algorithms/排序/计数排序]]
- [[02 - study/Data Structures and  Algorithms/排序/基数排序]]
## 比较

| 排序算法     | 时间复杂度（平均）  | 时间复杂度（最坏）  | 时间复杂度（最好）  | 空间复杂度    | 是否稳定  | 排序方式  |
| -------- | ---------- | ---------- | ---------- | -------- | ----- | ----- |
| **选择排序** | O(n²)      | O(n²)      | O(n²)      | O(1)     | ❌ 不稳定 | 原地排序  |
| **冒泡排序** | O(n²)      | O(n²)      | O(n)       | O(1)     | ✅ 稳定  | 原地排序  |
| **插入排序** | O(n²)      | O(n²)      | O(n)       | O(1)     | ✅ 稳定  | 原地排序  |
| **快速排序** | O(n log n) | O(n²)      | O(n log n) | O(log n) | ❌ 不稳定 | 原地排序  |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n)     | ✅ 稳定  | 非原地排序 |
| **堆排序**  | O(n log n) | O(n log n) | O(n log n) | O(1)     | ❌ 不稳定 | 原地排序  |
| **桶排序**  | O(n + k)   | O(n²)      | O(n + k)   | O(n + k) | ✅ 稳定  | 非原地排序 |
| **计数排序** | O(n + k)   | O(n + k)   | O(n + k)   | O(k)     | ✅ 稳定  | 非原地排序 |
| **基数排序** | O(n × d)   | O(n × d)   | O(n × d)   | O(n + k) | ✅ 稳定  | 非原地排序 |

## 分类
### 选择排序族（简单直观，效率差）
- 选择、冒泡、插入：适合**小数据量**场景
- 插入排序在**近乎有序**的数据中表现较好
---

### 分治排序族（性能强，适合大规模）
- 快速排序：**平均性能最好**，但不稳定
- 归并排序：**稳定排序中的最快者**，但需要额外空间
- 堆排序：适合**内存受限**、不要求稳定性的场景
---

### 线性排序族（对数据有特殊要求）
- 计数排序：适合**整数、小范围**
- 桶排序：适合**均匀分布**的浮点数据
- 基数排序：适合**定长整数或字符串**，如身份证号、电话号码