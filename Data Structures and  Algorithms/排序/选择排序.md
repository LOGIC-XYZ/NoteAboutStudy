selection sort：通过循环，每轮在**未排序的区间**选择**最小的元素**，然后把它放在**已经排完序的元素区间**的**末尾**。（外层循环把每一轮最小的扔前面去）

# 选择排序
1. 初始状态下，所有元素未排序，即未排序（索引）区间为 $[0,n−1]$ 。
2. 选取区间 $[0,n−1]$ 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。
3. 选取区间 $[1,n−1]$ 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。
4. 以此类推。经过 n−1 轮选择与交换后，数组前 n−1 个元素已排序。
5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。

# 代码实现
```cpp
void selectionSort(vector<int> &nums) {
    int n = nums.size();
    // 外循环：未排序区间为 [i, n-1]
    for (int i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        int k = i;
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[k])
                k = j; // 记录最小元素的索引
        }
        // 将该最小元素与未排序区间的首个元素交换
        swap(nums[i], nums[k]);
    }
}
```

# 算法特性
1. 时间复杂度为$O(n^2)$、非自适应排序：外循环共 n−1 轮，第一轮的未排序区间长度为 n ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 n、n−1、…、3、2 轮内循环，求和为 $\frac{(n - 1)(n + 2)}{2}$ 。
2.  空间复杂度为$O(1)$、原地排序：指针 i 和 j 使用常数大小的额外空间。
3. 非稳定排序，当有重复元素时，可能导致两者的相对顺序发生改变（[[NoteAboutStudy/Data Structures and  Algorithms/排序/排序算法]]）