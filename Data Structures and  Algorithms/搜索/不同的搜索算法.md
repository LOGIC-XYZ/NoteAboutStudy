**搜索算法**（searching algorithm）用于在数据结构中搜索一个或一组满足特定条件的元素。
## 暴力搜索
通过遍历数据结构的每个元素来定位目标元素，简单且通用性好，**无须对数据做预处理和借助额外的数据结构**。
## 自适应搜索
利用数据的==特有属性==来优化搜索过程（前提是有特有属性，这就需要对数据进行==预处理==了）
自适应搜索算法常被称为查找算法，**主要用于在特定数据结构中快速检索目标元素**。
## 选择搜索算法
效率对比![[attachments/Pasted image 20250416211908.png]]
**线性搜索**
- 通用性较好，无须任何数据预处理操作。假如我们仅需查询一次数据，那么其他三种方法的数据预处理的时间比线性搜索的时间还要更长。
- 适用于体量较小的数据，此情况下时间复杂度对效率影响较小。
- 适用于数据更新频率较高的场景，因为该方法不需要对数据进行任何额外维护。

**[[二分查找]]**
- 适用于大数据量的情况，效率表现稳定，最差时间复杂度为 O(log⁡n) 。
- 数据量不能过大，因为存储数组需要连续的内存空间。
- 不适用于高频增删数据的场景，因为维护有序数组的开销较大。

**[[哈希优化策略]]**
- 适合对查询性能要求很高的场景，平均时间复杂度为 O(1) 。
- 不适合需要有序数据或范围查找的场景，因为[[../哈希表/哈希表]]无法维护数据的有序性。
- 对哈希函数和哈希冲突处理策略的依赖性较高，具有较大的性能劣化风险。
- 不适合数据量过大的情况，因为哈希表需要额外空间来最大程度地减少冲突，从而提供良好的查询性能。

**树查找**
- 适用于海量数据，因为[[../树/树]]节点在内存中是分散存储的。
- 适合需要维护有序数据或范围查找的场景。
- 在持续增删节点的过程中，二叉搜索树可能产生倾斜，时间复杂度劣化至 O(n) 。
- 若使用 [[../树/AVL树]] 或[[../树/红黑树]]，则各项操作可在 O(log⁡n) 效率下稳定运行，但维护树平衡的操作会增加额外的开销。