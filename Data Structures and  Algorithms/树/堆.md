**堆**（heap）是一种满足特定条件的完全[[NoteAboutStudy/Data Structures and  Algorithms/树/二叉树]]。主要分为两种类型
- **小顶堆**（min heap）- 任意节点的值 $\leq$ 其子节点的值。
- **大顶堆**（max heap）- 任意节点的值 $\geq$ 其子节点的值。

#### 特性
- 最底层节点靠左填充，其他层的节点都被填满。
- 将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。
- 对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的。

## 堆的常用操作
**堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列**（具有优先级排列的[[NoteAboutStudy/Data Structures and  Algorithms/队列]]）。从使用角度来看，可以将“优先队列（priority queue）”和“堆”看作等价的数据结构。因此，统一称作“堆”。
```cpp
/* 初始化堆 */
// 初始化小顶堆
priority_queue<int, vector<int>, greater<int>> minHeap;
// 初始化大顶堆
priority_queue<int, vector<int>, less<int>> maxHeap;

/* 元素入堆 */
maxHeap.push(1);
maxHeap.push(3);
maxHeap.push(2);
maxHeap.push(5);
maxHeap.push(4);

/* 获取堆顶元素 */
int peek = maxHeap.top(); // 5

/* 堆顶元素出堆 */
// 出堆元素会形成一个从大到小的序列
maxHeap.pop(); // 5
maxHeap.pop(); // 4
maxHeap.pop(); // 3
maxHeap.pop(); // 2
maxHeap.pop(); // 1

/* 获取堆大小 */
int size = maxHeap.size();

/* 判断堆是否为空 */
bool isEmpty = maxHeap.empty();

/* 输入列表并建堆 */
vector<int> input{1, 3, 2, 5, 4};
priority_queue<int, vector<int>, greater<int>> minHeap(input.begin(), input.end());
```

## 堆的实现
以下为大顶堆的实现，若要实现小顶堆，可将所有大小逻辑判断进行逆转（将 $\geq$ 替换为 $\leq$ ）。
### 堆的存储与表示
使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。**节点指针通过索引映射公式来实现**。
**给定索引 $i$ ，其左子节点的索引为 $2i+1$ ，其右子节点的索引为 $2i+2$ ，其parent节点的索引为 $(i-1)/2$ 。**

### 元素入堆
给定元素 `val` ，首先将其添加到堆底。添加之后，由于 `val` 可能大于堆中其他元素，堆的成立条件可能已被破坏，**因此需要修复从插入节点到根节点的路径上的各个节点**，这个操作被称为堆化（heapify）。
1. 考虑从入堆节点开始，**从底至顶执行堆化**。
2. 比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。
```cpp
/* 元素入堆 */
void push(int val) {
    // 添加节点
    maxHeap.push_back(val);
    // 从底至顶堆化
    siftUp(size() - 1);
}

/* 从节点 i 开始，从底至顶堆化 */
void siftUp(int i) {
    while (true) {
        // 获取节点 i 的父节点
        int p = parent(i);
        // 当“越过根节点”或“节点无须修复”时，结束堆化
        if (p < 0 || maxHeap[i] <= maxHeap[p])
            break;
        // 交换两节点
        swap(maxHeap[i], maxHeap[p]);
        // 循环向上堆化
        i = p;
    }
}
```

### 堆顶元素出堆
堆顶元素是二叉树的根节点，即列表首元素。如果直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。所以执行以下操作以减少变动：
1. 交换堆顶元素与堆底元素（交换根节点与最右叶节点）。
2. 交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）。
3. 从根节点开始，**从顶至底执行堆化**。
```cpp
/* 元素出堆 */
void pop() {
    // 判空处理
    if (isEmpty()) {
        throw out_of_range("堆为空");
    }
    // 交换根节点与最右叶节点（交换首元素与尾元素）
    swap(maxHeap[0], maxHeap[size() - 1]);
    // 删除节点
    maxHeap.pop_back();
    // 从顶至底堆化
    siftDown(0);
}

/* 从节点 i 开始，从顶至底堆化 */
void siftDown(int i) {
    while (true) {
        // 判断节点 i, l, r 中值最大的节点，记为 ma
        int l = left(i), r = right(i), ma = i;
        if (l < size() && maxHeap[l] > maxHeap[ma])
            ma = l;
        if (r < size() && maxHeap[r] > maxHeap[ma])
            ma = r;
        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出
        if (ma == i)
            break;
        swap(maxHeap[i], maxHeap[ma]);
        // 循环向下堆化
        i = ma;
    }
}
```

## 建堆操作
用一个列表的所有元素来构建一个堆。
### 通过入堆操作实现
首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。

之后每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。

设元素数量为 n ，每个元素的入堆操作使用 $O(log⁡(n))$ 时间，因此该建堆方法的时间复杂度为 $O(nlog(⁡n))$ 。
### 通过遍历堆化实现
1. 将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。
2. 倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。
**每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆**。而由于是倒序遍历，因此堆是“自下而上”构建的。（倒序遍历的原因是能够保证当前节点的子树可以形成合法的子堆，而叶节点没有子节点，所以本身就是合法的子堆）
```cpp
/* 构造方法，根据输入列表建堆 */
MaxHeap(vector<int> nums) {
    // 将列表元素原封不动添加进堆
    maxHeap = nums;
    // 堆化除叶节点以外的其他所有节点
    for (int i = parent(size() - 1); i >= 0; i--) {
        siftDown(i);  //该函数在堆顶元素出堆中有定义
    }
}
```
时间复杂度为$O(n)$。

## Top-k问题
Q：给定一个长度为 n 的无序数组 `nums` ，请返回数组中最大的 k 个元素。
### 遍历选择
进行`k`轮遍历，分别在每轮中提取第 1、2、……、k 大的元素，时间复杂度为$O(nk)$。
只适用于 k≪n 的情况，因为当 k 与 n 比较接近时，其时间复杂度趋向于 $O(n^2)$。而当 k=n 时，可以得到完整的有序序列，此时等价于“选择排序”算法。（ps：一个一个的去找，按照大小，这样找出来之后也排好了，就是一轮轮遍历比较耗时）

### 排序
先对数组 `nums` 进行排序，再返回最右边的 k 个元素，时间复杂度为 $O(nlog(⁡n))$。（ps：思路很简单，先排完序，再选择，就是排序的时间复杂度较高）

### 堆
1. 初始化一个小顶堆，其堆顶元素最小。
2. 先将数组的前 k 个元素依次入堆。
3. 从第 k+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。
4. 遍历完成后，堆中保存的就是最大的 k 个元素。
```cpp
/* 基于堆查找数组中最大的 k 个元素 */
priority_queue<int, vector<int>, greater<int>> topKHeap(vector<int> &nums, int k) {
    // 初始化小顶堆
    priority_queue<int, vector<int>, greater<int>> heap;
    // 将数组的前 k 个元素入堆
    for (int i = 0; i < k; i++) {
        heap.push(nums[i]);
    }
    // 从第 k+1 个元素开始，保持堆的长度为 k
    for (int i = k; i < nums.size(); i++) {
        // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆
        if (nums[i] > heap.top()) {
            heap.pop();
            heap.push(nums[i]);
        }
    }
    return heap;
}
```
总共执行了 n 轮入堆和出堆，堆的最大长度为 k ，因此时间复杂度为 $O(nlog⁡(k))$ 。该方法的效率很高，当 k 较小时，时间复杂度趋向 $O(n)$ ；当 k 较大时，时间复杂度不会超过 $O(nlog(⁡n))$ 。 

## Q：数据结构的“堆”与内存管理的“堆”是同一个概念吗？
| 名称   | 数据结构的堆      | 内存管理的堆       |
| ---- | ----------- | ------------ |
| 定义   | 完全二叉树，优先级结构 | 程序运行时动态分配的内存 |
| 实现方式 | 数组          | 内存块，由操作系统管理  |
| 应用场景 | 优先队列、排序等算法  | 创建动态对象、数组等   |
