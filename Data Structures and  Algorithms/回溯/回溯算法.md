backtracking algorithm：是一种通过**穷举**来解决问题的方法，它的核心思想是从一个初始状态(state)出发，暴力搜索**所有可能的解决方案**，当遇到正确的解(solution)则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。通常采用“**深度优先搜索（DFS）**”来遍历解空间，且在搜索解空间时会采用“**尝试(attempt)**（前进操作）”与“**回退(backtracking)**（撤销操作）”。

有的回溯问题会包含一个或多个**约束条件(constraint)**，此时需要“**剪枝(pruning)**”操作，当遇到**不满足约束条件的搜索分支**时，“剪掉”该分支，即提前返回，不再继续搜索该分支。
# 框架代码
`state` 表示问题的当前状态，`choices` 表示当前状态下可以做出的选择
```cpp
/* 回溯算法框架 */
void backtrack(State *state, vector<Choice *> &choices, vector<State *> &res) {
    // 判断是否为解
    if (isSolution(state)) {
        // 记录解
        recordSolution(state, res);
        // 不再继续搜索
        return;
    }
    // 遍历所有选择
    for (Choice choice : choices) {
        // 剪枝：判断选择是否合法
        if (isValid(state, choice)) {
            // 尝试：做出选择，更新状态
            makeChoice(state, choice);
            backtrack(state, choices, res);
            // 回退：撤销选择，恢复到之前的状态
            undoChoice(state, choice);
        }
    }
}
```

# 优点与局限性
本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率。
然而，在处理大规模或者复杂问题时，**回溯算法的运行效率可能难以接受**。
- **时间**：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶。
- **空间**：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大。
即便如此，**回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案**。对于这些问题，由于无法预测哪些选择可生成有效的解，因此必须对所有可能的选择进行遍历。在这种情况下，**关键是如何优化效率**，常见的效率优化方法有两种。
- **剪枝**：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。
- **启发式搜索**：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。

# 回溯典型例题
- [[全排列问题]]
- [[子集和问题]]
- [[n 皇后问题]]