**Floyd算法**（Floyd-Warshall算法）用于求解**带权有向图或无向图**中所有顶点对之间的**最短路径**。其核心思想是动态规划，通过逐步引入中间顶点来优化路径。算法支持处理负权边，但**不允许存在负权环**。

---

### **Floyd算法的核心思想**
设想每个点都可能成为路径上的“中间点”，如果经过该点能够缩短两点之间的距离，就更新路径。

```c
/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    
void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{    
    int v,w,k;    
    for(v=0; v<G.numVertexes; ++v) /* 初始化D与P */  
    {        
        for(w=0; w<G.numVertexes; ++w)  
        {
            (*D)[v][w]=G.arc[v][w]; /* D[v][w]值即为对应点间的权值 */
            (*P)[v][w]=w;               /* 初始化P */
        }
    }
    for(k=0; k<G.numVertexes; ++k)  
    {
        for(v=0; v<G.numVertexes; ++v)  
        {        
            for(w=0; w<G.numVertexes; ++w)    
            {
                if ((*D)[v][w]>(*D)[v][k]+(*D)[k][w])
                {/* 如果经过下标为k顶点路径比原两点间路径更短 */
                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */
                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */
                }
            }
        }
    }
}
```
### **Floyd算法的详细步骤**
1. **初始化**
	- 创建两个矩阵：
	    - `D[][]`：记录当前已知的最短路径长度（初始值为原图的权重）。
	    - `P[][]`：记录路径的中间点，初始为 `P[v][w] = w`，表示 `v` 到 `w` 直接相连。

2. **核心循环（引入“中间点”）**
	三重循环，依次考虑每个点 `k` 作为“中间点”时是否能优化路径，逐步优化 `D[v][w]`。
	**更新条件：**
	`如果 D[v][w] > D[v][k] + D[k][w]     则 D[v][w] = D[v][k] + D[k][w]     P[v][w] = P[v][k]   // 更新中间点`

3. **输出结果**
	- `D[v][w]` 就是 `v` 到 `w` 的最短路径长度。
	- `P[v][w]` 可用于回溯路径，输出具体的行进路线。

