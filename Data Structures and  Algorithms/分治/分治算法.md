divide and conquer（分而治之）：是一种算法策略，通常基于[[NoteAboutStudy/Data Structures and  Algorithms/递归]]实现。包括“分”和“治”两个步骤，分（划分阶段） -- 递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止；治（合并阶段） -- 从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。（[[NoteAboutStudy/Data Structures and  Algorithms/排序/归并排序]]是分治的典型应用之一）

# 是否适合使用分治？
1. **问题可以分解**：原问题可以分解成规模更小、类似的子问题（**互不重叠**），以及能够以相同方式递归地进行划分。
2. **子问题是独立的**：子问题之间没有重叠，互不依赖，可以独立解决。
3. **子问题的解可以合并**：原问题的解通过合并子问题的解得来。

# 分治提升效率
**分治不仅可以有效地解决算法问题，往往还可以提升算法效率**。例如在排序算法中，[[NoteAboutStudy/Data Structures and  Algorithms/排序/快速排序]]、[[NoteAboutStudy/Data Structures and  Algorithms/排序/归并排序]]、[[NoteAboutStudy/Data Structures and  Algorithms/排序/堆排序]]相较于[[NoteAboutStudy/Data Structures and  Algorithms/排序/选择排序]]、[[NoteAboutStudy/Data Structures and  Algorithms/排序/冒泡排序]]、[[NoteAboutStudy/Data Structures and  Algorithms/排序/插入排序]]更快，就是因为它们应用了分治策略。所以为什么分治可以提升算法效率？分而治之为什么会比直接解决效率更高？
## 操作数量优化
以“冒泡排序”为例，其处理一个长度为 n 的数组需要 $O(n^2)$ 时间。假设将数组从中点处分为两个子数组，则划分需要 O(n) 时间，排序每个子数组需要 $O((n/2)^2)$ 时间，合并两个子数组需要 O(n) 时间，总体时间复杂度为：$O(n^2/2 + 2n)$，这意味着当 n > 4 时，划分后的操作数量更少，排序效率更高。（请注意，划分后的时间复杂度仍然是平方阶 $O(n^2)$ ，只是复杂度中的常数项变小了。）
**如果把子数组不断地再从中点处划分为两个子数组**，直至子数组只剩一个元素时停止划分呢？这种思路实际上就是“[[NoteAboutStudy/Data Structures and  Algorithms/排序/归并排序]]”，时间复杂度为 O(nlog⁡n) 。
**如果多设置几个划分点**，将原数组平均划分为 k 个子数组呢？这种情况与“[[NoteAboutStudy/Data Structures and  Algorithms/排序/桶排序]]”非常类似，它非常适合排序海量数据，理论上时间复杂度可以达到 O(n+k) 。

## 并行计算优化
分治生成的子问题是相互独立的，**因此通常可以并行解决**。也就是说，分治不仅可以降低算法的时间复杂度，**还有利于操作系统的并行优化**。
并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间。

# 分治常见应用
一方面，分治可以用来解决许多经典算法问题。
- **寻找最近点对**：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对。
- **大整数乘法**：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法。
- **矩阵乘法**：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法。
- **[[NoteAboutStudy/Data Structures and  Algorithms/分治/汉诺塔问题]]**
- **求解逆序对**：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解。
另一方面，分治在算法和数据结构的设计中应用得非常广泛。
- **[[NoteAboutStudy/Data Structures and  Algorithms/搜索/二分查找]]**：是分治策略的另一个典型应用，它不包含将子问题的解进行合并的步骤。
- **[[NoteAboutStudy/Data Structures and  Algorithms/排序/归并排序]]**
- **[[NoteAboutStudy/Data Structures and  Algorithms/排序/快速排序]]**
- **[[NoteAboutStudy/Data Structures and  Algorithms/排序/桶排序]]**
- **[[NoteAboutStudy/Data Structures and  Algorithms/树/树]]**：例如[[NoteAboutStudy/Data Structures and  Algorithms/树/二叉搜索树]]、[[NoteAboutStudy/Data Structures and  Algorithms/树/AVL树]]、[[NoteAboutStudy/Data Structures and  Algorithms/树/红黑树]]、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用，也可以[[NoteAboutStudy/Data Structures and  Algorithms/分治/构建二叉树问题]]（已知前序遍历与中序遍历，构建二叉树）。
- **[[NoteAboutStudy/Data Structures and  Algorithms/树/堆]]**：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。
- **[[NoteAboutStudy/Data Structures and  Algorithms/哈希表/哈希表]]**：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。

