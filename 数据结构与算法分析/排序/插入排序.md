insertion sort：通过循环，每轮在**未排序的区间**（初始时，就当第一个元素已完成排序）里选择一个**基准元素**（一般是未排序的区间里的第一个元素），并将该元素与**已排序区间**中的元素逐一比较大小（一般由大到小进行比较），并将该元素插入到合适的位置。（ps：就像是牌类游戏里的排序，扑克的大小顺序我真的是学了又忘，顶天两小时保质期）
# 算法流程
1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。
3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。
4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。

# 代码实现
```cpp
void insertionSort(vector<int> &nums) {
    // 外循环：已排序区间为 [0, i-1]
    for (int i = 1; i < nums.size(); i++) {
        int base = nums[i], j = i - 1;
        // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置
        while (j >= 0 && nums[j] > base) {
            nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位
            j--;
        }
        nums[j + 1] = base; // 将 base 赋值到正确位置
    }
}
```

# 算法特性
1. 时间复杂度为$O(n^2)$、自适应排序：在最差情况下，每次插入操作分别需要循环 n−1、n−2、…、2、1 次，求和得到 $\frac{(n - 1)n}{2}$ ，因此时间复杂度为 $O(n^2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 O(n) 。
2.  空间复杂度为$O(1)$、原地排序：指针 i 和 j 使用常数大小的额外空间。
3. 稳定排序

# 优势
插入排序的时间复杂度为 $O(n^2)$ ，而[[快速排序]]的时间复杂度为 $O(nlog⁡n)$ 。尽管插入排序的时间复杂度更高，**但在数据量较小的情况下，插入排序通常更快**。

这个结论与线性查找和[[二分查找]]的适用情况的结论类似。快速排序这类$O(nlog⁡n)$ 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，$n^2$ 和 $nlog⁡n$ 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。

实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：**对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。**

虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $O(n^2)$，但在实际情况中，**插入排序的使用频率显著高于[[冒泡排序]]和[[选择排序]]**，主要有以下原因。
- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**。
- 选择排序在任何情况下的时间复杂度都为$O(n^2)$ 。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高**。
- 选择排序不稳定，无法应用于多级排序。