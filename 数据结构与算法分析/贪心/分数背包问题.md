**Q**：给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i−1]$、价值为 $val[i−1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，**但可以选择物品的一部分，价值根据选择的重量比例计算**，问在限定背包容量下背包中物品的最大价值。

# 问题分析
分数背包问题和 0-1 [[背包问题]]整体上非常相似，状态包含当前物品 $i$ 和容量 $c$ ，目标是求限定背包容量下的最大价值。

不同点在于，本题允许只选择物品的一部分。因此，可以对物品任意地进行切分，并按照重量比例来计算相应价值。
1. 对于物品 $i$ ，它在单位重量下的价值为 $val[i−1]/wgt[i−1]$ ，简称单位价值。
2. 假设放入一部分物品 $i$ ，重量为 $w$ ，则背包增加的价值为 $w×val[i−1]/wgt[i−1]$ 。

# 确定贪心策略
最大化背包内物品总价值，**本质上是最大化单位重量下的物品价值**。由此便可推理出贪心策略：
1. 将物品按照单位价值从高到低进行排序。
2. 遍历所有物品，**每轮贪心地选择单位价值最高的物品**。
3. 若剩余背包容量不足，则使用当前物品的一部分填满背包。

## 代码实现
建立了一个物品类 `Item` ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解。
```cpp
class Item {
  public:
    int w; // 物品重量
    int v; // 物品价值

    Item(int w, int v) : w(w), v(v) {
    }
};
double fractionalKnapsack(vector<int> &wgt, vector<int> &val, int cap) {
    // 创建物品列表，包含两个属性：重量、价值
    vector<Item> items;
    for (int i = 0; i < wgt.size(); i++) {
        items.push_back(Item(wgt[i], val[i]));
    }
    // 按照单位价值 item.v / item.w 从高到低进行排序
    sort(items.begin(), items.end(), [](Item &a, Item &b) { return (double)a.v / a.w > (double)b.v / b.w; });
    // 循环贪心选择
    double res = 0;
    for (auto &item : items) {
        if (item.w <= cap) {
            // 若剩余容量充足，则将当前物品整个装进背包
            res += item.v;
            cap -= item.w;
        } else {
            // 若剩余容量不足，则将当前物品的一部分装进背包
            res += (double)item.v / item.w * cap;
            // 已无剩余容量，因此跳出循环
            break;
        }
    }
    return res;
}
```
内置排序算法的时间复杂度通常为 O(log⁡n) ，空间复杂度通常为 O(log⁡n) 或 O(n) ，取决于编程语言的具体实现。
除排序之外，在最差情况下，需要遍历整个物品列表，**因此时间复杂度为 O(n)** ，其中 n 为物品数量。
由于初始化了一个 `Item` 对象列表，**因此空间复杂度为 O(n)** 。

# 正确性证明
