**Dijkstra算法**用于求解**带权有向图或无向图**中**单源点**到其余所有顶点的**最短路径**。算法基于[[贪心策略]]，逐步确定离源点最近的顶点，并更新其邻接顶点的最短距离。要求图中**边权非负**。

---
### **Dijkstra算法的核心思想**
假设从起点 `v0` 出发，要找到从 `v0` 到其他所有顶点的最短路径。  
- 初始时，**已知起点到自身的最短路径为0**，到其他所有顶点的距离设为无穷大（∞）  
- 每次在“未确定最短路径”的点中，选出距离起点**最近**的点，并将其标记为“已确定”  
- 更新其邻接点的最短路径长度  
- 重复上述步骤，直到所有点都标记为“已确定”

```
/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    
/* P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */ 
void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{    
    int v,w,k,min;    
    int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */
    for(v=0; v<G.numVertexes; v++)    /* 初始化数据 */
    {        
        final[v] = 0;           /* 全部顶点初始化为未知最短路径状态 */
        (*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */
        (*P)[v] = -1;               /* 初始化路径数组P为-1  */      
    }
    (*D)[v0] = 0;  /* v0至v0路径为0 */  
    final[v0] = 1;    /* v0至v0不需要求路径 */        
    /* 开始主循环，每次求得v0到某个v顶点的最短路径 */  
    for(v=1; v<G.numVertexes; v++)  
    {
        min=GRAPH_INFINITY;    /* 当前所知离v0顶点的最近距离 */        
        for(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    
        {            
            if(!final[w] && (*D)[w]<min)            
            {                  
                k=w;                    
                min = (*D)[w];    /* w顶点离v0顶点更近 */            
            }        
        }        
        final[k] = 1;    /* 将目前找到的最近的顶点置为1 */
        for(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */
        {
            /* 如果经过v顶点的路径比现在这条路径的长度短的话 */
            if(!final[w] && (min+G.arc[k][w]<(*D)[w])) 
            { /*  说明找到了更短的路径，修改D[w]和P[w] */
                (*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */              
                (*P)[w]=k;        
            }      
        }  
    }
}
```
### **Dijkstra算法的详细步骤**
1. **初始化**
    - 创建一个数组 `D[]`，表示从起点 `v0` 到每个点的最短路径长度，初始值为无穷大（∞）
    - 创建一个数组 `P[]`，用于记录每个顶点的**前驱节点**，初始值为 `-1`
    - 创建一个布尔型数组 `final[]`，表示哪些顶点已确定最短路径，初始时所有点均为 `0`（未确定）
    - 将 `v0` 标记为已确定，即 `final[v0] = 1`，并将 `D[v0]` 设为 `0`

2. **主循环（共执行 `n-1` 次）**  
    每次从未确定的点中选出一个距离起点 `v0` 最近的顶点 `k`，然后：
    - 标记 `final[k] = 1`，表示 `k` 已确定最短路径
    - 更新 `k` 的邻接点 `w` 的最短路径，如果 `D[w] > D[k] + G.arc[k][w]`，则更新 `D[w]` 并记录 `P[w] = k`

3. **结束**  
    所有点都被标记为已确定后，`D[]` 数组中就存储了起点 `v0` 到其他所有顶点的最短路径长度，而 `P[]` 则记录了每个顶点的最短路径上的前驱节点。