dynamic programing：将一个问题分解为一系列更小的子问题，并通过记录中间结果来避免重复计算，从而大幅提升时间效率。常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

# 经典例题引入
**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶？

## [[回溯算法]]
因为目标是求解方案数量，可以通过回溯来穷举所有可能性。（这种方法同时可以列举出所有可能的路径，以下代码即是）
```cpp
void backtrack(int n, int i, vector<int> &path, vector<vector<int>> &res) {
    if (i == n) {
        res.push_back(path); // 到达终点，记录一条路径
        return;
    }
    if (i > n) return; // 超过终点，剪枝

    // 尝试走 1 步
    path.push_back(1);
    backtrack(n, i + 1, path, res);
    path.pop_back();

    // 尝试走 2 步
    path.push_back(2);
    backtrack(n, i + 2, path, res);
    path.pop_back();
}
vector<vector<int>> climbStairsPaths(int n) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(n, 0, path, res);
    return res;
}
# 若只返回路径数量，可以通过计数器
```

## 推论
爬到第 $i−1$ 阶的方案数加上爬到第 $i−2$ 阶的方案数就等于爬到第 $i$ 阶的方案数，即$$dp[i]=dp[i-1]+dp[i-2]$$各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**。

## 暴力搜索
brute-force search：**通过遍历所有可能的情况来寻找问题的解**。虽然效率较低，但它是解决问题的出发点，常用于：构造回溯、剪枝、动态规划等高级算法的基础；解空间不大时可直接使用；算法竞赛中作为暴力对拍或验证的参考解。（与回溯类似，都属于DFS，但更简洁）
```cpp
int dfs(int i) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}
int climbingStairsDFS(int n) {
    return dfs(n);
}
```
会形成深度为 $n$ 的递归树，时间复杂度为$O(2^n)$，其指数阶的时间复杂度是“**重叠子问题**”导致的。

## 记忆化搜索
memoization：是一种结合了递归和动态规划思想的方法，也叫**自顶向下的动态规划**。通过[[递归]]和缓存中间结果，避免重复计算。 
为提升算法效率，希望所有的重叠子问题都只被计算一次，为此，通过声明一个数组`men`来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。
