dynamic programing：将一个问题分解为一系列更小的子问题，并通过记录中间结果来避免重复计算，从而大幅提升时间效率。常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

# 经典例题引入
**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶？

## [[回溯算法]]
因为目标是求解方案数量，可以通过回溯来穷举所有可能性。（这种方法同时可以列举出所有可能的路径，以下代码即是）
```cpp
void backtrack(int n, int i, vector<int> &path, vector<vector<int>> &res) {
    if (i == n) {
        res.push_back(path); // 到达终点，记录一条路径
        return;
    }
    if (i > n) return; // 超过终点，剪枝

    // 尝试走 1 步
    path.push_back(1);
    backtrack(n, i + 1, path, res);
    path.pop_back();

    // 尝试走 2 步
    path.push_back(2);
    backtrack(n, i + 2, path, res);
    path.pop_back();
}
vector<vector<int>> climbStairsPaths(int n) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(n, 0, path, res);
    return res;
}

```