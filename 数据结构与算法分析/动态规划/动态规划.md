dynamic programing：将一个问题分解为一系列更小的子问题，并通过记录中间结果来避免重复计算，从而大幅提升时间效率。常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

# 经典例题引入
**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶？

## [[回溯算法]]
因为目标是求解方案数量，可以通过回溯来穷举所有可能性。（这种方法同时可以列举出所有可能的路径，以下代码即是，# 若只返回路径数量，可以通过计数器）
```cpp
void backtrack(int n, int i, vector<int> &path, vector<vector<int>> &res) {
    if (i == n) {
        res.push_back(path); // 到达终点，记录一条路径
        return;
    }
    if (i > n) return; // 超过终点，剪枝

    // 尝试走 1 步
    path.push_back(1);
    backtrack(n, i + 1, path, res);
    path.pop_back();

    // 尝试走 2 步
    path.push_back(2);
    backtrack(n, i + 2, path, res);
    path.pop_back();
}
vector<vector<int>> climbStairsPaths(int n) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(n, 0, path, res);
    return res;
}

```

## 推论
爬到第 $i−1$ 阶的方案数加上爬到第 $i−2$ 阶的方案数就等于爬到第 $i$ 阶的方案数，即$$dp[i]=dp[i-1]+dp[i-2]$$各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**。

## 暴力搜索
brute-force search：**通过遍历所有可能的情况来寻找问题的解**。虽然效率较低，但它是解决问题的出发点，常用于：构造回溯、剪枝、动态规划等高级算法的基础；解空间不大时可直接使用；算法竞赛中作为暴力对拍或验证的参考解。（与回溯类似，都属于DFS，但更简洁）
```cpp
int dfs(int i) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}
int climbingStairsDFS(int n) {
    return dfs(n);
}
```
会形成深度为 $n$ 的递归树，时间复杂度为$O(2^n)$，其指数阶的时间复杂度是“**重叠子问题**”导致的。

## 记忆化搜索
memoization：是一种结合了[[递归]]和动态规划思想的方法，也叫**自顶向下的动态规划**。 从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。通过递归和缓存中间结果，避免重复计算。

通过声明一个数组`men`来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。
```cpp
int dfs(int i, vector<int> &mem) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // 若存在记录 dp[i] ，则直接返回之
    if (mem[i] != -1)
        return mem[i];
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    // 记录 dp[i]
    mem[i] = count;
    return count;
}
int climbingStairsDFSMem(int n) {
    // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    vector<int> mem(n + 1, -1);
    return dfs(n, mem);
}
```
**经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至$O(n)$**

## 动态规划
**是一种“从底至顶”的方法**：从最小子问题的解开始，**迭代**地构建更大子问题的解，直至得到原问题的解。

通过初始化一个数组 `dp` 来存储子问题的解，它起到了与记忆化搜索中数组 `mem` 相同的记录作用：
```cpp
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
![[Pasted image 20250517220918.png]]
因为 $dp[i]$ 只与 $dp[i−1]$ 和 $dp[i−2]$ 有关，所以无须使用一个数组 `dp` 来存储所有子问题的解，只需两个变量滚动前进即可。
```cpp
int climbingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
```
由于省去了数组 `dp` 占用的空间，因此空间复杂度从 $O(n)$ 降至 $O(1)$ 。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

## 记忆化搜索与动态规划的比较
| 特性      | 记忆化搜索（递归）       | 动态规划（迭代）        |
| ------- | --------------- | --------------- |
| 执行顺序    | 自顶向下（从大问题拆到小问题） | 自底向上（从小问题推出大问题） |
| 写法风格    | 递归，代码简洁，易读      | 循环，结构清晰，控制明确    |
| 重复子问题处理 | 使用缓存表避免重复计算     | 每个子问题只算一次       |
| 性能      | 递归有函数栈开销        | 通常更快，空间更可控      |
| 适用场景    | 状态较少或不确定的子问题空间  | 状态空间确定的优化问题     |

# DP问题特性
## 最优子结构
**原问题的最优解是从子问题的最优解构建得来的**。

**Q**：给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 $cost$ ，其中 $cost[i]$ 表示在第 $i$ 个台阶需要付出的代价，$cost[0]$ 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？

$$dp[i] = min(dp[i-1],dp[i-2]) + cost[i]$$

```cpp
int minCostClimbingStairsDPComp(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = min(a, tmp) + cost[i];
        a = tmp;
    }
    return b;
}
```
## 无后效性
