dynamic programing：将一个问题分解为一系列更小的子问题，并通过记录中间结果来避免重复计算，从而大幅提升时间效率。常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

# 经典例题引入
**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶？

## [[回溯算法]]
因为目标是求解方案数量，可以通过回溯来穷举所有可能性。（这种方法同时可以列举出所有可能的路径，以下代码即是，# 若只返回路径数量，可以通过计数器）
```cpp
void backtrack(int n, int i, vector<int> &path, vector<vector<int>> &res) {
    if (i == n) {
        res.push_back(path); // 到达终点，记录一条路径
        return;
    }
    if (i > n) return; // 超过终点，剪枝

    // 尝试走 1 步
    path.push_back(1);
    backtrack(n, i + 1, path, res);
    path.pop_back();

    // 尝试走 2 步
    path.push_back(2);
    backtrack(n, i + 2, path, res);
    path.pop_back();
}
vector<vector<int>> climbStairsPaths(int n) {
    vector<vector<int>> res;
    vector<int> path;
    backtrack(n, 0, path, res);
    return res;
}

```

## 推论
爬到第 $i−1$ 阶的方案数加上爬到第 $i−2$ 阶的方案数就等于爬到第 $i$ 阶的方案数，即$$dp[i]=dp[i-1]+dp[i-2]$$各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**。

## 暴力搜索
brute-force search：**通过遍历所有可能的情况来寻找问题的解**。虽然效率较低，但它是解决问题的出发点，常用于：构造回溯、剪枝、动态规划等高级算法的基础；解空间不大时可直接使用；算法竞赛中作为暴力对拍或验证的参考解。（与回溯类似，都属于DFS，但更简洁）
```cpp
int dfs(int i) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}
int climbingStairsDFS(int n) {
    return dfs(n);
}
```
会形成深度为 $n$ 的递归树，时间复杂度为$O(2^n)$，其指数阶的时间复杂度是“**重叠子问题**”导致的。

## 记忆化搜索
memoization：是一种结合了[[递归]]和动态规划思想的方法，也叫**自顶向下的动态规划**。 从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。通过递归和缓存中间结果，避免重复计算。

通过声明一个数组`men`来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。
```cpp
int dfs(int i, vector<int> &mem) {
    // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // 若存在记录 dp[i] ，则直接返回之
    if (mem[i] != -1)
        return mem[i];
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    // 记录 dp[i]
    mem[i] = count;
    return count;
}
int climbingStairsDFSMem(int n) {
    // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    vector<int> mem(n + 1, -1);
    return dfs(n, mem);
}
```
**经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至$O(n)$**

## 动态规划
**是一种“从底至顶”的方法**：从最小子问题的解开始，**迭代**地构建更大子问题的解，直至得到原问题的解。

通过初始化一个数组 `dp` 来存储子问题的解，它起到了与记忆化搜索中数组 `mem` 相同的记录作用：
```cpp
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
![[Pasted image 20250517220918.png]]
因为 $dp[i]$ 只与 $dp[i−1]$ 和 $dp[i−2]$ 有关，所以无须使用一个数组 `dp` 来存储所有子问题的解，只需两个变量滚动前进即可。
```cpp
int climbingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
```
由于省去了数组 `dp` 占用的空间，因此空间复杂度从 $O(n)$ 降至 $O(1)$ 。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

## 记忆化搜索与动态规划的比较
| 特性      | 记忆化搜索（递归）       | 动态规划（迭代）        |
| ------- | --------------- | --------------- |
| 执行顺序    | 自顶向下（从大问题拆到小问题） | 自底向上（从小问题推出大问题） |
| 写法风格    | 递归，代码简洁，易读      | 循环，结构清晰，控制明确    |
| 重复子问题处理 | 使用缓存表避免重复计算     | 每个子问题只算一次       |
| 性能      | 递归有函数栈开销        | 通常更快，空间更可控      |
| 适用场景    | 状态较少或不确定的子问题空间  | 状态空间确定的优化问题     |

# DP问题特性
## 最优子结构
**原问题的目标解是从子问题的目标解推导构建得来的**。

**Q**：给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 $cost$ ，其中 $cost[i]$ 表示在第 $i$ 个台阶需要付出的代价，$cost[0]$ 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？

$$dp[i] = min(dp[i-1],dp[i-2]) + cost[i]$$
以下为空间优化后的
```cpp
int minCostClimbingStairsDPComp(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = min(a, tmp) + cost[i];
        a = tmp;
    }
    return b;
}
```
## 无后效性
**给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关**。

以爬楼梯问题为例，给定状态 i ，它会发展出状态 i+1 和状态 i+2 ，分别对应跳 1 步和跳 2 步。在做出这两种选择时，无须考虑状态 i 之前的状态，它们对状态 i 的未来没有影响。

如果添加一个约束，情况就不同了。

**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，**但不能连续两轮跳 1 阶**，请问有多少种方案可以爬到楼顶？

下一步选择不能由当前状态（当前所在楼梯阶数）独立决定，还和前一个状态（上一轮所在楼梯阶数）有关。故之前的状态转移方程失效。为此需要扩展状态定义：**状态 $[i,j]$ 表示处在第 $i$ 阶并且上一轮跳了 $j$ 阶**，其中 $j∈{1,2}$ 。状态转移方程为：$$\begin{cases}
dp[i, 1] = dp[i - 1, 2] \\
dp[i, 2] = dp[i - 2, 1] + dp[i - 2, 2]
\end{cases}$$
```cpp
int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector<vector<int>> dp(n + 1, vector<int>(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i][1] = dp[i - 1][2];
        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];
}
```

以上这个案例由于仅需考虑前面一个状态，因此可以通过扩展状态定义，使其重新满足无后效性，但是有些问题具有非常严重的“有后效性”。如，
**Q**：给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶。**规定当爬到第 i 阶时，系统自动会在第 2i 阶上放上障碍物，之后所有轮都不允许跳到第 2i 阶上**。例如，前两轮分别跳到了第 2、3 阶上，则之后就不能跳到第 4、6 阶上。请问有多少种方案可以爬到楼顶？

在这个问题中，下次跳跃依赖过去所有的状态，因为每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃。对于这类问题，动态规划往往难以解决。此时通常会选择其他方法，如启发式搜索、遗传算法、强化学习等

# DP解题思路
## 问题判断

## 求解步骤

