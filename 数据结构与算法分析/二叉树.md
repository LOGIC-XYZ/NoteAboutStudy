***二叉树***（Binary Tree）是n ($n \geq  0$)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成

 -- **二叉树的特点**
 1. 每个结点最多有两棵子树；
 2. 左子树和右子树是有顺序的，次序不能任意颠倒；
 3. 即使树中某结点只有一棵子树，也要区分其是左子树还是右子树

 -- **特殊二叉树**
 1. **斜树**
	所有结点都只有左子树的二叉树称为左斜树，反之称为右斜树，统称为斜树；
 2. **满二叉树**
	所有分支结点都存在左子树和右子树，并且所有叶子都只能出现在最下一层上；
 3. **完全二叉树**
	 对一棵具有 n 个结点的二叉树按层序编号，如果编号为  i $(1 \le i \le n)$ 的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树
	 1. 叶子结点只能出现在最下两层。
	 2. 最下层的叶子一定集中在左部连续位置。
	 3. 倒数两层，若有叶子结点，一定都在右部连续位置。
	 4. 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。
	 5. 同样结点数的二叉树，完全二叉树的深度最小。

 -- **二叉树的性质**
 1. 在二叉树的第i层至多有 $2^{(i-1)}$ 个结点$(i \ge 1)$;
 2. 深度为k的二叉树至多有 $(2^k)-1$ 个结点$(k \ge 1)$;
 3. 对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则 $n_0$ = $n_2$ + 1；
 4. 具有n个结点的完全二叉树的深度为$\lfloor {log_{2} n} \rfloor + 1$（$\lfloor x \rfloor$表示不大于x的最大整数）；
 5. 如果对一棵有n个结点的完全二叉树（其深度为$\lfloor {log_{2} n} \rfloor + 1$)的结点按层序编号（从第1层到第$\lfloor {log_{2} n} \rfloor + 1$层，每层从左到右)，对任一结点 i$(1 \le i \le n)$有：
	(1)如果 i=1，则结点 i 是二叉树的根，无Parent；如果>1，则其Parent是结点$\lfloor \frac{i}{2} \rfloor$。
	(2)如果2i>n，则结点i无左Child（结点为叶子结点)；否则其左Child是结点2i。
	(3)如果2i+1>n,则结点 i 无右Child；否则其右Child是结点2i+1。

## 二叉树的存储结构
 1. 顺序存储结构
	用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系（一般只用于完全二叉树，以避免对存储空间的浪费）；![[e4043b723701a2d0b984e6f5184ace6a.jpg]]
 2. 二叉链表
	二叉树的每个结点最多有两个Child，所以设计有一个数据域和两个指针域的链表![[76c735a8966c0353c0d9b4c0d0aa2282.jpg]]

## 遍历二叉树
 traversing binary tree -- 指从根结点出发，按照某种次序访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次
 1. 前序遍历
	若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树![[4553fd4ab9cc9ec2254ce7812f101a9d.jpg]]
 2. 中序遍历
	若树为空，则空操作返回，否则从根结点开始（不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树![[c4f564da4323ac1466c47b82bed9cbc7.jpg]]
 3. 后序遍历
	若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点![[9d71cb0d577e35d0e014cd382d8c6628.jpg]]
 4. 层序遍历
	若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问![[d98520b0c40b3cb2ad3304e1a3724115.jpg]]
 5. 推导遍历结果
	- 已知***前序***遍历序列和***中序***遍历序列，可以确定一棵二叉树；
	- 已知***后序***遍历序列和***中序***遍历序列，可以确定一棵二叉树；

## 建立二叉树
 将二叉树中的每个结点的空指针引出一个虚结点，其值为一特定值，如“#”![[1fd01420f73ddcd7e44d8b3899bf8d4b.jpg]]

## 线索二叉树
 - 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）
 - 将二叉树以某种次序遍历使其变为线索二叉树的过程（将所有空指针域中的rchild改为指向当前结点的后继结点，将所有空指针域中的lchild改为指向当前结点的前驱结点）称作是线索化。
 ![[0f96e7acbcb5972f223d117a8eea7cdc.jpg]]
 - ltag为0时指向该结点的左child，为1时指向该结点的前驱；
 - rtag为0时指向该结点的右child，为1时指向该结点的后继；
![[bed97ce9b865fd63ed5fa3f0f2f64dfc.jpg]]
*线索化的过程就是在遍历的过程中修改空指针的过程*
```

```
如果需经常遍历或查找结点时需要某种遍历序列中的前驱和后继 ^|^

## 树、森林、二叉树的转换

## [[哈夫曼树]]