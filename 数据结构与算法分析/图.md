**图**（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成的通常表示为G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合

## 各种图的定义

**无向边**：若顶点 Vi 到 Vj 之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（ $V_i$ , $V_j$ ）来表示；
如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图**；

**有向边**：若从顶点 $V_i$ 到 $V_j$ 的边有方向，则称这条边为有向边，也称为弧（Arc），用有序偶对 < $V_i$ , $V_j$  > 来表示，$V_i$ 称为弧尾（Tail），$V_j$ 称为弧头·（Head）；
如果图中任意两个顶点之间的边都是有向边，则称该图为**有向图**；

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为**简单图**；

在无向图中，如果任意两个顶点之间都存在边，则称该图为**无向完全图**；-- 含有 n 个顶点的无向完全图有 $\frac {n \times {(n-1)}} {2}$条边
在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为**有向完全图**；-- 含有 n 个顶点的有向完全图有 $n \times {(n-1)}$ 条边

有很少条边或弧的图称为稀疏图，反之称为稠密图。（相对而言）

无向图顶点的边数叫作**度**，有向图顶点分为**入度**和**出度**。

与图的边或弧相关的树叫作**权**（Weight），这种带权的图通常称为**网**（Network）
假设有两个图G=（V,{E}）和G’=（V‘,{E‘}），如果V’包含于V且E‘包含于E，则称G'为G的**子图**（Subgraph）

路径的**长度**是路径上的边或弧的数目。

第一个顶点和最后一个顶点相同的路径称为**回路**或**环**（Cycle）。序列中顶点不重复出现的路径称为**简单路径**。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为**简单回路**或**简单环**。

若任意两顶点都是连通的，则图就是**连通图**，有向则称**强连通图**。
图中有子图，若子图极大连通则就是**连通分量**，有向的则称**强连通分量**。

无向图中连通且n个顶点n-1条边叫作**生成树**。有向图中一顶点入度为0其余顶点入度为1的叫作**有向树**。
一个有向图由若干棵优先树构成**生成森林**。
![[8ab69a2d1d0af74bfbe7157a6647b7f6.jpg]]

## 图的存储结构
 - **邻接矩阵**
	Adjacency Matrix存储方式是用两个数组来表示图。一个一维数组存储图中的顶点信息，一个二维数组（邻接数组）存储图中的边或弧的信息。（无向图的边数组是一个对称矩阵）
		设图G是网图，有n个顶点，则邻接矩阵是一个 $n \times n$ 的方阵，定义为：
	$$
	\text{arc}[i][j] = 
	\begin{cases} 
	W_{ij}, & \text{若 } (v_i, v_j) \in E \text{ 或 } \langle v_i, v_j \rangle \in E \\ 
	0, & \text{若 } i = j \\ 
	\infty, & \text{其他}
	\end{cases}
	$$
		$W_ij$ 表示 $(v_i, v_j)$ 或 $\langle v_i, v_j \rangle$ 上的权值，$\infty$ 表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值来代表不存在
 - **邻接表**
	 Adjacency List存储方法是用数组与链表相结合来表示。
	 1. 图中顶点用一个一维数组存储（也可用单链表），对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
	 2. 图中每个顶点 $v_i$  的所有邻接点构成一个线性表，由于邻接点的个数不定，故用单链表存储，无向图称为顶点 $v_i$ 的边表，有向图则称为顶点 $v_i$ 作为弧尾的出边表（容易得到每个顶点的出度）。
		 ![[2c3d2dbfdacdb598a3f0949b66dc7e92.jpg]]
		 建立一个有向图的逆邻接表，即对每个顶点 $v_i$ 都建立一个链接为 $v_i$ 为弧头的表（容易算出某个顶点的入度是多少，并进一步判断两顶点是否存在弧）![[09dcc76897fab99134c55f5c5c1eccf7.jpg]]
		 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息![[3423f5db26b3b6ef274e740029bfae4e.jpg]]
 - **十字链表**（对于有向图邻接表的优化）
	 Orthogonal List把邻接表与逆邻接表结合起来。
	 定义顶点表结点结构为 data  firstin  firstout ；firstin表示入边表中第一个结点；firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。
	 定义边表结点结构为 tailvex  headvex  headlink  taillink；tailvex指弧起点在顶点表中的下标；headvex指弧终点在顶点表中的下标；headlink指入边表指针域，指向终点相同的下一条边；taillink指边表指针域，指向起点相同的下一条边；如果是网，再增加一个weight域来存储权值。
	 ![[83195ddf981d769d3cb1cb0ec6f0da14.jpg]]
 - **邻接多重表**（对于无向图邻接表的优化 -- 更关注边的操作）
	 定义边表的结点结构为 ivex  ilink  jvex  jlink；ivex和jvex是与某条边依附的两个顶点在顶点表中的下标；ilink指向依附顶点ivex的下一条边；jlink指向依附顶点jvex的下一条边![[9525edf751ff41f4d8b0a410ad689b96.jpg]]
 - **边集数组**
	由两个一维数组构成的。一个存储顶点的信息；另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。（适合对边依次处理而不适合对顶点相关的操作） -- 与[[Kruskal算法]]有关![[bdef512aaa9b1fff202c7aea0237f040.jpg]]

## 图的遍历
Traversing Graph 从图中某一顶点出发访遍图中其余顶点，且使每个顶点仅被访问一次
 - **深度优先遍历（搜索）**
   Depth First Search（DFS）
	 从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。 若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。（类似树的前序遍历）
	 %% ps：个人的理解是一条路走到黑，比如一条路上有很多个十字路口，先按照一个走法（for example路口都向右走）走不通就退回上一个十字路口再按这个走法走 
	 AI对此理解的改进：假设在迷宫中探索，规则如下：
	1. 每到一个岔路口，按固定规则（如“左手法则”）选择一条未走过的路；
	2. 边走边撒面包屑（标记已访问）；
	3. 如果走到死胡同或所有岔路都已标记，则原路返回到上一个岔路口（回溯）；
	4. 重复上述过程，直到找到出口或遍历完整张地图。%%
- **广度优先遍历（搜索）**
	Breadth First Search（BFS）（类似树的层序遍历）
	%% ps：个人的理解是，从起点出发，将所有直接相邻的节点（第一层）依次访问完毕，再继续访问这些节点的下一层，依此类推，直到遍历完整个图。它更像是在多条道路的交叉点（十字路口）同时展开，每次探索所有同一层的交叉点，逐步深入。BFS 通常使用队列来保证节点按层次访问的顺序。%%
## 最小生成树
Minimum Cost Spanning Tree为构造连通网的最小代价生成树
	1. 有 `n` 个顶点时，MST 恰好有 `n-1` 条边。
    2. 在满足连通性的前提下，选的边权值之和最小。
 - **[[Prim算法]]** -- 从一个起点出发，不断扩展最短边（稠密图）
 - [[Kruskal算法]] -- 按照边的权值从小到大逐一选边（稀疏图）

## 最短路径
对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且称路径上的第一个顶点是源点，最后一个顶点是终点
 - [[Dijkstra算法]] -- 逐步扩展，依次找到源点到每个顶点的最短路径（贪心）
 - [[Floyd算法]] -- 逐步检查每个顶点作为“中间点”的情况，可求任意两点最短路径（动态规划）

## [[拓扑排序]]
拓扑排序是一种对**有向无环图 (DAG)** 进行的排序。它将图中的**顶点**排成一个线性序列，使得： **若存在一条从顶点 `u` 到顶点 `v` 的有向边 `(u → v)`，则在排序中 `u` 必须出现在 `v` 之前。**
## [[关键路径]]
**关键路径**是指在一个项目（或事件）中，**从起点到终点用时最长的一条路径**，它决定了该项目的**最短完成时间**。(ps：我的理解 - 假如要去一个地方，planA是地铁转公交用时一个半小时，planB是公交转公交用时两个小时，以防万一，需要预留的最短时间至少是两个小时，而planB就是关键路径)