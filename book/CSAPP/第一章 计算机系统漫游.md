**从某种意义上来说，本书的目的就是了解，当在系统中执行程序时，系统会发生什么，以及为什么会这样**

# 1.1 信息就是位 + 上下文
系统中所有的信息一包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

# 1.2 程序被其他程序翻译成不同的格式
程序的生命周期通常是从一个高级语言开始的，以便人能读懂。但是，为了能在系统上运行程序，需要机器能读懂，于是每条语句都必须被其他程序转化为一系列低级的**机器语言**指令。然后这些指令按照一种称为**可执行文件目标程序**的格式打包好，并以二进制磁盘文件的形式存放起来。目标程序也称为**可执行目标文件**。（就比如编译cpp文件会产生一个exe文件，运行是运行这个exe文件）
这个翻译过程可分为四个阶段完成，如图![[../../attachments/Pasted image 20250825161218.png]]执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。
 - 预处理阶段。根据以字符#开头的命令，修改原始的C程序。比如 `hello.c` 中第1行 `#include<stdio.h>` 命令告诉预处理器读取系统头文件 `stdio.h`的内容，并把它直接插入程序文本中。结果就得到了另一个C程序。
 - 编译阶段。将上一个阶段的文本文件翻译成汇编语言程序的文本文件，每一条语句都以一种文本格式描述一条低级机器语言指令。
 - 汇编阶段。将上一阶段的文本文件翻译成机器语言指令，并把这些指令打包成一种叫做**可重定位目标程序**的格式，并将结果保存在目标文件中（该文件是个二进制文件）
 - 链接阶段。链接其他需要使用的单独的预编译好了的目标文件，从而得到可执行文件，可以被加载到内存中，由系统执行。

# 1.3 了解编译系统如何工作是大有益处的
益处：优化程序性能；理解链接时出现的错误；避免安全漏洞

# 1.4 处理器读并解释储存在内存中的指令
在 Unix 系统上运行可执行文件，是通过 Shell 来运行。（[[../../Shell/The Shell|The Shell]]）

## 1.4.1 系统的硬件组成
![[../../attachments/Pasted image 20250825163037.png]]
### 1. 总线
Bus -- 携带信息字节并负责在各个部件间传递
### 2. I/O 设备
是系统与外部世界的联系通道。每个 I/O 设备都通过一个控制器与适配器与 I/O 总线相连。控制器与适配器的区别主要在于它们的封装方式：控制器是 I/O 设备本身或者系统的主板上的芯片组，而适配器则是一块插在主板插槽上的卡
### 3. 主存
是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的
### 4. 处理器
中央处理单元(CPU)，简称处理器，是解释（或执行）存储在主存中指令的引擎。
处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器(PC)。
在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。
处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC ，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。
