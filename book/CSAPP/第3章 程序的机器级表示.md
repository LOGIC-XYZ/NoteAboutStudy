在本章中，将详细学习一种特别的汇编语言，了解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同于手工编写汇编代码。必须了解典型的编译器在将 C 程序结构变换成机器代码时所做的转换。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解。这是一种 **逆向工程(reverse engineering)** -- 通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且可以做试验，让编译器产生许多不同程序的代码。

---
# 3.1 历史观念
Intel 处理器系列俗称 x86 ，经历了一个长期的、不断进化的发展过程。开始时，它是第一代单芯片、16 位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。
并且每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理器上运行。

# 3.2 程序编码
假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们用 Unix命令行编译这些代码：  `linux>gcc -Og -o p p1.c p2.c` 
命令 gcc 指的就是 GCC C 编译器。因为这是 Linux 上默认的编译器，也可以简单地用 cc 来启动它。编译选项 -Og 是告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此会使用 -Og 优化作为学习工具，然后当增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项 -O1 或 -O2 指定）被认为是较好的选择。
编译的过程可参考 [[第1章 计算机系统漫游]] 2.1 节。

---
## 3.2.1 机器级代码
正如在 1.9.3 节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。
- 第一种是由 **指令集体系结构或指令集架构(Instruction Set Architecture, ISA)** 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86-64，将程序的行为描述成好像每条指令都是按顺序执行的。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。
- 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。==汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。==

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：
- 程序计数器（通常称为 “PC”，在 x86-64 中用 `%rip`表示）给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc 库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如，x86-64 的虚拟地址是由 64 位的字来表示的。在目前的实现中，这些地址的高 16 位必须设置为 0，所以一个地址实际上能够指定的是 $2^{48}$ 或 $64TB$ 范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

一条机器指令只执行一个非常基本的操作。

> [!tip]
> 本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结构。而读者需要将这些技术应用到个人的特定的编译器产生的代码格式上（不同的机器可能产生不同的代码）。

## 3.2.2 代码示例
假设写了一个 C 语言代码文件 mstore.c 包含如下的函数定义：
```c
long mult2(long,long);
void multstore(long x,long y,long *dest){
	long t mult2(x,y);
	*dest =t;
}
```

在命令行上使用 ”-S“ 选项，就能看到 C 语言编译器产生的汇编代码 `mstore.s`，这会使 GCC 运行编译器并产生一个汇编文件，但是不做其他进一步的工作。（通常情况下，还会继续调用汇编器产生目标文件代码）
`linux> gcc -Og -S mstore.c`

汇编代码文件包含各种声明，包括以下几行，代码中每个缩进去的行都对应于一条机器指令：
```
mulstore
  pushq    %rbx
  movq     %rdx,%rbx
  call     mult2
  movq     %rax,(%rbx)
  popq     %rbx
  ret
```


在命令行上使用 ”-c“ 选项，GCC 会编译并汇编该代码，并产生目标代码文件 `mstore.o`，是二进制格式的，所以机器执行的程序只是一个字节序列，它是对一系列指令的编码，而机器对产生这些指令的源代码几乎一无所知。


如果要查看机器代码文件的内容，有一类称为 **反汇编器（disassembler）** 的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux 系统中，带 ”-d“ 命令行标志的程序 OBJDUMP（表示“object dump”）可以充当这个角色：
`linux> objdump -d mstore.o`

结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：
在左边，按照前面给出的字节顺序排列的 14 个十六进制字节值，它们分成了若
干组，每组有 1～5 个字节。每组都是一条指令，右边是等价的汇编语言。
```
Disassemblyof function multstore in binary file mstore.o
1    0000000000000000<multstore>:
     Offset   Bytes                 Equivalent assembly language
2        0:   53                    push    %rbx
3        1:   48 89 d3              mov     %rdx,%rbx
4        4:   e8 00 00 00 00        callq   9 <multstore+0x9>
5        9:   48 89 03              mov     %rax,(%rbx)
6        c:   5b                    pop     %rbx
7        d:   c3                    retq
```

其中一些关于机器代码和它的反汇编表示的特性值得注意：
- x86-64 的指令长度从 1 ~ 15 个字节不等。==常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多==。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 `pushq %rbx` 是以字节值 53 开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的 'q'。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了 'q' 后缀，同样，省略这些后缀也没有问题。


生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。

假设在文件 main.c 中有下面这样的函数：
```
#include<stdio.h>
void multstore（long,long,long*);
int main(){
	long d;
	multstore（2,3，&d）;
	printf（"2 * 3 --> %ld\n"，d）;
	return 0;
}
longmult2（longa，longb）{
	long s = a * b;
return s;
}
```
然后 `linux> gcc -Og -o prog main.c mstore.c` 生成可执行文件 prog，此时，不仅包含了用来启动程序和终止程序的代码，以及用来与操作系统交互的代码。此时反汇编后的部分结果与 `mstore.c` 对比可以发现三个区别：
```
Disassemblyof function multstore in binary file prog
1    0000000000400540<multstore>:
2     400540:   53                    push    %rbx
3     400541:   48 89 d3              mov     %rdx,%rbx
4     400544:   e8 42 00 00 00        callq   40058b <mult2>
5     400549:   48 89 03              mov     %rax,(%rbx)
6     40054c:   5b                    pop     %rbx
7     40054d:   c3                    retq
8     40054e:   90                    nop
9     40054f:   90                    nop
```
- 左边列出的地址不同 -- 链接器将这段代码的地址移到了一段不同的地址范围中。
- 链接器填上了 callq 指令调用函数 mult2 需要使用的地址（反汇编代码第 4 行）。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。
- 多了两行代码（第 8 和 9 行）。这两条指令对程序没有影响，因为它们出现在返回指令后面（第 7 行）。插入这些指令是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能更好地放置下一个代码块。

## 3.2.3 关于格式的注解
GCC 产生的汇编代码对人类来说有点儿难读。一方面，它包含一些不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。

所有以 '.' 开头的行都是指导汇编器和链接器工作的伪指令。通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

为了更清楚地说明汇编代码，用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于示例，带解释的汇编代码如下：
![[../../attachments/Pasted image 20250902203445.png]]
通常只会给出与讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C 语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。

# 3.3 数据格式
由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 “字（word）” 表示 16 位数据类型。因此，称 32 位数为 “双字（doublewords）”，称 64 位数为 “四字（quadwords）”。
![[../../attachments/Pasted image 20250902203907.png]]

浮点数主要有两种形式：单精度（4 字节）值，对应于 C 语言数据类型 float；双精度（8 字节）值，对应于 C 语言数据类型 double。

==大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。==

> [!tip]
> 汇编代码也使用后缀 ’l‘ 来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

# 3.4 访问信息
一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的 **通用目的寄存器**。这些寄存器用来存储整数数据和指针。

图 3-2 显示了这 16 个寄存器。它们的名字都以 `%r` 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。
1. 最初的 8086 中有 8 个 16 位的寄存器，即图 3-2 中的 `%ax` 到 `%bp`。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。
2. 扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 `%eax` 到 `%ebp`。
3. 扩展到 x86-64 后，原来的 8 个寄存器扩展成 64 位，标号从 `%rax` 到 `%rbp`。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规则制定的：从 `%r8` 到 `%r15`。
![[../../attachments/Pasted image 20250902204734.png]]

如图 3-2 中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。

就像图 3-2 右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针 `%rsp`，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

---
## 3.4.1 操作系统指示符
大多数指令有一个或多个操作数（operand），指示出执行一个操作中==要使用的源数据值，以及放置结果的目的位置==。x86-64 支持多种操作数格式（参见图 3-3）。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。
- 第一种类型是 **立即数（immediate）** ，用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是 `$` 后面跟一个用标准 C 表示法表示的整数，比如， `$-577` 或 `$0x1F`。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种类型是 **寄存器（register）** ，它表示某个寄存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8 位、16 位、32 位或 6 4位。在图 3-3 中，用符号 $r_a$ 来表示任意寄存器a，用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看成一个数组 R，用寄存器标识符作为索引。
- 第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，用符号 $M_b[Addr]$ 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，通常省去下标 b。

如图 3-3 所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法 $Imm(r_b,r_i,s)$ 表示的是最常用的形式。
由四个组成部分：一个立即数偏移 $Imm$，一个基址寄存器 $r_b$，一个变址寄存器 $r_i$ 和一个比例因子 $s$，这里 s 必须是 1、2、4 或者 8。基址和变址寄存器都必须是 64 位寄存器。
**有效地址被计算为 $Imm+R[r_b]+R[r_i]·s$。**
引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。
![[../../attachments/Pasted image 20250902210022.png]]

##  3.4.2 数据传送指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

有多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在该讲述中，把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只是操作数大小不同。

MOV 类 -- 最简单形式的数据传送指令，这些指令把数据从源位置复制到目的位置，不做任何变化。该类由四条指令组成：movb、movw、movl 和 movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、 2、4 和 8 字节。
![[../../attachments/Pasted image 20250902210526.png]]

源操作数指定的值是一个立即数，存储在寄存器中或者内存中。
目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。
x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置，因此，将一个值从一个内存位置复制到另一个内存位置需要两条指令 -- 第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。（以寄存器为中转站）

参考图 3-2，这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（'b'，'w'，'l' 或 'g'）指定的大小匹配。

大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 movl 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0。造成这个例外的原因是 x86-64 采用的惯例，即==任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0== 。

下面的 MOV 指令示例给出了源和目的类型的五种可能的组合。记住，第一个是源操作数，第二个是目的操作数：
![[../../attachments/Pasted image 20250902215128.png]]

图 3-4 中记录的最后一条指令是处理 64 位立即数数据的。常规的 movq 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置。movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。

图 3-5 和图 3-6 记录的是两类数据移动指令，==在将较小的源值复制到较大的目的时使用==。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。 **MOVZ 类中的指令把目的中剩余的字节填充为 0**，而 **MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制**。每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只考虑目的大于源的情况。
![[../../attachments/Pasted image 20250902215528.png]]
![[../../attachments/Pasted image 20250902215555.png]]

图 3-5 中并没有一条明确的指令把 4 字节源值零扩展到 8 字节目的。这样的指令逻辑上应该被命名为 movzlq，但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 movl 指令来实现。这一技术利用的属性是，生成 4 字节值并以寄存器作为目的的指令会把高 4 字节置为 0。对于 64 位的目标，所有三种源类型都有对应的符号扩展传送，而只有两种较小的源类型有零扩展传送。

图 3-6 还给出 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 作为源，%rax 作为符号扩展结果的目的。它的效果与指令 movslq %eax,%rax 完全一致，不过编码更紧凑。

## 3.4.3 数据传送示例
作为一个使用数据传送指令的代码示例，考虑图 3-7 中所示的数据交换函数，既有 C 代码，也有 GCC 产生的汇编代码。
![[../../attachments/Pasted image 20250902220532.png]]

函数通过把值存储在寄存器 %rax 或该寄存器的某个低位部分中返回。

1. 当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器 %rdi 和 %rsi 中。
2. 然后，指令 2 从内存中读出 x，把它存放到寄存器 %rax 中，直接实现了 C 程序中的操作 `x=*xp`。
3. 稍后，用寄存器名 %rax 从这个函数返回一个值，因而返回值就是 x。指令 3 将 y 写入到寄存器 %rdi 中的 xp 指向的内存位置，直接实现了操作`*xp=y`。

> [!important]
> - C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
> - 像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

## 3.4.4 压入和弹出栈数据
最后两个数据传送操作可以将数据压人程序栈中，以及从程序栈中弹出数据。

如图 3-9 所示，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，栈是倒过来画的，栈 “顶” 在图的底部。）栈指针 %rsp 保存着栈顶元素的地址。

pushq 指令的功能是把数据压入到栈上，而 popq 指令是弹出数据。这些指令都只有一个操作数 -- 压入的数据源和弹出的数据目的。

而将一个四字值压入栈中，首先要将栈指针减 8，然后将值写到新的栈顶地址。弹出一个四字的操作需要从栈顶位置读出数据，然后将栈指针加 8。但是无论如何，%rsp 指向的位置总是栈顶。
![[../../attachments/Pasted image 20250902223544.png]]

# 3.5 算术和逻辑操作
图 3-10 列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 leaq 没有其他大小的变种）。这些操作被分为四组：加载有效地址操作和移位。二元操作有两个操作数，而一元操作有一个操作数。
![[../../attachments/Pasted image 20250902224324.png]]

---
## 3.5.1 加载有效地址
**加载有效地址(load effective address)** 指令 `leaq` 实际上是 `movq` 指令的变形。但是它并没有引入内存。两者的区别在于，`leaq` 的寄存器存的是计算出来的地址，`movq` 的寄存器存的是计算出来的地址的数据。

## 3.5.2 一元和二元操作
图 3-10 第二组中的操作是一元操作，只有一个操作数，既是源又是目的（既是输入也是输出）。这个操作数可以是一个寄存器，也可以是一个内存位置。

图 3-10 第三组是二元操作，其中，第一个操作数是源，第二个操作数既是源又是目的。这种差异导致，第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置，不能是立即数。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存（CPU 无法同时从两个内存操作数里 读/写）。

## 3.5.3 移位操作
图 3-10 最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 `&cl` 中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。)

原则上来说，1 个字节的移位量使得移位量的编码范围可以达到 $2^8-1=255$。x86-64 中，移位操作对 w 位长的数据值进行操作，移位量是由 `&cl` 寄存器的低 m 位决定的，这里 $2^m=w$。高位会被忽略。

左移指令有两个名字：SAL 和 SHL。两者的效果是一样的，都是将右边填上 0。

右移指令不同，SAR 执行算术移位（填上符号位），而 SHR 执行逻辑移位（填上 0 )。

移位操作的目的操作数可以是一个寄存器或是一个内存位置。

## 3.5.4 讨论
图 3-10 所示的大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。

# 3.6 控制
截至目前，只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。但是还有一些判断语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

与数据相关的控制流是实现有条件行为的更一般和更常见的方法，用 `jump` 指令可以改变一组机器代码指令的执行顺序，`jump` 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。

---
## 3.6.1 条件码
除了整数寄存器，CPU 还维护着一组单个位的 **条件码(condition code)** 寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。

最常用的条件码有： 
- CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 
- ZF:零标志。最近的操作得出的结果为 0。 
- SF:符号标志。最近的操作得到的结果为负数。 
- OF:溢出标志。最近的操作导致一个补码溢出 -- 正溢出或负溢出。

`leaq` 指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，图 3-10 中列出的所有指令都会设置条件码。

除了图 3-10 中的指令会设置条件码，还有两类指令（有 8、16、32 和 64 位形式)，它们只设置条件码而不改变任何其他寄存器；

如图 3-13 所示。==CMP 指令根据两个操作数之差来设置条件码==。除了只设置条件码而不更新目的寄存器的值之外，CMP 指令与 SUB 指令的行为是一样的。在ATT格式中，操作数顺序是 **源，目标**（和 Intel 格式相反）。如果两个操作数相等，这些指令会将零标志从（ZF）设置为 1，而其他的标志可以用来确定两个操作数之间的大小关系（通过组合）。

TEST 指令的行为与 AND 指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型用途：测试某个位是否为 1（比如检查符号位、掩码位）。

![[../../attachments/Pasted image 20250906213800.png]]

## 3.6.2 访问条件码
条件码通常不会直接读取，常用的使用方法有三种：
1. 可以根据条件码的某种组合，将一个字节设置为 0 或者 1。
2. 可以条件跳转到程序的某个其他的部分。
3. 可以有条件地传送数据。

本节主要讲述第一种情况，另两种在后续几节。

对于第一种情况，图 3-14 中描述的指令根据条件码的某种组合，将一个字节设置为 0 或者 1。将这一整类指令称为 SET 指令；它们之间的区别就在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小。

一条 SET 指令的目的操作数是低位单字节寄存器元素（图 3-2 ）之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1。为了得到一个 32 位或 64 位结果，必须对高位清零（SET 指令只写 8 位）。
![[../../attachments/Pasted image 20250906215132.png]]

某些底层的机器指令可能有多个名字，称之为 “同义名(synonym)”。比如说，  `setg` (表示 “设置大于”)和 `setnle` (表示 “设置不小于等于”)指的就是同一条机器指令。编译器和反汇编器会随意决定使用哪个名字。


虽然所有的算术和逻辑操作都会设置条件码，但是各个 SET 命令的描述都适用的情况是：执行比较指令，根据计算 t=a-b 设置条件码。更具体地说，假设 $a$、$b$ 和 $t$ 分别是变量 a、b 和 t 的补码形式表示的整数，因此 $t=a-_{w}^tb$，这里 $w$ 取决于 $a$ 和 $b$ 的大小。
1. 以 `sete` 为例（等于比较）
	- `sete` = **set when equal**
	- 原理：当 a = b 时，t = a - b = 0 → `ZF=1`。
2. 以 `setl` 为例（小于，有符号比较）
	- `setl` = **set when less**
	- 目标：判断 **a < b**。
	- 情况分两类：
	    **(1) 没有溢出 (OF=0)**
	    - 如果 `t = a - b < 0` → `SF=1` → a < b
	    - 如果 `t >= 0` → `SF=0` → a >= b
	    **(2) 发生溢出 (OF=1)**
	    - 当补码溢出时，SF 的值会“翻转”。
	    - 例如：
	        - 如果 t 本应为负（a < b），但算出来是正数 → SF=0, OF=1    
	        - 如果 t 本应为正（a > b），但算出来是负数 → SF=1, OF=1
	    - 结论：判断 a < b 的逻辑是 SF ^ OF
3. 其他有符号比较
	- `setle` (≤)：(SF ^ OF) ∨ ZF
	- `setg` (> )：¬(SF ^ OF) ∧ ¬ZF
	- `setge` (≥)：¬(SF ^ OF)
4. 无符号比较
    - 对于无符号数，比较结果靠 **CF（进位/借位标志）**：
        - 如果 `a < b`，做 `a - b` 时会产生借位 → CF=1
        - 如果 `a >= b`，则 CF=0
    - 结合 ZF，还能写出：
        - `setb` (<)：CF=1
        - `setbe` (≤)：CF=1 ∨ ZF=1
        - `seta` (> )：CF=0 ∧ ZF=0
        - `setae` (≥)：CF=0

---
注意到机器代码如何区分有符号和无符号值是很重要的。同 C 语言不同，机器代码不会将每个程序值都和一个数据类型联系起来。相反，大多数情况下，机器代码对于有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况需要用不同的指令来处理有符号和无符号操作。

## 3.6.3 跳转指令
**跳转（jump）** 指令会导致执行切换到程序中一个全新的位置，让下一条执行的指令从新位置取。在汇编代码中，这些跳转的目的地通常用一个 **标号（label）** 指明。

图 3-15 列举了不同的跳转指令。`jmp` 指令是无条件跳转。它可以是直接跳转，即**跳转目标是作为指令的一部分编码**的；也可以是间接跳转，即**跳转目标是从寄存器或内存位置中读出**的。汇编语言中，直接跳转是给出一个标号作为跳转目标的。
![[../../attachments/Pasted image 20250906224349.png]]

表中所示的其他跳转指令都是有条件的 -- 它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与 SET 指令的名字和设置条件是相匹配的（参见图 3-14）。同 SET 指令一样，一些底层的机器指令有多个名字。条件跳转只能是直接跳转。

## 3.6.4 跳转指令的编码
虽然不关心机器代码格式的细节，但是理解跳转指令的目标如何编码，对研究链接非常重要。同时，也能帮助理解反汇编器的输出。

在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。

跳转指令有几种不同的编码，但是最常用都是 **PC相对的(PC-relative)** 。也就是，它们会==将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码==。这些地址偏移量可以编码为 1、2 或 4 个字节。

第二种编码方法是给出 “绝对” 地址，==用 4 个字节直接指定目标==。汇编器和链接器会选择适当的跳转目的编码。

当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这种惯例可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。

## 3.6.5 用条件控制来实现条件分支
将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。（另一种方式在3.6.6节中会看到，有些条件可以用数据的条件转移实现，而不是用控制的条件转移来实现。)

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。

汇编代码的实现中，通过比较操作数，设置条件码，从而跳转到某一行。

## 3.6.6 用条件传送来实现条件分支
3.6.5 的这种机制简单而通用，但是在现代处理器上，它可能会非常低效。

一种替代的策略是使用 数据 的条件转移。**这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个**。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。如下将介绍这一策略，以及它在 x86-64 上的实现。

为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码性能要好，必须了解一些关于现代处理器如何运行的知识。正如将在第 4 章和第 5 章中看到的，处理器通过使用 **流水线(pipelining)** 来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器)。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。

处理器采用精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到 90% 以上的成功率)，指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。这样一个错误预测会导致很严重的惩罚，浪费大约 15~30 个时钟周期，导致程序性能严重下降。

无论测试的数据是什么，编译出来使用条件传送的代码所需的时间都是约 8 个时钟周期。控制流不依赖于数据，这使得处理器更容易保持流水线是满的。


图 3-18 列举了 x86-64 上一些可用的条件传送指令。每条指令都有两个操作数：源寄存器或者内存地址 S，和目的寄存器 R。与不同的 SET( 3.6.2 节)和跳转指令( 3.6.3 节)一样，这些指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

源和目的的值可以是 16 位、32 位或 64 位长。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中（例如 movw 和 movl)，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。
![[../../attachments/Pasted image 20250907163629.png]]

同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。

但是两个分支的计算必须都做一遍，即使最后只用其中一个结果。所以如果分支计算代价很高（比如函数调用、复杂运算），那条件传送反而会更慢。

### 条件控制与条件跳转的区别
前者控制流跳转依赖预测，后者数据流选择依赖计算 -- 前者是先预测，走不通再换，后者是算出来直接选择。

## 3.6.7 循环
C 语言提供了多种循环结构，即 `do-while`、`while` 和 `for`。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。GCC 和其他汇编器产生的循环代码主要基于两种基本的循环模式。

### 1. `do-while`循环
`do-while` 语句的通用形式如下： 
```
do 
	body-statement 
	while (test-expr);
```
这个循环的效果就是重复执行 `body-statement`，对 `test-expr` 求值，如果求值的结果为非零，就继续循环。`body-statement` 至少会执行一次。

这种通用形式可以被翻译成如下所示的条件和 goto 语句：
```
loop:
	body-statement
	t = test-expr;
	if(t)
		goto loop;
```
每次循环，程序会执行循环体里的语句，然后执行测试表达式。如果测试为真，就回去再执行一次循环。

### 2. `while`循环
`while` 语句的通用形式如下：
```
while(test-expr)
	body-statement
```
与 `do-while` 的不同之处在于，在第一次执行 `body-statement` 之前，它会对 `test-expr` 求值，循环有可能就中止了。

有很多种方法将 `while` 循环翻译成机器代码，GCC 在代码生成中使用其中的两种方法。这两种方法使用同样的循环结构，与 `do-while` 一样，不过它们实现初始测试的方法不同。

第一种翻译方法，称之为跳转到中间( jump to middle )，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。可以用以下模板来表达这种方法，这个模板把通用的 `while` 循环格式翻译到 `goto` 代码：
```
	goto test; 
loop: 
	body-statement 
test: 
	t = test-expr; 
if (t) 
	goto loop;
```

第二种翻译方法，称之为 `guarded-do`，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 `do-while` 循环。当使用较高优化等级编译时，例如使用命令行选项 `-o1`，GCC 会采用这种策略。可以用如下模板来表达这种方法，把通用的 `while` 循环格式翻译成 `do-while` 循环：
```
t = test-expr;
if (!t)
	goto done;
do
	body-statement
	while (test-expr);
done:
```
相应地，还可以把它翻译成 `goto` 代码如下：
```
t = test-expr;
if (!t)
	goto done;
loop:
	body-statement
	t = test-expr;
	if (t)
		goto loop;
done:
```
利用这种实现策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。

### 3. `for`循环
`for`循环的通用形式如下：
```
for(init-expr; test-expr; update-expr)
	body-statement
```
C 语言标准说明，这样一个循环的行为与下面这段使用 `while` 循环的代码的行为一样：
```
init-expr;
while (test-expr){
	body-statement
	update-expr;
}
```
程序首先对初始表达式 `init-expr` 求值，然后进入循环；在循环中它先对测试条件 `test-expr` 求值，如果测试结果为 “假” 就会退出，否则执行循环体 `body-statement;` 最后对更新表达式 `update-expr` 求值。

GCC 为 `for` 循环产生的代码是 `while` 循环的两种翻译之一，这取决于优化的等级。

跳转到中间策略会得到如下 `goto` 代码：
```
	init-expr;
	goto test;
1oop:
	body-statement
	update-expr;
test:
	t = test-expr;
if (t)
	goto loop;
```
`guarded-do` 策略得到：
```
init-expr;
	t = test-expri
	if (!t)
		goto done;
loop:
	body-statement
	update-expr;
	t = test-expri
	if (t)
		goto loop;
done:
```

## 3.6.8 `switch` 语句
`switch` (开关)语句可以根据一个整数索引值进行多重分支( multiway branching )。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C 代码的可读性，而且通过使用 **跳转表(jump table)** 这种数据结构使得实现更加高效。

跳转表是一个数组，表项 `i` 是一个代码段的地址，这个代码段实现当开关索引值等于 `i` 时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。

和使用一组很长的 `if-else` 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

# 3.7 过程
过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数(function)、方法(method)、子例程(subroutine))、处理函数(handler)等等，但是它们有一些共有的特性。

要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程  P 调用过程 Q，Q 执行后返回到 P。这些动作包括下面一个或多个机制：
- 传递控制。在进人过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
- 传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
- 分配和释放内存。在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

---
## 3.7.1 运行时栈
C 语言过程调用机制的一个关键特性（大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则。

在过程 P 调用过程 Q 的例子中，当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。

当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。

当 Q 返回时，任何它所分配的局部存储空间都可以被释放。因此，**程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。**

当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的 **栈帧(stack fram)**。
![[../../attachments/Pasted image 20250907174752.png]]
图 3-25 给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。把这个返回地址当做 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。

大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧，这个问题会在 3.10.5 节中讨论。通过寄存器，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。

为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分。例如，许多过程有 6 个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，图 3-25 中画出的某些栈帧部分可以省略。

实际上，许多函数甚至根本不需要栈帧。**当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理**。例如，到目前为止审视过的所有函数都不需要栈帧。

## 3.7.2 转移控制
将控制从函数 P 转移到函数 Q 只需要把程序计数器(PC)设置为 Q 的代码的起始位置。不过，当稍后从 Q 返回的时候，处理器必须记录好它需要继续 P 的执行的代码位置。

在 x86-64 机器中，这个信息是用指令 `call Q` 调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 `call` 指令后面的那条指令的地址。对应的指令 `ret` 会从栈中弹出地址 A，并把 PC 设置为 A。
![[../../attachments/Pasted image 20250907180400.png]]

`call` 指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是 * 后面跟一个操作数指示符。

`call` 指令将控制转移到一个函数的起始，`ret` 指令返回到这次调用后面的那条指令。

这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点。C 语言（以及大多数程序语言）标准的调用/返回机制刚好与栈提供的后进先出的内存管理方法吻合。

## 3.7.3 数据传送
当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64 中，大部分过程间的数据传送是通过寄存器实现的。

当过程 P 调用过程 Q 时，P 的代码必须首先把参数复制到适当的寄存器中。类似地，当 Q 返回到 P 时，P 的代码可以访问寄存器 `%rax` 中的返回值。

x86-64 中，可以通过寄存器最多传递 6 个整型（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如图 3-28 所示。会根据参数在参数列表中的顺序为它们分配寄存器。可以通过 64 位寄存器适当的部分访问小于 64 位的参数。
![[../../attachments/Pasted image 20250907181317.png]]

如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。

假设过程 P调用过程 Q，有 n 个整型参数，且 n>6。那么 P 的代码分配的栈帧必须要能容纳 7 到 n 号参数的存储空间，如图 3-25 所示。要把参数 1~6 复制到对应的寄存器，把参数 7~n 放到栈上，而参数 7 位于栈顶。通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。参数到位以后，程序就可以执行 `call` 指令将控制转移到过程 Q 了。过程 Q 可以通过寄存器访问参数，有必要的话也可以通过栈访问。

相应地，如果 Q 也调用了某个有超过 6 个参数的函数，它也需要在自己的栈帧中为超出 6 个部分的参数分配空间，如图 3-25 中标号为 “参数构造区” 的区域所示。

## 3.7.4 栈上的局部存储
有些时候，局部数据必须存放在内存中，常见的包括以下情况：
- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用地址运算符 ‘&’，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标
号为 “局部变量”，如图 3-25 所示。

局部变量会分配在栈帧中，用 **偏移量** 相对于栈指针 `%rsp` 来访问，而栈帧由函数调用时分配。

## 3.7.5 寄存器中的局部存储空间
寄存器组是唯一被所有过程共享的资源。

虽然在给定时刻只有一个过程是活动的，但是必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

根据惯例，寄存器 `%rbx`、`%rbp` 和 `%r12~%r15` 被划分为被调用者保存寄存器。当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为 “保存的寄存器” 的一部分，如图 3-25 中所示。
有了这条惯例，P 的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他的寄存器，除了栈指针 `%rsp`，都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解 “调用者保存” 这个名字：过程 P 在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P(调用者)的责任。

## 3.7.6 递归过程
前面所描述的寄存器和栈的惯例使得 x86-64 过程能够递归地调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，**每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值)存储空间**。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用 - 返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程 P 调用 Q，Q 再调用 P)。

# 3.8 数组分配和访问
C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成**地址计算**。

优化编译器非常善于简化数组索引所使用的地址计算。但是这也使得 C 代码和它到机器代码的翻译之间的对应关系有些复杂。

---
## 3.8.1 基本原则
对于数据类型 T 和整型常数 N，声明如下：
`T A[N];`

起始位置表示为 $x_A$。这个声明有两个效果。
- 首先，它在内存中分配一个 $L·N$ 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）。
- 其次，它引入了标识符 A，可以用 A 来作为指向数组开头的指针，这个指针的值就是 $x_A$。
可以用 $0$～$N-1$ 的整数索引来访问该数组元素。数组元素 i 会被存放在地址为 $x_A+L·i$ 的地方。

x86-64 的内存引用指令可以用来简化数组访问。

因为 x86-64 的内存引用指令的一般形式是 `Imm(%Base, %Index, Scale)`，也就是常量偏移量 + 基址寄存器（类比数组的起始位置） + 索引寄存器（**索引**） * 放大因子（**字节大小**），刚好覆盖了 $x_A+L·i$ 的计算。

## 3.8.2 指针运算
C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。

如果 p 是一个指向类型为 T 的数据的指针，p 的值为 $x_p$，那么表达式 $p+i$ 的值为 $x_p+L·i$，这里 L 是数据类型 T 的大小。


单操作数操作符 `&` 和 `*` 可以产生指针和间接引用指针。

1. 对于一个表示某个对象的表达式 `Expr`，`&Expr` 是给出该对象地址的一个指针。
2. 对于一个表示地址的表达式 `AExpr`，`*AExpr` 给出该地址处的值。
3. 因此，表达式 `Expr` 与 `* &Expr` 是等价的。可以对数组和指针应用数组下标操作。

数组引用 `A[i]` 等同于表达式 `*（A+i）`。它计算第 i 个数组元素的地址，然后访问这个内存位置。

## 3.8.3 嵌套的数组
当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。

数组元素在内存中按照 “行优先” 的顺序排列。

要访问多维数组的元素，编译器会以数组起始为基地址，（可能需要经过伸缩的）偏移量为索引，产生计算期望的元素的偏移量，然后使用某种 MOV 指令。

通常来说，对于一个声明如下的数组：
`T D[R][C];`
它的数组元素 `D[i][j]` 的内存地址为 `&`$D[i][j]=x_D+L(C·i+j)$。L 是数据类型 T 以字节为单位的大小。

## 3.8.4 定长数组
当数组长度在编译期已知时：
**数组基址 = 栈帧中的某个固定偏移量**
- 如果数组是局部变量，编译器会在函数栈帧里给它分配一段连续空间。
- 因为数组长度 $N$ 已知，所以它的内存布局是固定的。

## 3.8.5 变长数组
ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。
在变长数组的 C 版本中，可以将一个数组声明如下： 
`int A[exprl][expr2]`
它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 `expr1` 和 `expr2` 求值来确定数组的维度。

引用变长数组需要对定长数组做一点儿概括。动态的版本必须用乘法指令对 i 伸缩 n 倍，而不能用一系列的移位和加法。在一些处理器中，乘法会招致严重的性能处罚，但是在这种情况中无可避免。

在一个循环中引用变长数组以利用访问模式的规律性来优化索引的计算。

可以看到，如果允许使用优化，GCC 能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式 `&`$D[i][j]=x_D+L(C·i+j)$ 导致的乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能提高程序的性能（用地址累加替代重复乘法），并且差不多，前者直接用累加，后者会把 `i*m` 的乘法外提，然后在循环中累加地址。

# 3.9 异质的数据结构
C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：**结构（structure）**，用关键字 `struct` 来声明，将多个对象集合到一个单位中；**联合（union）**，用关键字 `union` 来声明，允许用几种不同的类型来引用一个对象。

---
## 3.9.1 结构
C 语言的 `struct` 声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。

类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而**指向结构的指针就是结构第一个字节的地址**。编译器维护关于每个结构类型的信息，指示每个字段（field）的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

每个字段都有独立的存储空间，结构体的大小是各字段大小之和

结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

## 3.9.2 联合
联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

所有字段**共享同一块存储空间**，大小是**最大字段的大小**。

在一些下上文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了 C 语言类型系统提供的安全措施。一种应用情况是，当事先知道**对一个数据结构中的两个不同字段的使用是互斥的**，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量，节省空间。

联合可以用来访问不同数据类型的位模式。-- 能把同一段内存用不同的类型去读取，并不改变数据的二进制。

## 3.9.3 数据对齐
许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是 2、4 或 8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。

无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。这条原则会得到如下的对齐：
![[../../attachments/Pasted image 20250910213548.png]]
确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。而==编译器在汇编代码中放入命令，指明全局数据所需的对齐。==

---
对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。

编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求。

# 3.10 在机器级程序中将控制与数据结合起来
到目前为止，已经分别讨论机器级代码如何实现程序的控制部分和如何实现不同的数据结构。在本节中，将会看到数据和控制如何交互。

---
## 3.10.1 理解指针
指针是 C 语言的一个核心特色。它们以一种统一方式，对不同数据结构中的元素产生引用。但同时，对初学者来说，困惑颇多。在此，重点介绍一些指针和它们映射到机器代码的关键原则。
 - **每个指针都对应一个类型**。这个类型表明该指针指向的是哪一类对象；通常，如果对象类型为 `T`，那么指针类型为 `T *`；而特殊的 `void *` 类型代表通用指针（可以指向任意类型的数据，并且不能直接解引用，必须先强制转换成正确类型，常用于通用接口）；指针类型不是机器代码中的一部分，它们是 C 语言提供的一种抽象，来避免寻址错误。
 - **每个指针都有一个值**。这个值是某个指定类型的对象的地址。特殊的 `NULL(0)` 值表示该指针没有指向任何地方。
 - **指针用 `&` 运算符创建**。这个运算符可以应用到任何 `lvalue` 类的 C 表达式上， `lvalue` 意指可以出现在赋值语句左边的表达式。这样的例子包括变量以及结构、联合和数组的元素。因为 `leaq` 指令是设计用来计算内存引用的地址的，`&` 运算符的机器代码实现常常用这条指令来计算表达式的值。
 - **`*` 操作符用于间接引用指针**。其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
 - **数组与指针紧密联系**。一个数组的名字可以像一个指针变量一样引用（但是不能修改）。数组引用（例如 `a[3]` ）与指针运算和间接引用（例如 `*（a+3）` ）有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。当写表达式 `p+i`，这里指针 p 的值为 $p$，得到的地址计算为 $p+L·i$，这里 $L$ 是与 p 相关联的数据类型的大小。
 - **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值**。强制类型转换的一个效果是改变指针运算的伸缩（改变指针运算的所用的类型的大小 -- 步长）。
 - **指针可以指向函数**。这提供了引用的功能，这些引用可以被程序的某个其他部分调用。而函数指针的值是该函数机器代码表示中第一条指令的地址。

## 3.10.2 应用：使用 GDB 调试器
GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。对于本书中的示例和练习，试图通过阅读代码，来推断出程序的行为。有了 GDB，可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。

图 3-39 给出了一些 GDB 命令的例子，帮助研究机器级 x86-64 程序。先运行 OBJDUMP 来获得程序的反汇编版本，是有益处的。本书的示例都基于对文件 `prog` 运行 GDB，程序的描述和反汇编见 3.2.3 节。

用这个命令行来启动 GDB：`linux> gdb prog`

通常的方法是在程序中感兴趣的地方附近设置断点。断点可以设置在函数入口后面，或是一个程序的地址处。程序在执行过程中遇到一个断点时，程序会停下来，并将控制返回给用户。在断点处，能够以各种方式查看各个寄存器和内存位置。也可以单步跟踪程序，一次只执行几条指令，或是前进到下一个断点。

![[../../attachments/Pasted image 20250910221218.png]]

## 3.10.3 内存越界引用和缓冲区溢出
C 语言的数组和指针很强大，但它们没有**边界检查机制**。
- 编译器/CPU 不会确认访问的下标是不是合法的。
- 结果就是：**越界访问会破坏数组之外的内存区域**。
这就是 **内存越界引用（out-of-bounds reference）**。  
 - 如果只是读数据，可能得到垃圾值，或者触发段错误（Segmentation Fault）
 - 如果是写操作，可能破坏其他变量、寄存器保存值，甚至返回地址。

如果越界写破坏的是栈上的状态信息（如返回地址），就会造成 **缓冲区溢出（buffer overflow）**。

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为 **攻击代码(exploit code)**，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行 ret 指令的效果就是跳转到攻击代码。

在一种攻击形式中，攻击代码会使用系统调用启动一个 shell 程序，给攻击者提供命令行入口操纵操作系统。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，（表面上）正常返回到调用者。

> [!note]-
> > 蠕虫和病毒都试图在计算机中传播它们自己的代码段。蠕虫(worm)可以自己运行，并且能够将自己的等效副本传播到其他机器。病毒(virus)能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。在一些大众媒体中，用 ”病毒“ 指代各种在系统间传播攻击代码的策略，就会导致将蠕虫归为病毒。

## 3.10.4 对抗缓冲区溢出攻击
缓冲区溢出攻击的普遍发生给计算机系统造成了许多的麻烦。现代的编译器和操作系统实现了很多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。在本节中，将会介绍一些 Linux 上最新 GCC 版本所提供的机制。

### 1. 栈随机化
为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，如果攻击者可以确定一个常见的 Web 服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象常被称作 **安全单一化(security monoculture)**。

---
栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。

实现的方式是：程序开始时，在栈上分配一段 0~n 字节之间的随机大小的空间，程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范围必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。

---
在 Linux 系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为 **地址空间布局随机化(Address--Space Layout Randomization)**，或者简称 ASLR。

采用 ASLR，==每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域==。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的攻击。

然而，一个执着的攻击者总是能够用蛮力克服随机化，可以通过反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop(读作“no op”，no operatioin 的缩写)指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是 “空操作雪橇(nop sled)”，意思是程序会 “滑过” 这个序列。

这些能够增加成功攻击一个系统的难度，因而大大降低了病毒或者蠕虫的传播速度，但是也不能提供完全的安全保障。

### 2. 栈的破坏检测
计算机的第二道防线是能够检测到何时栈已经被破坏。破坏通常发生在当超越局部缓冲区的边界时。在 C 语言中，没有可靠的方法来防止对数组的越界写。但是，能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

在产生的代码中加入了一种 **栈保护者(stack protector)** 机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的 **金丝雀(canary)** 值，如图3-42所示。这个金丝雀值，也称为 **哨兵值(guard value)**，是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常中止。
![[../../attachments/Pasted image 20250911170019.png]]

栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为 GCC 只在函数中有局部 char 类型缓冲区的时候才插入这样的代码。当然，也有其他一些方法会破坏一个正在执行的程序的状态，但是降低栈的易受攻击性能够对抗许多常见的攻击策略。

### 3. 限制可执行代码区域
最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。

现代处理器支持 **NX（No-eXecute）位**，操作系统可以标记某些内存区域只读/不可执行。

## 3.10.5 支持变长栈帧
在前面所接触的各种函数的机器级代码中，编译器都能够预先确定需要为栈帧分配多少空间。

但是有些函数，需要的局部存储是变长的。例如，当函数调用 alloca 时就会发生这种情况。alloca 是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

为了管理变长栈帧，x86-64 代码使用寄存器 `%rbp` 作为 **帧指针(frame pointer)** (有时称为 **基指针(base pointer)**，这也是 `%rbp` 中 bp 两个字母的由来)。

### 栈帧的布局
固定大小栈帧布局：
```markdown
高地址 →
-----------------
调用者的栈帧
-----------------
返回地址
-----------------
旧的 %rbp
-----------------
局部变量（固定大小）
-----------------
低地址 →
```

变长栈帧的布局：
```markdown
高地址 →
-----------------
调用者的栈帧
-----------------
返回地址
-----------------
旧的 %rbp
-----------------
局部变量（固定部分）
-----------------
变长数组 / alloca 分配的空间
-----------------
低地址 →
```

### 访问局部变量的方式
- 固定大小栈帧：编译器直接用 **固定偏移量** 相对 `%rbp` 或 `%rsp` 访问。  
    比如 `movl -8(%rbp), %eax`。
- 变长栈帧：由于栈指针 `%rsp` 在运行过程中会变（随着 `alloca` 或数组大小不同），编译器需要额外保存一个指针，来可靠地访问固定部分的局部变量。
    

通常的做法：
- `%rbp` 指向 **栈帧的固定部分（基准点）**。
- `%rsp` 根据运行时分配往下移动，指向 **当前栈顶**。

# 3.11 浮点代码
1. **浮点体系结构关注点**
	- 浮点数 **存储/访问**：通过寄存器完成。
	- **浮点指令**：执行算术操作。
	- **参数传递/返回规则**：浮点参数如何进函数、结果如何出函数。
	- **寄存器保存规则**：调用者保存 vs 被调用者保存。
2. **历史演变**
	- **1997 Pentium/MMX**：引入媒体指令，支持 **SIMD** (单指令多数据)。
	- **MMX → SSE → AVX**：逐步扩展寄存器大小 & 功能。
	    - MMX → 64 位（`mm` 寄存器）。
	    - SSE → 128 位（`xmm`）。
	    - AVX → 256 位（`ymm`）。
3. **SIMD 特点**
	- 同一条指令可并行处理多个数据。
	- `ymm` (256 位) 可存：
	    - 8 × 32-bit 值（float 或 int）。
	    - 4 × 64-bit 值（double 或 int）。
4. **标量模式**
	- 从 **SSE2 (2000 Pentium 4)** 开始支持。
	- 可在 XMM/YMM 的 **低 32 位 (float)** 或 **低 64 位 (double)** 上做单个浮点操作。
	- x86-64 统一基于 SSE/AVX 作为浮点机制，不再依赖旧的 x87 FPU。
> [!abstract]-
> 这一节是什么破玩意

---
## 3.11.1 浮点传送和转换操作
图 3-46 给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。

引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中（由表中的 $M_{32}$ 和 $M_{64}$ 指明），要么保存在 XMM 寄存器中（在表中用 X 表示）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。

内存引用的指定方式与整数 MOV 指令的一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。
![[../../attachments/Pasted image 20250912125634.png]]

---
图 3-47 和图 3-48 给出了在浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量指令。图 3-47 中的指令把一个从 XMM 寄存器或内存中读出的浮点值进行转换，并将结果写入一个通用寄存器（例如 `%rax`、`%ebx` 等)。把浮点值转换成整数时，指令会执行 **截断(truncation)** ，把值向 0 进行舍入，这是 C 和大多数其他编程语言的要求。
![[../../attachments/Pasted image 20250912130712.png]]

图 3-48 中的指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节。而目标必须是 XMM 寄存器。在最常见的使用场景中，第二个源和目的操作数都是一样的。

- `vcvtss2sd`：单精度 → 双精度。
- `vcvtsd2ss`：双精度 → 单精度（可能损失精度）。

## 3.11.2 过程中的浮点代码
### 1. 参数传递和返回值
- **整数和指针** → 通过 **通用寄存器**（如 `%rdi, %rsi …`）传递。
- **浮点参数** → 通过 **XMM 寄存器**（`%xmm0, %xmm1, …`）传递。
- **返回值**：
    - `float` / `double` 返回在 `%xmm0`。
    - `int` / `long` 返回在 `%rax`。

### 2. 调用者保存 & 被调用者保存
- 浮点寄存器 `%xmm0` ~ `%xmm15` 的使用规则：
    - **调用者保存（caller-saved）**：调用函数前，调用者要自己保存需要保留的寄存器值。
    - **被调用者保存（callee-saved）**：一般浮点寄存器 **不要求保存**，只有通用寄存器里的一部分需要被调用者保存。
这意味着浮点计算更灵活，减少了寄存器保存/恢复的开销。

### 3. 栈帧中的浮点局部变量
- 如果浮点值 **只在寄存器中使用**，编译器不会放到栈里。
- 如果函数需要保存局部数组、地址传递、或寄存器溢出（不够用），浮点数会被存到 **栈帧中**。

## 3.11.3 浮点运算操作
图 3-49 描述了一组执行算术运算的标量 AVX2 浮点指令。每条指令有一个($S_1$)或两个($S_1,S_2$)源操作数，和一个目的操作数 D。第一个源操作数 $S_1$，可以是一个 XMM 寄存器或一个内存位置。第二个源操作数和目的操作数都必须是 XMM 寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。
![[../../attachments/Pasted image 20250912140028.png]]

和整数运算的区别：
- 整数运算可以用通用寄存器（`rax`, `rbx`, …），浮点运算必须用 **XMM 寄存器**。
- 整数 ALU 和浮点单元是 **分开的硬件**。
- 浮点寄存器运算不会影响整数的条件码（`ZF`, `SF`, `OF`, …）。比较要用专门的浮点比较指令

## 3.11.4 定义和使用浮点常数
和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数（因为在 x86-64 的指令集中，**没有直接把浮点立即数写到寄存器的指令**）。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读入。

## 3.11.5 在浮点代码中使用位级操作
- **GCC 编译器有时候会用位级操作来处理浮点数**，而不是显式地调用浮点运算指令。
- 这些位级操作（如 `andps`、`orps`、`xorps` 等）跟通用寄存器的按位逻辑运算一一对应，只不过它们的目标是 **XMM 寄存器**。
- 操作作用在整个 128 位 XMM 寄存器上，但只需要关心其中的低 32 位（单精度）或低 64 位（双精度），因为这才是标量浮点数所在的位置。
- 用法示例：通过位掩码可以快速实现浮点数的 **取绝对值、取相反数、符号复制** 等，而无需调用专门的浮点指令。

## 3.11.6 浮点比较操作
AVX2 提供了两条用于比较浮点数值的指令：
![[../../attachments/Pasted image 20250912145750.png]]

这些指令类似于 CMP 指令（参见 3.6 节），它们都比较操作数 $S_1$ 和 $S_2$(但是顺序可能与预计的相反)，并且设置条件码指示它们的相对值。与 cmpq 一样，它们遵循以相反顺序列出操作数的 ATT 格式惯例。参数 $S_2$ 必须在 XMM 寄存器中，而 $S_1$ 可以在 XMM 寄存器中，也可以在内存中。

浮点比较指令会设置三个条件码：零标志位 ZF、进位标志位 CF 和奇偶标志位 PF。

对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个 1)，那么就会设置奇偶标志位。不过对于浮点比较，当两个操作数中任一个是 NaN 时，会设置该位。根据惯例，C 语言中如果有个参数为 NaN，就认为比较失败了，这个标志位就被用来发现这样的条件。

条件码的设置条件如下：
![[../../attachments/Pasted image 20250912150355.png]]

当任一操作数为 NaN 时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。通常 jp(jump on parity) 指令是条件跳转，条件就是浮点比较得到一个无序的结果。除了这种情况以外，进位和零标志位的值都和对应的无符号比较一样：当两个操作数相等时，设置 ZF;当 $S_2<S_1$ 时，设置 CF。像 ja 和 jb 这样的指令可以根据标志位的各种组合进行条件跳转。

## 3.11.7 对浮点代码的观察结论
可以看到，用 AVX2 为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。

当然，处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂之处，同时，AVX2 代码包括许多比只执行整数运算的函数更加不同的指令和格式。

AVX2 还有能力在封装好的数据上执行并行操作，使计算执行得更快。编译器开发者正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可靠的方法是使用 GCC 支持的、操纵向量数据的 C 语言扩展。

# 3.12 小结 -- 其他编译方式
目前只分析了 C 到 x86-64 的映射，但是大多数内容对其他语言和机器组合来说也是类似的。

例如，编译 C++ 与编译 C 就非常相似。实际上，C++ 的早期实现就只是简单地执行了从 C++ 到 C 的源到源的转换，并对结果运行 C 编译器，产生目标代码。C++ 的对象用结构来表示，类似于 C 的 `struct`。C++ 的方法是用指向实现方法的代码的指针来表示的。

相比而言，Java 的实现方式完全不同。Java 的目标代码是一种特殊的二进制表示，称为 Java 字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。

另外，有一种称为 **及时编译(just-in-time compilation)** 的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行，而在本章谈到的机器代码只能在 x86-64 机器上运行。

