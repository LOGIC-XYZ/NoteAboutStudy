在本章中，将详细学习一种特别的汇编语言，了解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同于手工编写汇编代码。必须了解典型的编译器在将 C 程序结构变换成机器代码时所做的转换。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解。这是一种 **逆向工程(reverse engineering)** -- 通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且可以做试验，让编译器产生许多不同程序的代码。

# 3.1 历史观念
Intel 处理器系列俗称 x86 ，经历了一个长期的、不断进化的发展过程。开始时，它是第一代单芯片、16 位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。
并且每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理器上运行。

# 3.2 程序编码
假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们用 Unix命令行编译这些代码：  `linux>gcc -Og -o p p1.c p2.c` 
命令 gcc 指的就是 GCC C 编译器。因为这是 Linux 上默认的编译器，也可以简单地用 cc 来启动它。编译选项 -Og 是告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此会使用 -Og 优化作为学习工具，然后当增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项 -O1 或 -O2 指定）被认为是较好的选择。
编译的过程可参考 [[第1章 计算机系统漫游]] 2.1 节。

## 3.2.1 机器级代码
正如在 1.9.3 节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。
- 第一种是由 **指令集体系结构或指令集架构(Instruction Set Architecture, ISA)** 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。
- 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。==汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。==能够理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：
- 程序计数器（通常称为 “PC”，在 x86-64 中用 `%rip`表示）给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc 库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如，x86-64 的虚拟地址是由 64 位的字来表示的。在目前的实现中，这些地址的高 16 位必须设置为 0，所以一个地址实际上能够指定的是 $2^{48}$ 或 $64TB$ 范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

一条机器指令只执行一个非常基本的操作。

> [!tip]
> 本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结构。而读者需要将这些技术应用到个人的特定的编译器产生的代码格式上（不同的机器可能产生不同的代码）。

## 3.2.2 代码示例
假设我们写了一个 C 语言代码文件 mstore.c 包含如下的函数定义：
```c
long mult2(long,long);
void multstore(long x,long y,long *dest){
	long t mult2(x,y);
	*dest =t;
}
```

在命令行上使用 ”-S“ 选项，就能看到 C 语言编译器产生的汇编代码 `mstore.s`，这会使 GCC 运行编译器并产生一个汇编文件，但是不做其他进一步的工作。（通常情况下，还会继续调用汇编器产生目标文件代码）
`linux> gcc -Og -S mstore.c`

汇编代码文件包含各种声明，包括以下几行，代码中每个缩进去的行都对应于一条机器指令：
```
mulstore
  pushq    %rbx
  movq     %rdx,%rbx
  call     mult2
  movq     %rax,(%rbx)
  popq     %rbx
  ret
```


在命令行上使用 ”-c“ 选项，GCC 会编译并汇编该代码，并产生目标代码文件 `mstore.o`，是二进制格式的，所以机器执行的程序只是一个字节序列，它是对一系列指令的编码，而机器对产生这些指令的源代码几乎一无所知。


如果要查看机器代码文件的内容，有一类称为 **反汇编器（disassembler）** 的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux 系统中，带 ”-d“ 命令行标志的程序 OBJDUMP（表示“object dump”）可以充当这个角色：
`linux> objdump -d mstore.o`

结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：
在左边，按照前面给出的字节顺序排列的 14 个十六进制字节值，它们分成了若
干组，每组有 1～5 个字节。每组都是一条指令，右边是等价的汇编语言。
```
Disassemblyof function multstore in binary file mstore.o
1    0000000000000000<multstore>:
     Offset   Bytes                 Equivalent assembly language
2        0:   53                    push    %rbx
3        1:   48 89 d3              mov     %rdx,%rbx
4        4:   e8 00 00 00 00        callq   9 <multstore+0x9>
5        9:   48 89 03              mov     %rax,(%rbx)
6        c:   5b                    pop     %rbx
7        d:   c3                    retq
```

其中一些关于机器代码和它的反汇编表示的特性值得注意：
- x86-64 的指令长度从 1 ~ 15 个字节不等。==常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多==。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 `pushq %rbx` 是以字节值 53 开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的 'q'。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了 'q' 后缀，同样，省略这些后缀也没有问题。


生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。

假设在文件 main.c 中有下面这样的函数：
```
#include<stdio.h>
void multstore（long,long,long*);
int main(){
	long d;
	multstore（2,3，&d）;
	printf（"2 * 3 --> %ld\n"，d）;
	return 0;
}
longmult2（longa，longb）{
	long s = a * b;
return s;
}
```
然后 `linux> gcc -Og -o prog main.c mstore.c` 生成可执行文件 prog，此时，不仅包含了用来启动程序和终止程序的代码，以及用来与操作系统交互的代码。此时反汇编后的部分结果与 `mstore.c` 对比可以发现三个区别：
```
Disassemblyof function multstore in binary file prog
1    0000000000400540<multstore>:
2     400540:   53                    push    %rbx
3     400541:   48 89 d3              mov     %rdx,%rbx
4     400544:   e8 42 00 00 00        callq   40058b <mult2>
5     400549:   48 89 03              mov     %rax,(%rbx)
6     40054c:   5b                    pop     %rbx
7     40054d:   c3                    retq
8     40054e:   90                    nop
9     40054f:   90                    nop
```
- 左边列出的地址不同 -- 链接器将这段代码的地址移到了一段不同的地址范围中。
- 链接器填上了 callq 指令调用函数 mult2 需要使用的地址（反汇编代码第 4 行）。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。
- 多了两行代码（第 8 和 9 行）。这两条指令对程序没有影响，因为它们出现在返回指令后面（第 7 行）。插入这些指令是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能更好地放置下一个代码块。

## 3.2.3 关于格式的注解
GCC 产生的汇编代码对人类来说有点儿难读。一方面，它包含一些不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。

所有以 '.' 开头的行都是指导汇编器和链接器工作的伪指令。通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

为了更清楚地说明汇编代码，用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于示例，带解释的汇编代码如下：
![[../../attachments/Pasted image 20250902203445.png]]
通常只会给出与讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C 语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。

# 3.3 数据格式
由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 “字（word）” 表示 16 位数据类型。因此，称 32 位数为 “双字（doublewords）”，称 64 位数为 “四字（quadwords）”。
![[../../attachments/Pasted image 20250902203907.png]]

浮点数主要有两种形式：单精度（4 字节）值，对应于 C 语言数据类型 float；双精度（8 字节）值，对应于 C 语言数据类型 double。

==大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。==

注意，汇编代码也使用后缀 ’l‘ 来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

# 3.4 访问信息
一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的 **通用目的寄存器**。这些寄存器用来存储整数数据和指针。

图 3-2 显示了这 16 个寄存器。它们的名字都以 `%r` 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最初的 8086 中有 8 个 16 位的寄存器，即图 3-2 中的 `%ax` 到 `%bp`。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 `%eax` 到 `%ebp`。扩展到 x86-64 后，原来的 8 个寄存器扩展成 64 位，标号从 `%rax` 到 `%rbp`。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规则制定的：从 `%r8` 到 `%r15`。
![[../../attachments/Pasted image 20250902204734.png]]

如图 3-2 中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。

就像图 3-2 右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针 `%rsp`，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

## 3.4.1 操作系统指示符
大多数指令有一个或多个操作数（operand），指示出执行一个操作中==要使用的源数据值，以及放置结果的目的位置==。x86-64 支持多种操作数格式（参见图 3-3）。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。
- 第一种类型是 **立即数（immediate）** ，用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是 `$` 后面跟一个用标准 C 表示法表示的整数，比如， `$-577` 或 `$0x1F`。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种类型是 **寄存器（register）** ，它表示某个寄存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8 位、16 位、32 位或 6 4位。在图 3-3 中，用符号 $r_a$ 来表示任意寄存器a，用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看成一个数组 R，用寄存器标识符作为索引。
- 第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，用符号 $M_b[Addr]$ 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，通常省去下标 b。

如图 3-3 所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法 $Imm(r_b,r_i,s)$ 表示的是最常用的形式。
这样的引用有四个组成部分：一个立即数偏移 $Imm$，一个基址寄存器 $r_b$，一个变址寄存器 $r_i$ 和一个比例因子 $s$，这里 s 必须是 1、2、4 或者 8。基址和变址寄存器都必须是 64 位寄存器。
有效地址被计算为 $Imm+R[r_b]+R[r_i]·s$。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。
![[../../attachments/Pasted image 20250902210022.png]]

# 3.4.2 数据传送指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

有多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在该讲述中，把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只是操作数大小不同。

MOV 类 -- 最简单形式的数据传送指令，这些指令把数据从源位置复制到目的位置，不做任何变化。该类由四条指令组成：movb、movw、movl 和 movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、 2、4 和 8 字节。
![[../../attachments/Pasted image 20250902210526.png]]

