一个处理器支持的指令和指令的字节级编码称为它的 **指令集体系结构（Instruction-SetArchitecture，ISA）** 。
- 不同的处理器“家族”，都有不同的 ISA。
- 一个程序编译成在一种机器上运行，就不能在另一种机器上运行。
- 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 ISA 级别上都保持着兼容。
- 一些常见的处理器家族（例如 x86-64）中的处理器分别由多个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。

ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一些特殊的机制。

本章首先通过自定义一个简单的指令集 Y86-64 来作为处理器实现的运行示例（受 x86-64 指令集的启发），数据类型、指令、寻址方式更少，编码更简单（不紧凑但容易解码），功能足够强大，可以写一些处理整数的程序。

接下来会提供一些数字硬件设计背景，包括处理器中使用的基本构建块，以及它们是如何连接起来和操作，会介绍 HCL（Hardware Control Language，硬件控制语言） -- 一种描述硬件系统控制部分的简单语言。

作为设计处理器的第一步，先构建一个 **顺序执行的 Y86-64 处理器**：每个时钟周期只执行一条完整的指令，优点：功能正确，逻辑简单，缺点：性能差，因为时钟必须足够慢，保证所有操作在一个周期内完成。

以顺序设计为基础，进行优化，创建一个 **流水线化的处理器（pipelined processor）** ，把一条指令分成 **5 个阶段**（取指、译码、执行、访存、写回），每个阶段由不同硬件完成，每个时钟周期都有新指令进入，使得同一时间有多条指令在不同阶段执行 → 并行度提升，性能大大提高。

但是为了使这个处理器保留 Y86-64 ISA 的顺序行为，就要求处理很多 **冒险或冲突（hazard）** 情况。冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令。

---
# 4.1 Y86-64 指令集体系结构
定义一个指令集体系结构（例如 Y86-64）包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

---
## 4.1.1 程序员可见的状态
![[NoteAboutStudy/attachments/Pasted image 20250921192754.png]]
如图 4-1 所示，Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这称为 **程序员可见状态** ，这里的 “程序员” 既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。

在处理器实现中，只要保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方式（顺序执行指令）来表示和组织这个处理器状态。

Y86-64 的状态类似于 x86-64。有 15 个程序寄存器：`%rax`、`%rcx`、`%rdx`、`%rbx`、`%rsp`、`%rbp`、`%rsi`、`%rdi` 和 `%r8` 到 `%r14`。(省略了 x86-64 的寄存器 `%r15` 以简化指令的编码。) 每个程序寄存器存储一个 64 位的字。寄存器 `%rsp` 被入栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。有 3 个一位的条件码： ZF、SF 和 OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。程序计数器 (PC) 存放当前正在执行指令的地址。

**内存** 从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或 **物理地址** ，指明数据实际存在内存中哪个地方。目前只需认为虚拟内存系统向 Y86-64 程序提供了一个单一的字节数组映像。

程序状态的最后一个部分是状态码 `Stat`，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常，例如当一条指令试图去读非法的内存地址时。

## 4.1.2 Y86-64 指令
图 4-2 给出了 Y86-64 ISA 中各个指令的简单描述。这个指令集就是处理器实现的目标。Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，寻址方式较少，操作也较少。因为只有 8 字节数据，所以称之为 “字(word)” 不会有任何歧义。在这个图中，左边是指令的汇编码表示，右边是字节编码。而图 4-3 给出了其中一些指令更详细的内容。汇编代码格式类似于 x86-64 的 ATT 格式。

以下为 Y86-64 的一些细节：
 - x86-64 的 `movq` 指令分成了 4 个不同的指令：`irmovq`、`rrmovq`、`mrmovq` 和 `movq`，分别显式地指明源和目的的格式。源可以是立即数(`i`)、寄存器(`r`)或内存(`m`)。指令名字的第一个字母就表明了源的类型。目的可以是寄存器(`r`)或内存(`m`)。指令名字的第二个字母指明了目的的类型。在决定如何实现数据传送时，显式地指明数据传送的这 4 种类型是很有帮助的。
	 - 两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。在地址计算中，不支持第二变址寄存器( second index register )和任何寄存器值的伸缩( scaling )。
	 - 同 x86-64 一样，不允许从一个内存地址直接传送到另一个内存地址。另外，也不允许将立即数传送到内存。
 - 有4个整数操作指令，如图 4-2 中的 `OPq`。它们是 `addq`、`subq`、`andq` 和 `xorq`。它们只对寄存器数据进行操作，而 x86-64 还允许对内存数据进行这些操作。这些指令会设置 3 个条件码 ZF、SF 和 OF(零、符号和溢出)。
 - 7 个跳转指令（图 4-2 中的 `jXX` )是 `jmp`、`jle`、`jl`、`je`、`jne`、`jge` 和 `jg`。根据分支指令的类型和条件代码的设置来选择分支。分支条件和 x86-64 的一样（见图 3-15  -- 3.6.3）
 - 有 6 个条件传送指令（图 4-2 中的 `cmovXX`): `cmovle`、`cmovl`、`cmove`、`cmovne`、`cmovge` 和 `cmovg`。这些指令的格式与寄存器 - 寄存器传送指令 `rrmovq` 一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。
 - call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。
 - `pushq` 和 `popq` 指令实现了入栈和出栈，如同 x86-64。
 - `halt` 指令停止指令的执行。x86-64 中有一个与之相当的指令 `hlt`。x86-64 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86-64 来说，执行 `halt` 指令会导致处理器停止，并将状态码设置为 HLT (参见 4.1.4 节)
![[NoteAboutStudy/attachments/Pasted image 20250921193547.png]]

## 4.1.3 指令编码
图 4-2 还给出了指令的字节级编码。每条指令需要 1~10 个字节不等，这取决于需要哪些字段。

每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是 **代码(code)** 部分，低 4 位是 **功能(function)** 部分。如图 4-2 所示，代码值为 `0 ~ 0xB`。功能值只有在一组相关指令共用一个代码时才有用。图 4-3 给出了整数操作、分支和条件传送指令的具体编码。可以观察到， `rrmovq` 与条件传送有同样的指令代码。可以把它看作是一个 “无条件传送” ，就像 `jmp` 指令是无条件跳转一样，它们的功能代码都是 0。

![[NoteAboutStudy/attachments/Pasted image 20250921201949.png]]

如图 4-4 所示，15 个程序寄存器中每个都有一个相对应的范围在 `0 ~ 0xE` 之间的寄存器标识符( register ID )。Y86-64 中的寄存器编号跟 x86-64 中的相同。程序寄存器存在 CPU 中的一个 **寄存器文件** 中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随机访问存储器。在指令编码中以及硬件设计中，当需要指明不应访问任何寄存器时，就用 ID 值 `0xF` 来表示。

有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加的 **寄存器指示符字节( register specifier byte )**，指定一个或两个寄存器。在图 4-2 中，这些寄存器字段称为 rA 和 rB。从指令的汇编代码表示中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。

没有寄存器操作数的指令，例如分支指令和 `call` 指令，就没有寄存器指示符字节。那些只需要一个寄存器操作数的指令( `irmovq`、`pushq` 和`popq` )将另一个寄存器指示符设为 `0xF`。

![[NoteAboutStudy/attachments/Pasted image 20250921202236.png]]

有些指令需要一个附加的 4 字节常数字( constant word )。这个字能作为 `irmovq` 的立即数数据，`rmmovq` 和 `mrmovq` 的地址指示符的偏移量，以及分支指令和调用指令的目的地址。

注意，分支指令和调用指令的目的是一个绝对地址，而不像 IA32 中那样使用 PC (程序计数器)相对寻址方式。处理器使用 PC 相对寻址方式，分支指令的编码会更简洁，同时这样也能允许代码从内存的一部分复制到另一部分而不需要更新所有的分支目标地址。因为更关心描述的简单性，所以就使用了绝对寻址方式。

同 IA32 一样，所有整数采用小端法编码。当指令按照反汇编格式书写时，这些字节就以相反的顺序出现。


**指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。**

Y86-64 就具有这个性质，因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，仍然可以很容易地确定指令序列。反过来说，如果不知道一段代码序列的起始位置，就不能准确地确定怎样将序列划分成单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其他一些工具来说，这就带来了问题。

> [!hint]- RISC 和 CISC 指令集
> RISC（精简指令集）
> 特点：
>  - 指令种类少，形式统一（大多是固定长度，比如 32 位）。
>  - 每条指令完成的功能相对简单（如：加法、加载、存储）。
>  - 更多依赖编译器优化，把复杂操作拆成多条简单指令。
>  - 目标：简化硬件译码，提升流水线并行度。
>
> 代表架构 - MIPS、RISC-V、ARM（早期版本）。
> 
> 优点：
>  - 指令格式统一 → 硬件实现简单，容易做高速流水线。
>  - 高性能 → 现代高性能 CPU 内核大多借鉴 RISC 思路。
> ---
> CISC（复杂指令集）
> 特点：
>  - 指令种类多，长度可变。
>  - 每条指令能完成较复杂的操作（例如一条指令就能“从内存取数 + 做乘法 + 存回去”）。
>  - 最初设计目标：提高汇编程序员的开发效率，让代码更紧凑。
>
> 代表架构 - x86、x86-64。
> 
> 优点：
>  - 单条指令能做更多事，机器码更紧凑（节省内存）。
>  - 对编译器不够强大的早期环境友好。

## 4.1.4 Y86-64 异常
对 Y86-64 来说，程序员可见的状态（图 4-1）包括状态码 `Stat`，它描述程序执行的总体状态。

这个代码可能的值如下：
 - 代码值 1，命名为 `AOK`，表示程序执行正常，而其他一些代码则表示发生了某种类型的异常。
 - 代码值 2，命名为 `HLT`，表示处理器执行力一条 `halt` 指令。
 - 代码值 3，命名为 `ADR`，表示处理器试图从一个非法内存地址读或向一个非法内存地址写，可能是当取指令的时候，也可能是当读或者写数据的时候。会限制最大的地址（确切的限定值因实现而异），任何访问超出这个限定值的地址都会引发ADR异常。
 - 代码 4，命名为 `INS`，表示遇到了非法的指令代码。

任何 `AOK` 以外的代码都会使处理器停止。

对于 Y86-64，当遇到这些异常的时候，就只是简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个 **异常处理程序（exception handler）**，这个过程被指定用来处理遇到的某种类型的异常。

## 4.1.5 Y86-64 程序
实践的一节（具体看书）

## 4.1.6 一些 Y86-64 指令的详情
- **大多数 Y86-64 指令都是“直观”的**
    - 就是说它们对程序状态的修改方式跟我们想象的一致，没有额外的歧义。
    - 比如 `addq`, `subq`, `rmmovq`, `mrmovq`, `irmovq`，行为都直接。
        
- **特殊情况：`pushq %rsp` 的歧义**
    - 指令语义：
        `R[rsp] ← R[rsp] - 8 M[R[rsp]] ← R[rA]`
    - 如果 `rA = rsp`，就出现冲突：
        - 是压入旧的 `%rsp` 值，还是压入减 8 后的新值？
    - 两种约定：
        1. 压入原始 `%rsp` 的值
        2. 压入 `R[rsp] - 8` 的值
    - **Y86-64 选择与 x86-64 一致**：采用方案 ② —— 压入减 8 后的值。

# 4.2 逻辑设计和硬件控制语言 HCL
在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压或低电压来表示不同的位值。在当前的技术中，逻辑 1 是用 1.0 伏特左右的高电压表示的，而逻辑 0 是用 0.0 伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。

> [!note]- 现代逻辑设计
> 过去电路设计依赖手工绘制逻辑图，现在普遍使用硬件描述语言（HDL）来以文本方式描述电路结构，常见的有语法类似 C 的 Verilog 和类似 Ada 的 VHDL。最初 HDL 主要用于电路的模拟建模，但自 20 世纪 80 年代逻辑综合工具出现后，人们可以直接从 HDL 生成高效电路，实现了类似于从汇编过渡到高级语言再用编译器生成机器码的转变。本书采用的 HCL 语言仅用于描述微处理器的控制逻辑，虽然功能有限、没有模块化，但控制部分正是设计中最复杂的环节。借助 HCL 转译为 Verilog 并结合硬件单元代码，就能合成可运行的 Y86-64 处理器，从而通过分离、设计和测试控制逻辑，逐步构建出一个完整的微处理器。

---
## 4.2.1 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。
 - **与门**：有 0 为 0，全 1 为 1；
 - **或门**：有 1 为 1，全 0 为 0；
 - **非门**：取反；
 - **与非门**：有 0 为 1，全 1 为 0；
 - **或非门**：有 1 为 0，全 0 为 1；
 - **异或门**：不同为 1；
 - **同或门**：相同为 1；

逻辑门总是活动的(active)。一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。

## 4.2.2 组合电路和 HCL 布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为 **组合电路(combinational circuits)** 。如何构建这些网有几个限制：
 - 每个逻辑门的输人必须连接到下述选项之一：1)一个系统输入（称为主输入），2)某个存储器单元的输出，3)某个逻辑门的输出。
 - 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
 - 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。

HCL 表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应之处。它们都是用布尔操作来对输人进行计算的函数。值得注意的是，这两种表达计算的方法之间有以下区别：
 - 因为组合电路是由一系列的逻辑门组成，它的属性是输出会持续地响应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C 表达式只会在程序执行过程中被遇到时才进行求值。
 - C 的逻辑表达式允许参数是任意整数，0 表示 FALSE ，其他任何值都表示 TRUE。而逻辑门只对位值 0 和 1 进行操作。
 - C 的逻辑表达式有个属性就是它们可能只被部分求值。如果一个 AND 或 OR 操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了。

## 4.2.3 字级的组合电路和 HCL 整数表达式
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

字级的逻辑运算可以看成是：**并行地对每一位进行位级运算**。

HCL里，除了布尔表达式，还支持整数表达式，用来描述字级运算。
- **算术运算**：`+`、`-`（比如做加法器）
- **逻辑运算**：`&`、`|`、`^`（按位与、或、异或）
- **移位运算**：`<<`（左移）、`>>`（右移，逻辑或算术右移）
这些都和 C 语言里的运算符很像。

## 4.2.4 集合关系
在硬件设计里，除了数值计算（加减乘除）之外，还需要判断 **关系**，比如：
- 两个数是否相等？
- 一个数是否小于另一个？
- 一个数是否小于等于另一个？
这些操作在处理器中非常重要，因为 **条件分支**、**比较指令** 都依赖这种结果。

结果 **不是整数**，而是布尔值。

## 4.2.5 存储器和时钟
组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生 **时序电路(sequential circuit)**，也就是有状态并且在这个状态上进行计算的系统，需要引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
 - 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。
 - 随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：
	 1) 处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字；
	 2) 寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器( `%rax~%r14`)。



> [!tip]- “寄存器”
> 在说到硬件和机器级编程时，“寄存器”这个词是两个有细微差别的事情。
>  - 在硬件中，寄存器直接将它的输人和输出线连接到电路的其他部分。
>  - 在机器级编程中，寄存器代表的是 CPU 中为数不多的可寻址的字，这里的地址是寄存器 ID 。这些字通常都存在寄存器文件中，虽然硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。
> 
> 需要避免歧义时，会分别称呼这两类寄存器为“硬件寄存器”和“程序寄存器”。

大多数时候，硬件寄存器都保持在稳定状态（用 x 表示），产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入（用 y 表示），但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输人信号就加载到寄存器中，成为下一个状态 y，直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。Y86-64 处理器会用时钟寄存器保存程序计数器(PC)、条件代码(CC)和程序状态(Stat)。

![[NoteAboutStudy/attachments/Pasted image 20250927164206.png]]

寄存器文件有两个读端口( A 和 B )，还有一个写端口( W )。这样一个 **多端口** 随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。地址是用图 4-4 中编码表示的寄存器标识符。两个读端口有地址输入 `srcA` 和 `srcB`(“source A”和“source B”的缩写)和数据输出 `valA` 和 `valB` (“value A”和“value B”的缩写)。写端口有地址输入 `dstW` (“destination W”的缩写)，以及数据输入 `valW` (“value W”的缩写)。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，在实现中，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当 `srcA` 或  `srcB` 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应程序寄存器的值就会出现在 `valA` 或 `valB` 上。

向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入 `valW` 上的值会被写入输入 `dstW` 上的寄存器 ID 指示的程序寄存器。当 `dstW` 设为特殊的 ID 值 `0xF` 时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，如果试图同时读和写同一个寄存器会发生什么？**先看到旧值，后更新成新值**。因为在时钟边沿触发写入前，读端口读到的是旧值。等时钟上升沿到来，寄存器才被更新。

![[NoteAboutStudy/attachments/Pasted image 20250927164744.png]]

这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。

读操作像组合逻辑，立即根据地址返回数据；写操作则受时钟控制，在时钟沿更新数据。系统通过 `error` 信号来检查地址是否合法。

# 4.3 Y86-64 的顺序实现
先设计一个最简单的顺序处理器 SEQ，在每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤。但这需要一个很长的时钟周期时间，时钟周期频率很低。

这样做的目的是先打好基础，再一步步改造，最终实现一个高效的流水线处理器。

---
## 4.3.1 将处理组织成阶段
虽然不同指令所要实现的不同，但通过把执行步骤划分为一系列统一的阶段，就能让所有指令都 “看起来” 遵循同一个流程，创建这样一个框架，处理器的硬件设计就可以被统一和简化，更好地去复用。

下面是关于各个阶段以及阶段内执行操作的简略描述：

 - **取指**(fetch)：取指阶段从内存读取指令字节，地址为程序计数器(PC)的值。
	 - 从指令中抽取出指令指示符字节的两个四位部分，称为 `icode`(指令代码)和 `ifun`(指令功能)。
	 - 可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 `rA` 和 `rB`。
	 - 还可能取出一个四字节常数字 `valC`。
	 - 按顺序方式计算当前指令的下一条指令的地址 `valP` -- `valP` 等于 `PC` 的值加上已取出指令的长度。

 - **译码**(decode)：译码阶段从寄存器文件读入最多两个操作数，得到值 `valA` 和 `/` 或 `valB`。
	 - 通常，它读入指令 `rA` 和 `rB` 字段指明的寄存器，不过有些指令是读寄存器 `%rsp` 的。

 - **执行**(execute)：在执行阶段，算术/逻辑单元(ALU)要么执行指令指明的操作（根据 `ifun` 的值)，计算内存引用的有效地址，要么增加或减少栈指针。得到的值称为 `valE`。
	 - 也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由 `ifun` 给出），如果条件成立，则更新目标寄存器。
	 - 同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。

 - **访存**(memory)：访存阶段可以读写内存。读出的值为 `valM`。

 - **写回**(write back)：写回阶段最多可以写两个结果到寄存器文件。

 - **更新PC**(PC update)：将 PC 设置成下一条指令的地址。

处理器无限循环，执行以上这些阶段。
 - 在这章学习中所简化的实现中，发生任何异常，处理器都会停止，比如：执行 `halt` 指令或非法指令，或试图读或写非法地址；
 - 在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型所决定的特殊代码。

## 4.3.2 SEQ 硬件结构
实现所有 Y86-64 指令所需要的计算可以被组织成 6 个基本阶段：取指、译码、执行、访存、写回和更新 PC。图 4-22 给出了一个能执行这些计算的硬件结构的抽象表示。程序计数器放在寄存器中，在图中左下角（标明为 “PC”)。然后，信息沿着线流动（多条线组合在一起就用宽一点的灰线来表示)，先向上，再向右。同各个阶段相关的 **硬件单元(hardware units)** 负责执行这些处理。在右边，反馈线路向下，包括要写到寄存器文件的更新值，以及更新的程序计数器值。
![[NoteAboutStudy/attachments/Pasted image 20250930215248.png]]

**在SEQ中，所有硬件单元的处理都在一个时钟周期内完成。**

这张图省略了一些小的组合逻辑块，还省略了所有用来操作各个硬件单元以及将相应的值路由到这些单元的控制逻辑。后面有张更细致的图。

将硬件单元与各个处理阶段相关联：
 - **取指**：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC 增加器(PC incre- menter)计算 `valP`，即增加了的程序计数器。
 - **译码**：寄存器文件有两个读端口 `A` 和 `B`，从这两个端口同时读寄存器值 `valA` 和 `valB`。
 - **执行**：执行阶段会根据指令的类型，将算术/逻辑单元(ALU)用于不同的目的。对整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加 0，将一个输入传递到输出。
	 - 条件码寄存器(CC)有三个条件码位。ALU 负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。
	 - 当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号 `Cnd`。
 - **访存**：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。
 - **写回**：寄存器文件有两个写端口。端口 E 用来写 ALU 计算出来的值，而端口 M 用来写从数据内存中读出的值。 
 - **PC 更新**：程序计数器的新值选择自：`valP`，下一条指令的地址；`val`，调用指令或跳转指令指定的目标地址；`valM`，从内存读取的返回地址。

![[NoteAboutStudy/attachments/Pasted image 20250930223849.png]]

> [!tip] 硬件画图惯例
>- 白色方框表示时钟寄存器。程序计数器 PC 是 SEQ 中唯一的时钟寄存器。
>- 浅蓝色方框表示硬件单元。这包括内存、ALU 等等。在所有的处理器实现中，都会使用这一组基本的单元。把这些单元当作“黑盒子”，不关心它们的细节设计。
>- 控制逻辑块用灰色圆角矩形表示。这些块用来从一组信号源中进行选择，或者用来计算一些布尔函数。书中会非常详细地分析这些块，包括给出 HCL 描述。
>- 线路的名字在白色圆圈中说明。它们只是线路的标识，而不是什么硬件单元。
>- 宽度为字长的数据连接用中等粗度的线表示。每条这样的线实际上都代表一簇 64根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分。宽度为字节或更窄的数据连接用细线表示。根据线上要携带的值的类型，每条这样的线实际上都代表一簇 4 根或 8 根线。
>- 单个位的连接用虚线来表示。这代表芯片上单元与块之间传递的控制值。

## 4.3.3 SEQ 的时序
SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存器)，随机访问存储器（寄存器文件、指令内存和数据内存）。
- **组合逻辑**：当输入发生变化时，输出会立刻发生变化，输出不由时钟控制（指令内存（只读）和寄存器文件的读操作，也可以当成组合逻辑看待）；
- **需要时钟控制的存储单元**：
	- **程序计数器（PC）**：每个时钟周期更新，装载下一条指令地址。
	- **条件码寄存器**：仅在执行整数运算指令时更新。
	- **数据内存**：仅在执行 `rmmovq`、`pushq`、`call` 等指令时进行写操作。
	- **寄存器文件**：写操作受控，每个周期最多可更新两个寄存器。可以用特殊的寄存器 ID `0xF` 作为端口地址，来表明在此端口不应该执行写操作。

**写入** 都受时钟上升沿控制；**读出** 则像组合逻辑一样立即可用。所有更新都在时钟上升时“同时发生”，保证顺序执行的等价性。

但是，如果执行过程中需要 “读刚刚写入的结果” 呢？就会导致矛盾。

所以建立一条关键原则：**从不回读** -- 处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。从而保证 **指令在执行时只依赖上个周期完成的状态，而不是本条指令刚刚更新的状态**。

**时序过程的描述**
- 在每个时钟周期：
    1. **周期开始** → 状态寄存器保持旧值；
    2. **周期中** → 新指令在组合逻辑里传播，计算出下一步所需的值；
    3. **周期结束** → 新结果准备好；
    4. **下个时钟沿** → 状态单元统一更新。
- 这就形成了“看似顺序赋值”的效果。

## 4.3.4 SEQ 阶段的实现
本节会设计实现 SEQ 所需要的控制逻辑块的 HCL 描述。（笔记做完发现一个  HCL 描述都没有(」ﾟﾛﾟ)｣）
![[NoteAboutStudy/attachments/Pasted image 20251001173436.png]]

---
### 取指阶段
![[NoteAboutStudy/attachments/Pasted image 20251001195450.png]]
如图 4-27 所示，取指阶段包括指令内存硬件单元。以 PC 作为第一个字节（字节 0）的地址，然后开始顺序取。

第一个字节被解释成指令字节，（标号为 “Split” 的单元)分为两个 4 位的数。然后，标号为 “icode” 和 “ifun” 的控制逻辑块计算指令和功能码，或者使之等于从内存读出的值，或者当指令地址不合法时（由信号 `imem_error` 指明)，使这些值对应于 `nop` 指令。

根据 icode 的值，可以计算三个一位的信号（用虚线表示）：
- instr_valid：这个字节对应于一个合法的 Y86-64 指令吗？（这个信号用来发现不合法的指令）
- need_regids：这个指令包括一个寄存器指示符字节吗？
- need_valC：这个指令包括一个常数字吗？

(当指令地址越界时会产生的)信号 instr_valid 和 imem_error 在访存阶段被用来产生状态码，用于决定处理器是继续执行还是停机。

从指令内存中读出的剩下的字节是寄存器指示字节和常数字的组合编码。标号为 “Aign” 的硬件单元会处理这些字节，将它们放入寄存器字段和常数字中。

如果 `need_regids=1`：取出第 1 字节，拆分成 `rA` 和 `rB`。否则：`rA = rB = 0xF (RNONE)`，表示“不用寄存器”。

根据信号 `need_regids` 的值，标号为 “Aign” 的单元产生常数字 `valC`。

PC 增加器硬件单元根据当前的 PC 以及两个信号 `need_regids` 和 `need_valC` 的值，产生信号 `valP`。

### 译码和写回阶段
![[NoteAboutStudy/attachments/Pasted image 20251002162635.png]]
图 4-28 给出了 SEQ 中实现译码和写回阶段的逻辑的详细情况。把这两个阶段联系在一起是因为它们都要访问寄存器文件。

寄存器文件有四个端口，它支持同时进行两个读（在端口 A 和 B 上）和两个写（在端口 E 和 M 上）。

每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器 ID，而数据连接是一组 64 根线路，既可以作为寄存器文件的输出字（对读端口来说)，也可以作为它的输人字（对写端口来说）。两个读端口的地址输入为 `srcA` 和 `srcB`，而两个写端口的地址输入为 `dstE` 和 `dstM`。如果某个地址端口上的值为特殊标识符 `0xF(RNONE)`，则表明不需要访问寄存器。

根据指令代码 `icode` 以及寄存器指示值 `rA` 和 `rB`，可能还会根据执行阶段计算出的 `Cnd` 条件信号，图 4-28 底部的四个块产生出四个不同的寄存器文件的寄存器 ID。寄存器 ID `srcA` 表明应该读哪个寄存器以产生 `valA`。所需要的值依赖于指令类型。

### 执行阶段
![[NoteAboutStudy/attachments/Pasted image 20251002164124.png]]
执行阶段包括算术/逻辑单元(ALU)。这个单元根据 `alufun` 信号的设置，对输入 `aluA` 和 `aluB` 执行 ADD、SUBTRACT、AND 或 EXCLUSIVE OR 运算。如图 4-29 所示，这些数据和控制信号是由三个控制块产生的。ALU 的输出就是 `valE` 信号。

ALU 在运算时会产生三个标志位：
  - ZF (zero flag)：结果是否为 0
   - SF (sign flag)：结果是否为负数
 - OF (overflow flag)：是否发生溢出

但是，并不是每条指令都要更新条件码。只有 OPq（算术运算指令，比如 addq、subq、andq、xorq）才会更新条件码。所以需要一个信号 `set_cc`，用来控制条件码寄存器是否被写入。

标号为 “cond” 的硬件单元会根据条件码和功能码来确定是否进行条件分支或者条件数据传送。它产生信号 `cnd`，用于设置条件传送的 `dstE`，也用在条件分支的下个 PC 逻辑中。对于其他指令，取决于指令的功能码和条件码的设置，`Cnd` 信号可以被设置为 1 或者 0。但是控制逻辑会忽略它。

### 访存阶段
![[NoteAboutStudy/attachments/Pasted image 20251002165655.png]]
访存阶段的任务就是读或者写程序数据。如图 4-30 所示，两个控制块产生内存地址和内存输人数据（为写操作）的值。另外两个块产生表明应该执行读操作还是写操作的控制信号。当执行读操作时，数据内存产生值 `valM`。

访存阶段最后的功能是根据取值阶段产生的 `icode`、`imem_error`、`instr_valid` 值以及数据内存产生的 `dmem_error` 信号，从指令执行的结果来计算状态码 `Stat`。

### 更新 PC 阶段
![[NoteAboutStudy/attachments/Pasted image 20251002170020.png]]
如图 4-31，SEQ 的最后一个阶段会产生程序计数器的新值，新的 PC 可能是 `valC`、 `valM` 或 `valP`。

### SEQ 小结
SEQ 把所有指令的执行步骤组织成一个统一的流程，用很少的硬件单元（指令内存、寄存器文件、ALU、数据内存、PC 逻辑等）就能完成所有指令，并且- - 只需要一个时钟来控制顺序。

但是，因为一个时钟周期要覆盖取指、译码、执行、访存、写回、更新 PC 的全过程，所以时钟必须足够“长”，以保证信号能穿过所有阶段，就会导致它速度慢。

同时这种实现方法硬件单元利用率低，因为每个单元只在整个时钟周期的一部分时间内才被使用。

# 4.4 流水线的通用原理
流水线化的一个重要特性就是提高了系统的 **吞吐量(throughput)**，不过它也会轻微地增加单个的 **延迟(latency)**。

- **吞吐量（throughput）**：指单位时间内完成的指令数。流水线大幅提升吞吐量。
- **延迟（latency）**：指单条指令从开始到完成的时间。流水线并没有减少延迟，反而可能更长（因为增加了流水线寄存器和阶段划分）。

---
## 4.4.1 计算流水线
把 **指令的执行步骤划分为不同的流水段（pipeline stage）**。各段之间用 **寄存器（pipeline register）** 隔开，保证时钟同步。一个时钟周期内，每个流水段只处理一小部分工作。

（在书本该节里，计算了非流水线和流水线的时间开销差异）

## 4.4.2 流水线操作的详细说明
在流水线中，把每个指令划分为不同的阶段，在阶段之间放置 **流水线寄存器**：
- 存储前一阶段的结果；
- 隔离不同阶段的信号；
- 保证各阶段能并行独立运行。
这些寄存器在时钟上升沿时 **同时更新**，实现指令的逐级推进。

每条指令的执行顺序依然是 取指 → 译码 → 执行 → 访存 → 写回。但是不同指令并行执行，比如：
- 时钟周期 1：指令 I1 在取指。
- 时钟周期 2：I1 进入译码，同时 I2 在取指。
- 时钟周期 3：I1 执行，I2 译码，I3 取指。
- …以此类推。
当流水线装满后，**每个时钟周期都能完成一条指令**。

同时，减缓时钟不回影响流水线的行为，信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性后果 -- 值可能会来不及通过组合逻辑，因此当始终上升时，寄存器的输入还不是合法的值。

## 4.4.3 流水线的局限性
正如世界上没有完美的事物一样，流水线也不是完全理想的，也有局限性。

---
### 硬件划分不均衡
理想流水线假设每个阶段耗时差不多。但现实里，不同操作的复杂度差异很大。如果强行把它们切成一样长的阶段，时钟周期必须按照最慢的阶段来定，导致其它阶段就是在浪费时间。

### 流水线过度细分
就直觉来说，把流水线的阶段切得越细，每个阶段延迟越小 → 时钟周期可以更短 → 频率更高。

但事实是，每多一级流水线，就要额外加 **流水线寄存器**（pipeline register），它有延迟。

当过度细分时，寄存器延迟 + 控制逻辑开销 **抵消了频率提升带来的收益**。

### 结构冒险（Structural Hazards）
多个阶段可能同时需要用到相同的硬件，如果硬件不能同时支持，就必须加额外逻辑解决，否则会阻塞流水线。

### 数据冒险（Data Hazards）
当前指令需要用到前面某条指令的结果，但这个结果还没准备好。

解决方案：
- **转发（forwarding/bypassing）**：在结果产生后立刻送到需要的阶段，而不是等到写回。
- **暂停（stall）**：如果转发不够，流水线必须停顿几个周期。

### 控制冒险（Control Hazards）
分支和跳转指令在确定下一条 PC 时，需要等到条件计算完成。但是取指阶段可能已经取了错误的指令，造成浪费。
    
解决方案：
- **分支预测**（乐观假设某个方向先取指）-- 详情跳转 4.5.4。
- **延迟分支**（编译器安排无害指令填补空隙）。
- 或者简单粗暴 -> 错误时清空流水线，代价是性能下降。

## 4.4.4 带反馈的流水线系统
对于像 x86-64 或 Y86-64 这样执行机器程序的系统来说，相邻指令之间可能是相关的。
- **数据相关**(data dependency)：由于指令之间的数据依赖；
- **控制相关**(control dependency)：由于指令控制流造成的顺序相关；

在 SEQ 设计中，这些相关都是由反馈路径来解决的，这些反馈将更新了的寄存器值向下传送到寄存器文件，将新的 PC 值向下传送到 PC 寄存器，但是**后续指令必须等待前一条指令的结果产生**，否则不能继续执行。

# 4.5 Y86-64 的流水线实现
在本节，将开始本章的主线任务 -- 设计一个流水线化的 Y86-64 处理器。

首先，对顺序的 SEQ 处理器做一点小的改动，将 PC 的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。到这个时候，这些尝试还不能正确处理各种数据和控制相关。不过，做一些修改，就能实现目标 -- 一个高效的、流水线化的实现Y86-64 ISA 的处理器。

---
## 4.5.1 SEQ+：重新安排计算阶段
作为实现流水线设计的一个过渡步骤，必须稍微调整一下 SEQ 中五个阶段的顺序，使得更新 PC 阶段在一个时钟周期开始时执行，而不是结束时才执行。

只需要对整体硬件结构做最小的改动 -- 对流水线阶段中的活动的时序，就能工作的更好。称之为 “SEQ+”。

通过移动 PC 阶段，使得它的逻辑在时钟周期开始时活动，计算当前指令的 PC 值。图 4-39 给出了 SEQ 和 SEQ+ 在 PC 计算上的不同之处。

![[NoteAboutStudy/attachments/Pasted image 20251003171816.png]]

在 SEQ 中（图 4-39a)，PC 计算发生在时钟周期结束的时候，根据当前时钟周期内计算出的信号值来计算 PC 寄存器的新值。

在 SEQ+ 中（图 4-39b)，通过创建状态寄存器来保存在一条指令执行过程中计算出来的信号。然后，当一个新的时钟周期开始时，这些信号值通过同样的逻辑来计算当前指令的 PC。将这些寄存器标号为 “pIcode” 、“pCnd” 等等，来指明在任一给定的周期，它们保存的是前一个周期中产生的控制信号。

如下一节的图 4-40，给出了 SEQ+ 硬件的一个更为详细的说明，其中的硬件单元和控制块与在 SEQ 中用到的（图4-23）一样，只不过 PC 逻辑从时钟周期结束时活动移到了时钟周期开始时活动。

SEQ 到 SEQ+ 中对状态单元的改变是一种很通用的改进的例子，这种改进称为 **电路重定时(circuit retiming)** 。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。

> [!note]- SEQ+ 中的 PC 在哪？
> 首先，SEQ+ 没有专门的硬件寄存器来保存 PC，而是通过前一条指令留下来的状态信号，动态地计算出当前指令的 PC。
> 
> 表明了，处理器的内部实现 不必严格照搬 ISA（指令集体系结构）里隐含的概念模型。只要最终能保证程序员可见的状态（如 PC、寄存器文件等）是正确的就行，就算内部方法完全不同。

## 4.5.2 插入流水线寄存器
![[NoteAboutStudy/attachments/Pasted image 20251003173601.png]]

在创建一个流水线化的 Y86-64 处理器的最初尝试中，需要在 SEQ+ 的各个阶段之间插入流水线寄存器，并对信号重新排列，得到 PIPE- 处理器，这里的 “-” 代表这个处理器和最终的处理器设计相比，性能要差一点。PIPE- 的抽象结构如图 4-41 所示。

流水线寄存器在该图中用黑色方框表示，每个寄存器包括不同的字段，用白色方框表示。正如多个字段表明的那样，每个流水线寄存器可以存放多个字节和字。同两个顺序处理器的硬件结构（图 4-23 和图 4-40）中的圆角方框不同，这些白色的方框表示实际的硬件组成。

![[NoteAboutStudy/attachments/Pasted image 20251003202141.png]]

可以看到，PIPE- 使用了与顺序设计 SEQ(图 4-40) 几乎一样的硬件单元，但是有流水线寄存器分隔开这些阶段。两个系统中信号的不同之处在 4.5.3 节中讨论。

流水线寄存器按如下方式标号：
- **F**   保存程序计数器的预测值，稍后讨论。 
- **D**  位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。
- **E**   位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。
- **M**  位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。 
- **W**  位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成 `ret` 指令时，它还要向 PC 选择逻辑提供返回地址。

## 4.5.3 对信号进行重新排列和标号
在 **PIPE-（流水线处理器）** 中：同一时刻会有多条指令处于不同阶段，因此同名信号有多个 “版本”，为了区分它们，建立了一个命名机制：
- 存储在流水线寄存器中的信号 -- 在信号名前加上大写的流水线寄存器名字作为前缀；
- 在一个阶段内刚刚计算出来的信号 -- 在信号名前加上小写的阶段名的第一个字母作为前缀。

在 **SEQ+** 里，`dstE`、`dstM`（目的寄存器地址）可以直接连到寄存器文件。但是在 **PIPE-** 里，必须让这些信号 **随着指令在流水线寄存器中前进**，直到写回阶段再送给寄存器文件。这样才能保证 **地址和数据匹配到同一条指令**，避免“数据写回错位”的严重错误。

对信号进行合并和优化，以下为 eg：
`valP`（下一条指令地址）和寄存器文件读出的值，在不同指令里有不同用途：
- `call` → 在访存阶段需要 `valP`。
- 跳转指令 → 在执行阶段可能需要 `valP`。
- 普通指令 → 只需要寄存器读出的值。
所以设计上把这两个合并成一个信号 `valA`，在译码阶段通过 “Select A” 块选择来源，**减少流水线寄存器要保存的状态数量，降低硬件复杂度**。

如图 4-41 所示，流水线寄存器包括一个状态码 `stat` 字段，每条指令从取指阶段起就带有一个 `stat` 状态码（包含正常、异常、结束等）。- 这个状态码会随指令穿过流水线，在访存阶段可能会被更新，最后在写回阶段决定整个处理器的状态。

## 4.5.4 预测下一个 PC
因为流水线设计的目的就是 **每个时钟周期都要发射一条新指令**，也就是所每个时钟周期都有一条新指令进入执行阶段并最终完成。这就要求，必须在取出当前指令后，马上确定下一条指令的位置。

对于大多数指令，下一条 PC 就是当前指令末尾的地址，又或是 `call / jmp`（无条件跳转），下一条 PC 是指令中的常数字 `valC`（立即数的目标地址）。

但是，如果取出的指令是条件分支指令，要到指令通过执行阶段之后，才知道是否要选择分支。类似地，如果取出的指令是 `ret`，要到指令通过访存阶段，才能确定返回地址。

因此，通过预测 PC 的下一个值，在大多数情况下，能达到每个时钟周期发射一条新指令的目的。
- 对大多数指令类型来说，预测是完全可靠的；
- 对条件转移来说，既可以预测选择了分支，那么新 PC 值应为 `valC`，也可以预测没有选择分支，那么新 PC 值应为 `valP`；
无论那种情况，都必须以某种方式来处理预测错误的情况，因为此时已经取出并执行了错误的指令。（将在 4.5.8 讨论这个问题）

猜测分支方向并根据猜测开始取指的技术称为 **分支预测**。实际上所有的处理器都采用了某种形式的此类技术。对于预测是否选择分支的有效策略已经进行了广泛的研究。有的系统花费了大量硬件来解决这个任务。在本书的设计中只使用了简单的策略，即总是预测选择了条件分支，因而预测 PC 的新值为 `valC`。

与条件转移不同，`ret` 指令的返回地址是位于 **栈顶** 的字，其内容可以是任意的。无法提前预测，所以只是简单地暂停处理新指令，直到 `ret` 指令通过写回阶段。（将在 4.5.8 讨论这部分的实现）

> [!tip]- 使用栈的返回地址预测
> 过程调用与返回通常成对出现，因此返回地址预测相对容易。高性能处理器常在取指单元里加入一个 硬件栈（Return Address Stack, RAS）：
> - 调用指令时：将返回地址压入栈中。
> - 返回指令时：从栈顶弹出地址作为预测结果。
> 若预测错误（调用/返回不匹配），需要恢复机制。

PIPE- 的取指阶段，如图 4-41 底部所示，负责预测 PC 的下一个值，以及为取指选择实际的 PC。可以看到，
- 标号为 “Predict PC” 的块会从 PC 增加器计算出的 `valP` 和取出的指令中得到的 `valC` 中进行选择。这个值存放在流水线寄存器 F 中，作为程序计数器的预测值。
- 标号为 “Select PC” 的块类似于 SEQ+ 的 PC 选择阶段中标号为 “PC” 的块（图 4-40）。它从三个值中选择一个作为指令内存的地址：
	- 预测的 PC；
	- 对于到达流水线寄存器 M 的不选择分支的指令来说是 `valP` 的值（存储在寄存器 `M_valA` 中）
	- 当 `ret` 指令到达流水线寄存器 W(存储在 `W_valM`)时的返回地址的值。

## 4.5.5 流水线冒险
 在 4.4.4 节中提到了相关的两种形式：
 - **数据相关** -- 下一条指令会用到这一条指令计算出的结果；
 - **控制相关** -- 一条指令要确定下一条指令的位置；

这些相关可能会导致流水线产生计算错误，称为 **冒险**(hazard)。同相关一样，冒险也可以分为两类：**数据冒险** 和 **控制冒险**。

> [!note]- 各程序状态的冒险类型
> 当一条指令修改了后续指令需要读取的 “程序状态”（program state）时，就可能出现冒险。
> 对于 Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器，将从这些方面讲述可能出现的冒险：
> - **程序寄存器**：寄存器文件的读写是在不同阶段进行的，会出现依赖（数据冒险）；
> - **程序计数器**：更新和读取程序计数器之间的冲突导致了控制冒险。当取指阶段逻辑在取下一条指令之前，正确预测了程序计数器的新值时，就不会产生冒险。预测错误的分支和 `ret` 指令需要特殊的处理；
> - **内存**：
> 	- 数据内存之间的冲突 -- 所有对数据内存的读写都在 **访存阶段**，而流水线保证“在一条读内存指令到达访存阶段前，所有要写内存的指令已经完成访存”。所以，不会出现“同一时刻一个写，一个读”的竞争；
> 	- 指令内存和数据内存之间的冲突 -- **取指阶段**要从内存中取出下一条指令，**访存阶段**可能要往内存中写数据，由于二者访问的是同一个内存空间，如果写入的那一块恰好是将来要取的指令所在的区域，就会冲突。只有包含自我修改代码的程序才会发生这种情况，在这样的程序中，指令写内存的一部分，过后会从中取出指令。有些系统有复杂的机制来检测和避免这种冒险，而有些系统只是简单地强制要求程序不应该使用自我修改代码；
> - **条件码寄存器**：虽然在多条指令间共享，但写入（来自整数操作）发生在执行阶段，而读取（来自条件传送或跳转）发生在后续更晚的阶段（后一条的执行或访存阶段）。因此，当需要读取条件码的指令到达相应阶段时，之前的写操作早已完成，不会出现数据冒险；
> - **状态寄存器**：每条指令都携带自己的状态码，使得异常发生时，能够处理。

### 用暂停来避免数据冒险
**暂停(stalling)** 是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。

让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样就能使处理器避免数据冒险。为保持流水线节奏，**执行阶段插入一个“气泡（bubble）”**—— 即一条什么都不做的伪指令。

“气泡”相当于自动插入的 `nop` 指令，用于占位。  
气泡：
- 不修改寄存器、内存、条件码；
- 让流水线保持时序正常；
- 为后续指令腾出时间等待数据准备好。

暂停技术实现简单，但有明显缺点：
- **性能下降严重**
    每次暂停都让流水线空转几个周期；
- **常见依赖会频繁触发暂停**

### 用转发来避免数据冒险
PIPE- 的设计是在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器 E 作为源操作数。

把还没写回寄存器的结果，**直接从流水线的后面阶段传到前面阶段的输入**，让后续指令能立刻用的技术称为 **数据转发**(data forwarding，或简称 **转发**，有时称为 **旁路**(bypassing) )。

同时，数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。


### 加载/使用数据冒险


### 避免控制冒险



