一个处理器支持的指令和指令的字节级编码称为它的 **指令集体系结构（Instruction-SetArchitecture，ISA）** 。
- 不同的处理器“家族”，都有不同的 ISA。
- 一个程序编译成在一种机器上运行，就不能在另一种机器上运行。
- 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 ISA 级别上都保持着兼容。
- 一些常见的处理器家族（例如 x86-64）中的处理器分别由多个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。

ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一些特殊的机制。

本章首先通过自定义一个简单的指令集 Y86-64 来作为处理器实现的运行示例（受 x86-64 指令集的启发），数据类型、指令、寻址方式更少，编码更简单（不紧凑但容易解码），功能足够强大，可以写一些处理整数的程序。

接下来会提供一些数字硬件设计背景，包括处理器中使用的基本构建块，以及它们是如何连接起来和操作，会介绍 HCL（Hardware Control Language，硬件控制语言） -- 一种描述硬件系统控制部分的简单语言。

作为设计处理器的第一步，先构建一个 **顺序执行的 Y86-64 处理器**：每个时钟周期只执行一条完整的指令，优点：功能正确，逻辑简单，缺点：性能差，因为时钟必须足够慢，保证所有操作在一个周期内完成。

以顺序设计为基础，进行优化，创建一个 **流水线化的处理器（pipelined processor）** ，把一条指令分成 **5 个阶段**（取指、译码、执行、访存、写回），每个阶段由不同硬件完成，每个时钟周期都有新指令进入，使得同一时间有多条指令在不同阶段执行 → 并行度提升，性能大大提高。

但是为了使这个处理器保留 Y86-64 ISA 的顺序行为，就要求处理很多 **冒险或冲突（hazard）** 情况。冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令。

---
# 4.1 Y86-64 指令集体系结构
定义一个指令集体系结构（例如 Y86-64）包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

## 4.1.1 程序员可见的状态

