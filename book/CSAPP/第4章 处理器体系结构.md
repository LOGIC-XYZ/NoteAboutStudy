一个处理器支持的指令和指令的字节级编码称为它的 **指令集体系结构（Instruction-SetArchitecture，ISA）** 。
- 不同的处理器“家族”，都有不同的 ISA。
- 一个程序编译成在一种机器上运行，就不能在另一种机器上运行。
- 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 ISA 级别上都保持着兼容。
- 一些常见的处理器家族（例如 x86-64）中的处理器分别由多个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。

ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一些特殊的机制。

本章首先通过自定义一个简单的指令集 Y86-64 来作为处理器实现的运行示例（受 x86-64 指令集的启发），数据类型、指令、寻址方式更少，编码更简单（不紧凑但容易解码），功能足够强大，可以写一些处理整数的程序。

接下来会提供一些数字硬件设计背景，包括处理器中使用的基本构建块，以及它们是如何连接起来和操作，会介绍 HCL（Hardware Control Language，硬件控制语言） -- 一种描述硬件系统控制部分的简单语言。

作为设计处理器的第一步，先构建一个 **顺序执行的 Y86-64 处理器**：每个时钟周期只执行一条完整的指令，优点：功能正确，逻辑简单，缺点：性能差，因为时钟必须足够慢，保证所有操作在一个周期内完成。

以顺序设计为基础，进行优化，创建一个 **流水线化的处理器（pipelined processor）** ，把一条指令分成 **5 个阶段**（取指、译码、执行、访存、写回），每个阶段由不同硬件完成，每个时钟周期都有新指令进入，使得同一时间有多条指令在不同阶段执行 → 并行度提升，性能大大提高。

但是为了使这个处理器保留 Y86-64 ISA 的顺序行为，就要求处理很多 **冒险或冲突（hazard）** 情况。冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令。

---
# 4.1 Y86-64 指令集体系结构
定义一个指令集体系结构（例如 Y86-64）包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

## 4.1.1 程序员可见的状态
![[../../attachments/Pasted image 20250921192754.png]]
如图 4-1 所示，Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这称为 **程序员可见状态** ，这里的 “程序员” 既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。

在处理器实现中，只要保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方式（顺序执行指令）来表示和组织这个处理器状态。

Y86-64 的状态类似于 x86-64。有 15 个程序寄存器：`%rax`、`%rcx`、`%rdx`、`%rbx`、`%rsp`、`%rbp`、`%rsi`、`%rdi` 和 `%r8` 到 `%r14`。(省略了 x86-64 的寄存器 `%r15` 以简化指令的编码。) 每个程序寄存器存储一个 64 位的字。寄存器 `%rsp` 被入栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。有 3 个一位的条件码： ZF、SF 和 OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。程序计数器 (PC) 存放当前正在执行指令的地址。

**内存** 从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或 **物理地址** ，指明数据实际存在内存中哪个地方。目前只需认为虚拟内存系统向 Y86-64 程序提供了一个单一的字节数组映像。

程序状态的最后一个部分是状态码 `Stat`，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常，例如当一条指令试图去读非法的内存地址时。

## 4.1.2 Y86-64 指令

图 4-2 给出了 Y86-64 ISA 中各个指令的简单描述。这个指令集就是处理器实现的目标。Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，寻址方式较少，操作也较少。因为只有 8 字节数据，所以称之为 “字(word)” 不会有任何歧义。在这个图中，左边是指令的汇编码表示，右边是字节编码。而图 4-3 给出了其中一些指令更详细的内容。汇编代码格式类似于 x86-64 的 ATT 格式。

以下为 Y86-64 的一些细节：
 - x86-64 的 `movq` 指令分成了 4 个不同的指令：`irmovq`、`rrmovq`、`mrmovq` 和 `movq`，分别显式地指明源和目的的格式。源可以是立即数(`i`)、寄存器(`r`)或内存(`m`)。指令名字的第一个字母就表明了源的类型。目的可以是寄存器(`r`)或内存(`m`)。指令名字的第二个字母指明了目的的类型。在决定如何实现数据传送时，显式地指明数据传送的这 4 种类型是很有帮助的。
	 - 两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。在地址计算中，不支持第二变址寄存器( second index register )和任何寄存器值的伸缩( scaling )。
	 - 同 x86-64 一样，不允许从一个内存地址直接传送到另一个内存地址。另外，也不允许将立即数传送到内存。
 - 有4个整数操作指令，如图 4-2 中的 `OPq`。它们是 `addq`、`subq`、`andq` 和 `xorq`。它们只对寄存器数据进行操作，而 x86-64 还允许对内存数据进行这些操作。这些指令会设置 3 个条件码 ZF、SF 和 OF(零、符号和溢出)。
 - 7 个跳转指令（图 4-2 中的 `jXX` )是 `jmp`、`jle`、`jl`、`je`、`jne`、`jge` 和 `jg`。根据分支指令的类型和条件代码的设置来选择分支。分支条件和 x86-64 的一样（见图 3-15  -- 3.6.3）
 - 有 6 个条件传送指令（图 4-2 中的 `cmovXX`): `cmovle`、`cmovl`、`cmove`、`cmovne`、`cmovge` 和 `cmovg`。这些指令的格式与寄存器 - 寄存器传送指令 `rrmovq` 一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。
 - call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。
 - `pushq` 和 `popq` 指令实现了入栈和出栈，如同 x86-64。
 - `halt` 指令停止指令的执行。x86-64 中有一个与之相当的指令 `hlt`。x86-64 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86-64 来说，执行 `halt` 指令会导致处理器停止，并将状态码设置为 HLT (参见 4.1.4 节)

## 4.1.3 指令编码
