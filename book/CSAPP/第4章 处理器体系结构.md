一个处理器支持的指令和指令的字节级编码称为它的 **指令集体系结构（Instruction-SetArchitecture，ISA）** 。
- 不同的处理器“家族”，都有不同的 ISA。
- 一个程序编译成在一种机器上运行，就不能在另一种机器上运行。
- 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 ISA 级别上都保持着兼容。
- 一些常见的处理器家族（例如 x86-64）中的处理器分别由多个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。

ISA 模型看上去应该是顺序指令执行，也就是先取出一条指令，等到它执行完毕，再开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一些特殊的机制。

本章首先通过自定义一个简单的指令集 Y86-64 来作为处理器实现的运行示例（受 x86-64 指令集的启发），数据类型、指令、寻址方式更少，编码更简单（不紧凑但容易解码），功能足够强大，可以写一些处理整数的程序。

接下来会提供一些数字硬件设计背景，包括处理器中使用的基本构建块，以及它们是如何连接起来和操作，会介绍 HCL（Hardware Control Language，硬件控制语言） -- 一种描述硬件系统控制部分的简单语言。

作为设计处理器的第一步，先构建一个 **顺序执行的 Y86-64 处理器**：每个时钟周期只执行一条完整的指令，优点：功能正确，逻辑简单，缺点：性能差，因为时钟必须足够慢，保证所有操作在一个周期内完成。

以顺序设计为基础，进行优化，创建一个 **流水线化的处理器（pipelined processor）** ，把一条指令分成 **5 个阶段**（取指、译码、执行、访存、写回），每个阶段由不同硬件完成，每个时钟周期都有新指令进入，使得同一时间有多条指令在不同阶段执行 → 并行度提升，性能大大提高。

但是为了使这个处理器保留 Y86-64 ISA 的顺序行为，就要求处理很多 **冒险或冲突（hazard）** 情况。冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令。

---
# 4.1 Y86-64 指令集体系结构
定义一个指令集体系结构（例如 Y86-64）包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

---
## 4.1.1 程序员可见的状态
![[02 - study/attachments/Pasted image 20250921192754.png]]
如图 4-1 所示，Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分。这称为 **程序员可见状态** ，这里的 “程序员” 既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。

在处理器实现中，只要保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方式（顺序执行指令）来表示和组织这个处理器状态。

Y86-64 的状态类似于 x86-64。有 15 个程序寄存器：`%rax`、`%rcx`、`%rdx`、`%rbx`、`%rsp`、`%rbp`、`%rsi`、`%rdi` 和 `%r8` 到 `%r14`。(省略了 x86-64 的寄存器 `%r15` 以简化指令的编码。) 每个程序寄存器存储一个 64 位的字。寄存器 `%rsp` 被入栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。有 3 个一位的条件码： ZF、SF 和 OF，它们保存着最近的算术或逻辑指令所造成影响的有关信息。程序计数器 (PC) 存放当前正在执行指令的地址。

**内存** 从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64 程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或 **物理地址** ，指明数据实际存在内存中哪个地方。目前只需认为虚拟内存系统向 Y86-64 程序提供了一个单一的字节数组映像。

程序状态的最后一个部分是状态码 `Stat`，它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常，例如当一条指令试图去读非法的内存地址时。

## 4.1.2 Y86-64 指令
图 4-2 给出了 Y86-64 ISA 中各个指令的简单描述。这个指令集就是处理器实现的目标。Y86-64 指令集基本上是 x86-64 指令集的一个子集。它只包括 8 字节整数操作，寻址方式较少，操作也较少。因为只有 8 字节数据，所以称之为 “字(word)” 不会有任何歧义。在这个图中，左边是指令的汇编码表示，右边是字节编码。而图 4-3 给出了其中一些指令更详细的内容。汇编代码格式类似于 x86-64 的 ATT 格式。

以下为 Y86-64 的一些细节：
 - x86-64 的 `movq` 指令分成了 4 个不同的指令：`irmovq`、`rrmovq`、`mrmovq` 和 `movq`，分别显式地指明源和目的的格式。源可以是立即数(`i`)、寄存器(`r`)或内存(`m`)。指令名字的第一个字母就表明了源的类型。目的可以是寄存器(`r`)或内存(`m`)。指令名字的第二个字母指明了目的的类型。在决定如何实现数据传送时，显式地指明数据传送的这 4 种类型是很有帮助的。
	 - 两个内存传送指令中的内存引用方式是简单的基址和偏移量形式。在地址计算中，不支持第二变址寄存器( second index register )和任何寄存器值的伸缩( scaling )。
	 - 同 x86-64 一样，不允许从一个内存地址直接传送到另一个内存地址。另外，也不允许将立即数传送到内存。
 - 有4个整数操作指令，如图 4-2 中的 `OPq`。它们是 `addq`、`subq`、`andq` 和 `xorq`。它们只对寄存器数据进行操作，而 x86-64 还允许对内存数据进行这些操作。这些指令会设置 3 个条件码 ZF、SF 和 OF(零、符号和溢出)。
 - 7 个跳转指令（图 4-2 中的 `jXX` )是 `jmp`、`jle`、`jl`、`je`、`jne`、`jge` 和 `jg`。根据分支指令的类型和条件代码的设置来选择分支。分支条件和 x86-64 的一样（见图 3-15  -- 3.6.3）
 - 有 6 个条件传送指令（图 4-2 中的 `cmovXX`): `cmovle`、`cmovl`、`cmove`、`cmovne`、`cmovge` 和 `cmovg`。这些指令的格式与寄存器 - 寄存器传送指令 `rrmovq` 一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。
 - call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回。
 - `pushq` 和 `popq` 指令实现了入栈和出栈，如同 x86-64。
 - `halt` 指令停止指令的执行。x86-64 中有一个与之相当的指令 `hlt`。x86-64 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86-64 来说，执行 `halt` 指令会导致处理器停止，并将状态码设置为 HLT (参见 4.1.4 节)
![[02 - study/attachments/Pasted image 20250921193547.png]]

## 4.1.3 指令编码
图 4-2 还给出了指令的字节级编码。每条指令需要 1~10 个字节不等，这取决于需要哪些字段。

每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：高 4 位是 **代码(code)** 部分，低 4 位是 **功能(function)** 部分。如图 4-2 所示，代码值为 `0 ~ 0xB`。功能值只有在一组相关指令共用一个代码时才有用。图 4-3 给出了整数操作、分支和条件传送指令的具体编码。可以观察到， `rrmovq` 与条件传送有同样的指令代码。可以把它看作是一个 “无条件传送” ，就像 `jmp` 指令是无条件跳转一样，它们的功能代码都是 0。

![[02 - study/attachments/Pasted image 20250921201949.png]]

如图 4-4 所示，15 个程序寄存器中每个都有一个相对应的范围在 `0 ~ 0xE` 之间的寄存器标识符( register ID )。Y86-64 中的寄存器编号跟 x86-64 中的相同。程序寄存器存在 CPU 中的一个 **寄存器文件** 中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随机访问存储器。在指令编码中以及硬件设计中，当需要指明不应访问任何寄存器时，就用 ID 值 `0xF` 来表示。

有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加的 **寄存器指示符字节( register specifier byte )**，指定一个或两个寄存器。在图 4-2 中，这些寄存器字段称为 rA 和 rB。从指令的汇编代码表示中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。

没有寄存器操作数的指令，例如分支指令和 `call` 指令，就没有寄存器指示符字节。那些只需要一个寄存器操作数的指令( `irmovq`、`pushq` 和`popq` )将另一个寄存器指示符设为 `0xF`。

![[02 - study/attachments/Pasted image 20250921202236.png]]

有些指令需要一个附加的 4 字节常数字( constant word )。这个字能作为 `irmovq` 的立即数数据，`rmmovq` 和 `mrmovq` 的地址指示符的偏移量，以及分支指令和调用指令的目的地址。

注意，分支指令和调用指令的目的是一个绝对地址，而不像 IA32 中那样使用 PC (程序计数器)相对寻址方式。处理器使用 PC 相对寻址方式，分支指令的编码会更简洁，同时这样也能允许代码从内存的一部分复制到另一部分而不需要更新所有的分支目标地址。因为更关心描述的简单性，所以就使用了绝对寻址方式。

同 IA32 一样，所有整数采用小端法编码。当指令按照反汇编格式书写时，这些字节就以相反的顺序出现。


**指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。**

Y86-64 就具有这个性质，因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，仍然可以很容易地确定指令序列。反过来说，如果不知道一段代码序列的起始位置，就不能准确地确定怎样将序列划分成单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其他一些工具来说，这就带来了问题。

> [!hint]- RISC 和 CISC 指令集
> RISC（精简指令集）
> 特点：
>  - 指令种类少，形式统一（大多是固定长度，比如 32 位）。
>  - 每条指令完成的功能相对简单（如：加法、加载、存储）。
>  - 更多依赖编译器优化，把复杂操作拆成多条简单指令。
>  - 目标：简化硬件译码，提升流水线并行度。
>
> 代表架构 - MIPS、RISC-V、ARM（早期版本）。
> 
> 优点：
>  - 指令格式统一 → 硬件实现简单，容易做高速流水线。
>  - 高性能 → 现代高性能 CPU 内核大多借鉴 RISC 思路。
> ---
> CISC（复杂指令集）
> 特点：
>  - 指令种类多，长度可变。
>  - 每条指令能完成较复杂的操作（例如一条指令就能“从内存取数 + 做乘法 + 存回去”）。
>  - 最初设计目标：提高汇编程序员的开发效率，让代码更紧凑。
>
> 代表架构 - x86、x86-64。
> 
> 优点：
>  - 单条指令能做更多事，机器码更紧凑（节省内存）。
>  - 对编译器不够强大的早期环境友好。

## 4.1.4 Y86-64 异常
对 Y86-64 来说，程序员可见的状态（图 4-1）包括状态码 `Stat`，它描述程序执行的总体状态。

这个代码可能的值如下：
 - 代码值 1，命名为 `AOK`，表示程序执行正常，而其他一些代码则表示发生了某种类型的异常。
 - 代码值 2，命名为 `HLT`，表示处理器执行力一条 `halt` 指令。
 - 代码值 3，命名为 `ADR`，表示处理器试图从一个非法内存地址读或向一个非法内存地址写，可能是当取指令的时候，也可能是当读或者写数据的时候。会限制最大的地址（确切的限定值因实现而异），任何访问超出这个限定值的地址都会引发ADR异常。
 - 代码 4，命名为 `INS`，表示遇到了非法的指令代码。

任何 `AOK` 以外的代码都会使处理器停止。

对于 Y86-64，当遇到这些异常的时候，就只是简单地让处理器停止执行指令。在更完整的设计中，处理器通常会调用一个 **异常处理程序（exception handler）**，这个过程被指定用来处理遇到的某种类型的异常。

## 4.1.5 Y86-64 程序
实践的一节（具体看书）

## 4.1.6 一些 Y86-64 指令的详情
- **大多数 Y86-64 指令都是“直观”的**
    - 就是说它们对程序状态的修改方式跟我们想象的一致，没有额外的歧义。
    - 比如 `addq`, `subq`, `rmmovq`, `mrmovq`, `irmovq`，行为都直接。
        
- **特殊情况：`pushq %rsp` 的歧义**
    - 指令语义：
        `R[rsp] ← R[rsp] - 8 M[R[rsp]] ← R[rA]`
    - 如果 `rA = rsp`，就出现冲突：
        - 是压入旧的 `%rsp` 值，还是压入减 8 后的新值？
    - 两种约定：
        1. 压入原始 `%rsp` 的值
        2. 压入 `R[rsp] - 8` 的值
    - **Y86-64 选择与 x86-64 一致**：采用方案 ② —— 压入减 8 后的值。

# 4.2 逻辑设计和硬件控制语言 HCL
在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压或低电压来表示不同的位值。在当前的技术中，逻辑 1 是用 1.0 伏特左右的高电压表示的，而逻辑 0 是用 0.0 伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。

> [!note]- 现代逻辑设计
> 过去电路设计依赖手工绘制逻辑图，现在普遍使用硬件描述语言（HDL）来以文本方式描述电路结构，常见的有语法类似 C 的 Verilog 和类似 Ada 的 VHDL。最初 HDL 主要用于电路的模拟建模，但自 20 世纪 80 年代逻辑综合工具出现后，人们可以直接从 HDL 生成高效电路，实现了类似于从汇编过渡到高级语言再用编译器生成机器码的转变。本书采用的 HCL 语言仅用于描述微处理器的控制逻辑，虽然功能有限、没有模块化，但控制部分正是设计中最复杂的环节。借助 HCL 转译为 Verilog 并结合硬件单元代码，就能合成可运行的 Y86-64 处理器，从而通过分离、设计和测试控制逻辑，逐步构建出一个完整的微处理器。

---
## 4.2.1 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。
 - **与门**：有 0 为 0，全 1 为 1；
 - **或门**：有 1 为 1，全 0 为 0；
 - **非门**：取反；
 - **与非门**：有 0 为 1，全 1 为 0；
 - **或非门**：有 1 为 0，全 0 为 1；
 - **异或门**：不同为 1；
 - **同或门**：相同为 1；

逻辑门总是活动的(active)。一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。

## 4.2.2 组合电路和 HCL 布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为 **组合电路(combinational circuits)** 。如何构建这些网有几个限制：
 - 每个逻辑门的输人必须连接到下述选项之一：1)一个系统输入（称为主输入），2)某个存储器单元的输出，3)某个逻辑门的输出。
 - 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
 - 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。

HCL 表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应之处。它们都是用布尔操作来对输人进行计算的函数。值得注意的是，这两种表达计算的方法之间有以下区别：
 - 因为组合电路是由一系列的逻辑门组成，它的属性是输出会持续地响应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C 表达式只会在程序执行过程中被遇到时才进行求值。
 - C 的逻辑表达式允许参数是任意整数，0 表示 FALSE ，其他任何值都表示 TRUE。而逻辑门只对位值 0 和 1 进行操作。
 - C 的逻辑表达式有个属性就是它们可能只被部分求值。如果一个 AND 或 OR 操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了。

## 4.2.3 字级的组合电路和 HCL 整数表达式
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

字级的逻辑运算可以看成是：**并行地对每一位进行位级运算**。

HCL里，除了布尔表达式，还支持整数表达式，用来描述字级运算。
- **算术运算**：`+`、`-`（比如做加法器）
- **逻辑运算**：`&`、`|`、`^`（按位与、或、异或）
- **移位运算**：`<<`（左移）、`>>`（右移，逻辑或算术右移）
这些都和 C 语言里的运算符很像。

## 4.2.4 集合关系
在硬件设计里，除了数值计算（加减乘除）之外，还需要判断 **关系**，比如：
- 两个数是否相等？
- 一个数是否小于另一个？
- 一个数是否小于等于另一个？
这些操作在处理器中非常重要，因为 **条件分支**、**比较指令** 都依赖这种结果。

结果 **不是整数**，而是布尔值。

## 4.2.5 存储器和时钟
组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生 **时序电路(sequential circuit)**，也就是有状态并且在这个状态上进行计算的系统，需要引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
 - 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。
 - 随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：
	 1) 处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字；
	 2) 寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器( `%rax~%r14`)。



> [!tip]- “寄存器”
> 在说到硬件和机器级编程时，“寄存器”这个词是两个有细微差别的事情。
>  - 在硬件中，寄存器直接将它的输人和输出线连接到电路的其他部分。
>  - 在机器级编程中，寄存器代表的是 CPU 中为数不多的可寻址的字，这里的地址是寄存器 ID 。这些字通常都存在寄存器文件中，虽然硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。
> 
> 需要避免歧义时，会分别称呼这两类寄存器为“硬件寄存器”和“程序寄存器”。

大多数时候，硬件寄存器都保持在稳定状态（用 x 表示），产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入（用 y 表示），但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输人信号就加载到寄存器中，成为下一个状态 y，直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。Y86-64 处理器会用时钟寄存器保存程序计数器(PC)、条件代码(CC)和程序状态(Stat)。

![[02 - study/attachments/Pasted image 20250927164206.png]]

寄存器文件有两个读端口( A 和 B )，还有一个写端口( W )。这样一个 **多端口** 随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。地址是用图 4-4 中编码表示的寄存器标识符。两个读端口有地址输入 `srcA` 和 `srcB`(“source A”和“source B”的缩写)和数据输出 `valA` 和 `valB` (“value A”和“value B”的缩写)。写端口有地址输入 `dstW` (“destination W”的缩写)，以及数据输入 `valW` (“value W”的缩写)。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，在实现中，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当 `srcA` 或  `srcB` 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应程序寄存器的值就会出现在 `valA` 或 `valB` 上。

向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入 `valW` 上的值会被写入输入 `dstW` 上的寄存器 ID 指示的程序寄存器。当 `dstW` 设为特殊的 ID 值 `0xF` 时，不会写任何程序寄存器。由于寄存器文件既可以读也可以写，如果试图同时读和写同一个寄存器会发生什么？**先看到旧值，后更新成新值**。因为在时钟边沿触发写入前，读端口读到的是旧值。等时钟上升沿到来，寄存器才被更新。

![[02 - study/attachments/Pasted image 20250927164744.png]]

这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。

读操作像组合逻辑，立即根据地址返回数据；写操作则受时钟控制，在时钟沿更新数据。系统通过 `error` 信号来检查地址是否合法。

# 4.3 Y86-64 的顺序实现