到目前为止，在对系统的研究中，都依赖于一个简单的计算机系统模型，CPU 执行指令，而存储器系统为 CPU 存放指令和数据。在简单模型中，存储器系统是一个线性的字节数组，而 CPU 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型，但是它并没有反映现代系统实际工作的方式。

实际上，**存储器系统(memory system)** 是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的小的、快速的 **高速缓存存储器(cache memory)** 作为一部分存储在相对慢速的主存储器(main memory)中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。

存储器层次结构是可行的，这是因为与下一个更低层次的存储设备相比来说，一个编写良好的程序倾向于更频繁地访问某一个层次上的存储设备。所以，下一层的存储设备可以更慢速一点，也因此可以更大，每个比特位更便宜。整体效果是一个大的存储器池，其成本与层次结构底层最便宜的存储设备相当，但是却以接近于层次结构顶部存储设备的高速率向程序提供数据。

同时，存储器的层次结构对应用程序的性能有巨大的影响，因为不同存储位置访问成本差异巨大。
为此，程序员需要理解存储器层次结构，以在编写程序时，使得它们的数据项存储在层次结构中较高的地方，以便 CPU 能更快地访问到。
而这围绕着计算机程序的一个基本属性：**局部性（locality）** -- 具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层次处访问数据项，因此运行得更快。

在本章中，将会讲述基本的存储技术 - SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘 -- 并描述它们是如何被组织成层次结构的。特别地，将主要讲述高速缓存存储器，它是作为 CPU 和主存之间的缓存区域，因为它们对应用程序性能的影响最大。将展示如何分析 C 程序的局部性，并且介绍改进程序中局部性的技术。还将讲述一种描绘某台机器上存储器层次结构的性能的方法，称为 “存储器山（memory mountain）”，它展示出读访问时间是局部性的一个函数。

---
# 6.1 存储技术
计算机技术的成功很大程度上源自于存储技术的巨大进步。

---
## 6.1.1 随机访问存储器
随机访问存储器（Random-Access Memory，RAM）分为两类：静态的和动态的。静态 RAM（SRAM）比动态 RAM（DRAM）更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。

### 1. 静态 RAM
SRAM 将每个位存储在一个 **双稳态的（bistable）** 存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置（configuration）或状态（state）之一。其他任何状态都是不稳定的 -- 如果在不稳定状态，电路会迅速地转移到两个稳定状态中的一个。这样一个存储器单元类似于图 6-1 中画出的倒转的钟摆。
![[NoteAboutStudy/attachments/Pasted image 20251104215528.png]]

由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。

### 2. 动态 RAM
DRAM 将每个位存储为对一个电容的充电。而这个电容非常小，因此 DRAM 存储器可以制造得非常密集 -- 每个单元由一个电容和一个访问晶体管组成。

但是，与 SRAM 不同，DRAM 存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。暴露在光线下会导致电容电压改变。实际上，数码照相机和摄像机中的传感器本质上就是 DRAM 单元的阵列。

图 6-2 总结了 SRAM 和 DRAM 存储器的特性。只要有供电，SRAM 就会保持不变。与 DRAM 不同，它不需要刷新。SRAM 的存取比 DRAM 快。SRAM 对诸如光和电噪声这样的干扰不敏感。代价是 SRAM 单元比 DRAM 单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大。
![[NoteAboutStudy/attachments/Pasted image 20251104220048.png]]

### 3. 传统的 DRAM
DRAM 芯片中的单元（位）被分成 $d$ 个 **超单元（supercell）**，每个超单元都由 $w$ 个 DRAM 单元组成。一个 $d×w$ 的 DRAM 总共存储了 $dw$ 位信息。超单元被组织成一个 $r$ 行 $c$ 列的长方形阵列，这里 $rc=d$。每个超单元有形如 $(i,j)$ 的地址，这里 $i$ 表示行，而 $j$ 表示列。如图 6-3 为例子。

![[NoteAboutStudy/attachments/Pasted image 20251104221149.png]]

> [!tip]- 关于 超单元 的注释
> 存储领域从来没有为 DRAM 的阵列元素确定一个标准的名字。计算机构架师倾向于称之为“单元”，使这个术语具有 DRAM 存储单元之意。电路设计者倾向于称之为“字”，使之具有主存一个字之意。为了避免混淆，本书采用了无歧义的术语“超单元”。

每个 DRAM 芯片被连接到某个称为 **内存控制器（memory controller）** 的电路，这个电路可以一次传送 $w$ 位到每个 DRAM 芯片或一次从每个 DRAM 芯片传出 $w$ 位。为了读出超单元 $(i,j)$ 的内容，内存控制器将行地址 $i$ 发送到 DRAM，然后是列地址 $j$。DRAM 把超单元 $(i,j)$ 的内容发回给控制器作为响应。行地址 $i$ 称为 RAS（Row Access Strobe，行访问选通脉冲）请求。列地址 $j$ 称为CAS（Column Access Strobe，列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引I脚。

![[NoteAboutStudy/attachments/Pasted image 20251104221216.png]]

电路设计者将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。

### 4. 内存模块
DRAM 芯片封装在 **内存模块（memorymodule）** 中，它插到主板的扩展槽上。图 6-5 展示了一个内存模块的基本思想。

![[NoteAboutStudy/attachments/Pasted image 20251104221723.png]]
示例模块用 8 个 64Mbit 的 8M×8 的 DRAM 芯片，总共存储 64MB（兆字节），这 8 个芯片编号为 0~7。每个超单元存储主存的一个字节，而用相应超单元地址为（i，j）的 8 个超单元来表示主存中字节地址 A 处的 64 位字。在图 6-5 的示例中，DRAM 0 存储第一个（低位）字节，DRAM 1 存储下一个字节，依此类推。
要取出内存地址 A 处的一个字，内存控制器将 A 转换成一个超单元地址（i，j），并将它发送到内存模块，然后内存模块再将 i 和 j 广播到每个 DRAM。作为响应，每个 DRAM 输出它的（i，j）超单元的 8 位内容。模块中的电路收集这些输出，并把它们合并成一个 64 位字，再返回给内存控制器。通过将多个内存模块连接到内存控制器，能够聚合成主存。在这种情况中，当控制器收到一个地址 A 时，控制器选择包含 A 的模块 k，将 A 转换成它的（i，j）的形式，并将（i，j）发送到模块 k。

### 5. 增强的 DRAM
有许多种 DRAM 存储器，而生产厂商试图跟上迅速增长的处理器速度，市场上就会定期推出新的种类。每种都是基于传统的 DRAM 单元，并进行一些优化，提高访问基本 DRAM 单元的速度。

|类型|优化机制|说明|
|---|---|---|
|**FPM DRAM**（Fast Page Mode）|行缓冲区连续访问|读同一行多个单元，只需一次 RAS + 多次 CAS，比传统 DRAM 快。|
|**EDO DRAM**（Extended Data Out）|CAS 信号间隔缩短|对 FPM DRAM 的增强，连续访问速度更快。|
|**SDRAM**（Synchronous DRAM）|与控制器同步时钟|使用外部时钟同步读写操作，比异步 DRAM 输出更快。|
|**DDR SDRAM**（Double Data Rate）|双倍数据速率|利用时钟上升沿和下降沿，速度翻倍；进一步有 DDR2、DDR3、DDR4，通过增加预取缓冲提升带宽。|
|**VRAM**（Video RAM）|并行读写|用于图形缓冲区，可同时读（显示屏幕）和写（更新帧缓冲），输出通过移位整个缓冲区。|

### 6. 非易失性存储器
如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是 **易失的（volatile**）。另一方面，**非易失性存储器（nonvolatile memory）** 即使是在关电后，仍然保存着它们的信息。现在有很多种非易失性存储器。由于历史原因，虽然 ROM 中有的类型既可以读也可以写，但是它们整体上都被称为 **只读存储器（Read-OnlyMemory，ROM）**。 ROM 是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制来区分的。
- **PROM（Programmable ROM，可编程ROM）** 只能被编程一次。PROM 的每个存储器单元有一种熔丝（fuse），只能用高电流熔断一次。
- **可擦写可编程 ROM（Erasable Programmable ROM，EPROM）** 有一个透明的石英窗口，允许光到达存储单元。紫外线光照射过窗口，EPROM 单元就被清除为 0。对 EPROM 编程是通过使用一种把 1 写入 EPROM 的特殊设备来完成的。EPROM 能够被擦除和重编程的次数的数量级可以达到 1000 次。
- **电子可擦除 PROM（Electrically Erasable PROM，EEPROM）** 类似于 EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM 能够被编程的次数的数量级可以达到 $10^5$ 次。
- **闪存（flash memory）** 是一类非易失性存储器，基于 EEPROM，它已经成为了一种重要的存储技术。闪存无处不在，为大量的电子设备提供快速而持久的非易失性存储，包括数码相机、手机、音乐播放器、PDA 和笔记本、台式机和服务器计算机系统。在 6.1.3 节中，将会仔细研究一种新型的基于闪存的磁盘驱动器，称为 **固态硬盘（Solid State Disk，SSD）**，它能提供相对于传统旋转磁盘的一种更快速、更强健和更低能耗的选择。

存储在 ROM 设备中的程序通常被称为 **固件（firmware）**。当一个计算机系统通电以后，它会运行存储在 ROM 中的固件。一些系统会在固件中提供了少量基本的输入输出函数。

### 7. 访问主存
数据流通过称为 **总线（bus）** 的共享电子电路在处理器和 DRAM 主存之间来来回回。每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为 **总线事务（bus transaction）**。**读事务（read transaction）** 从主存传送数据到 CPU。**写事务（write trans action）** 从 CPU 传送数据到主存。

总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。

![[NoteAboutStudy/attachments/Pasted image 20251104223407.png]]

如图 6-6 展示了一个示例计算机系统的配置。主要部件是 CPU 芯片、将称为 I/O 桥接器（I/O bridge）的芯片组（其中包括内存控制器），以及组成主存的 DRAM 内存模块。这些部件由一对总线连接起来，其中一条总线是 **系统总线（system bus）**，它连接 CPU 和 I/O 桥接器，另一条总线是 **内存总线（memory bus）**，它连接 I/O 桥接器和主存。I/O 桥接器将系统总线的电子信号翻译成内存总线的电子信号。正如所看到的那样，I/O 桥也将系统总线和内存总线连接到 I/O 总线，像磁盘和图形卡这样的 I/O 设备共享 I/O 总线。不过现在，将注意力集中在内存总线上。

CPU 执行指令需要从主存读取或写入数据。而主存比 CPU 寄存器慢很多，需要通过 **系统总线** 和 **内存总线** 与 CPU 通信。CPU 芯片上的 **总线接口（bus interface）** 负责协调这些读写事务。

#### 读主存（Load）的流程
以指令 `movq A, %rax` 为例：
1. **发起读请求**  
    CPU 将地址 `A` 放到 **系统总线**上，I/O 桥将信号传到 **内存总线**。
2. **主存响应**  
    DRAM 识别地址，从内存单元取出对应的数据字，并写入内存总线。
3. **数据回传 CPU**  
    I/O 桥把内存总线信号转换回系统总线信号，CPU 从总线读取数据并放入寄存器 `%rax`。
```流程总结
CPU → 系统总线 → I/O桥 → 内存总线 → DRAM → 内存总线 → I/O桥 → 系统总线 → CPU
```
![[NoteAboutStudy/attachments/Pasted image 20251104224652.png]]

#### 写主存（Store）的流程
以指令 `movq %rax, A` 为例：
1. **发起写请求**  
    CPU 将目标地址 `A` 放到系统总线上，主存知道地址并等待数据。
2. **传输数据**  
    CPU 将寄存器 `%rax` 的内容写入系统总线。
3. **写入 DRAM**  
    主存从内存总线读取数据，并将其存储到 DRAM 的指定位置。
```流程总结
CPU（数据） → 系统总线 → I/O桥 → 内存总线 → DRAM
```
![[NoteAboutStudy/attachments/Pasted image 20251105152511.png]]

## 6.1.2 磁盘存储
磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于 RAM 的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，比从 DRAM 读慢了 10 万倍，比从 SRAM 读慢了 100 万倍。

### 1. 磁盘构造
磁盘由多个 **盘片(platter)** 堆叠构成。每个盘片有两面或者称为 **表面(surface)** 覆盖着磁性记录材料。盘片中央有一个旋转的 **主轴(spindle)**，它使得盘片以固定的 **旋转速率** 旋转，通常是 5400 ~ 15000 转每分钟(Revolution Per Minute, RPM)。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。

![[NoteAboutStudy/attachments/Pasted image 20251105153512.png]]
图 6-9a 展示了一个典型的磁盘表面的结构。每个表面是由一组称为 **磁道(track)** 的同心圆组成的。每个磁道被划分为一组 **扇区(sector)**。每个扇区包含相等数量的数据位（通常是 512 字节)，这些数据编码在扇区上的磁性材料中。扇区之间由一些 **间隙(gap)** 分隔开，这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。

磁盘是由一个或多个叠放在一起的盘片组成的，它们被封装在一个密封的包装里，如图 6-9b 所示。整个装置通常被称为 **磁盘驱动器(disk drive)**，通常简称为 **磁盘(disk)**。有时，会称磁盘为 **旋转磁盘(rotating disk)**，以使之区别于基于闪存的 **固态硬盘(SSD)**，SSD 是没有移动部分的。

磁盘制造商通常用术语 **柱面(cylinder)** 来描述多个盘片驱动器的构造，这里，柱面是所有的盘片表面上到主轴中心的 距离相等 的磁道的集合。例如，如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面就是 6 个磁道的集合。

### 2. 磁盘容量
一个磁盘上可以记录的最大位数称为它的 **最大容量**，或者简称为 **容量**。磁盘容量是由以下技术因素决定的：
- **记录密度(recording density)(位/英寸)**：磁道一英寸的段中可以放入的位数。
- **磁道密度(track density)(道/英寸)**：从盘片中心出发半径上一英寸的段内可以有的
磁道数。
- **面密度(areal density)(位/平方英寸)**：记录密度与磁道密度的乘积。

因为磁盘制造商不懈地努力以提高面密度从而提高容量，所以面密度每隔几年就会翻倍。
而最初的磁盘，是在面密度很低的时代设计的，将每个磁道分为数目相同的扇区，扇区的数目是由最靠内的磁道能记录的扇区数决定的。为了保持每个磁道有固定的扇区数，越往外的磁道扇区间隙越大。在面密度相对比较低的时候，这种方法还算合理。
不过，随着面密度的提高，扇区之间的间隙（那里没有存储数据位）变得不可接受地大。因此，现代大容量磁盘使用一种称为 **多区记录(multiple zone recording)** 的技术，它将磁盘的柱面（磁道组成的同心圆集合）分成多个 **记录区**，每个记录区包含一批连续的柱面，一个区内部所有磁道扇区数一样（以最里面的磁道所能包含的扇区数决定），不同区之间扇区数可以不同（通常越往外越多）。

下面的公式给出了一个磁盘容量的计算：$$磁盘容量 = \frac{字节数}{扇区} ×\frac{平均扇区数}{磁道}×\frac{磁道数}{表面}×\frac{表面数}{盘片}×\frac{盘片数}{磁盘}$$ 也就是，磁盘容量 = 每扇区字节数 × 每磁道平均扇区数 × 每面磁道数 × 每盘片面数（这个目前只能是 2） × 每磁盘盘片数。

> [!important]+ 关于容量
> 不幸地，像 K(kilo)、M(mega)、G(giga) 和 T(tera) 这样的前缀的含义依赖于上下文。对于与 DRAM 和 SRAM 容量相关的计量单位，通常 K=$2^{10}$，M=$2^{20}$，G=$2^{30}$，而 T=$2^{40}$。对于与像磁盘和网络这样的 I/O 设备容量相关的计量单位，通常 K=$10^3$， M=$10^6$，G=$10^9$，而 T=$10^{12}$。速率和吞吐量常常也使用这些前缀。
> 幸运地，对于通常依赖的不需要复杂计算的估计值，无论哪种假设在实际中相对差别不大。

### 3. 磁盘操作
磁盘通过 **读/写头** 来读写磁性表面的数据。读/写头固定在 **传动臂（Actuator Arm）** 上，通过机械移动定位数据位置。这种将读/写头移动到指定磁道的过程叫 **寻道（Seek）**。当磁盘旋转让相应的位经过读/写头时，读/写头就能读取或写入数据。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，如图 6-10b 所示。读/写头垂直排列，一致行动。在任何时刻，所有的读/写头都位于同一个柱面上。

![[NoteAboutStudy/attachments/Pasted image 20251105205239.png]]

如果盘面上出现一粒细小的灰尘，则会让读/写头停下来，产生所谓的读/写头 **碰撞(head crash)**，为此，磁盘总是密封包装。

磁盘以扇区大小的块来读写数据。对扇区的 **访问时间(access time)** 有三个主要的部分：
- **寻道时间(seek time)**：移动传动臂到所要读取的包含目标扇区的磁道上的时间称为**寻道时间**。该时间依赖于读/写头之前的位置和传动臂移动的速度；
- **旋转时间(rotational latency)**：当读/写头移动到了所要到达的磁道，还需要等待目标扇区的第一个位转到读/写头下，这个时间或者说延迟依赖于读/写头到达时盘面的位置以及磁盘的旋转速度。最坏的情况下，要等待旋转一圈，因此最大旋转时间为磁盘旋转一圈的时间；
- **传送时间(transfer time)**：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了，读/写这个扇区所需的时间称为传送时间，它依赖于磁盘旋转速度和每条磁道的扇区数目；

### 4. 逻辑磁盘块
现代硬盘内部结构复杂（多盘面、多区记录等），但**为了让操作系统简单使用**，磁盘提供了一个**线性逻辑块地址空间**，隐藏实际复杂结构：
> **磁盘 = 从 0 到 B–1 的逻辑块序列（每块 = 1 扇区）**

磁盘内部封装有一个 **磁盘控制器**，负责：
- 维护 **逻辑块号 → 物理位置** 的映射；
- 执行磁盘寻址 和 数据传输；

I/O 操作的流程 - 读操作：
1. OS 发命令：**读逻辑块 N**；
2. 控制器查表：逻辑块 → 物理位置（盘面，磁道，扇区组成的三元组，这个三元组唯一地标识了对应的物理扇区）；
3. 控制器驱动硬件：
    - 移动读头到目标磁道（寻道）
    - 等扇区转到头下（旋转延迟）
4. 将数据读入控制器缓冲区 → 主存；

> [!important]+ 格式化的磁盘容量
> 磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据。格式化包括用标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及在每个区中预留出一组柱面作为备用，如果区中一个或多个柱面在磁盘使用过程中坏掉了，就可以使用这些备用的柱面。因为存在着这些备用的柱面，所以磁盘制造商所说的格式化容量比最大容量要小。

### 连接 I/O 设备
**I/O设备（显卡、显示器、鼠标、键盘、磁盘等）**  通过 **I/O总线**（典型如 **PCI** -- `Intel` 的外围设备互连 Peripheral Component Interconnect 总线）连接 CPU 和主存。

虽然 I/O 总线比 系统总线和内存总线(与 CPU 相关) 慢，但是它可以容纳种类繁多的第三方 I/O 设备。例如，在图 6-11 中，有三种不同类型的设备连接到总线。
![[NoteAboutStudy/attachments/Pasted image 20251105214843.png]]
- **通用串行总线(Universal Serial Bus, USB)** 控制器是一个连接到 USB 总线的设备的中转机构，USB 总线是一个广泛使用的标准，连接各种外围 I/O 设备（USB 3.0 最大带宽：**625MB/s** / USB 3.1 最大带宽：**1250MB/s**）；
- **显卡(GPU)** -- 图形适配器 包含硬件和软件逻辑，负责图形渲染；
- **主机总线适配器** -- 也成为磁盘控制器(HBA) 将一个或多个磁盘连接到 I/O 总线， 使用的是一个特别的 **主机总线接口** 定义的通信协议。两个最常用的接口是 SCSI 和 SATA，SCSI 比 SATA 更快但也更贵，前者可以支持多个磁盘驱动器，后者只能支持一个；
- 其他的设备，例如 **网络适配器** 等，可以通过将适配器插入到主板上空的 **扩展槽** 中，从而连接到 I/O 总线；

> [!tip]- I/O 总线设计进展
> 图 6-11 中的 I/O 总线是一个简单的抽象，使得可以具体描述但又不必和某个系统的细节联系过于紧密。它是基于外围设备互联(Peripheral Component Interconnect, PCI)总线的，在 2010 年前使用非常广泛。PCI 模型中，系统中所有的设备共享总线，一个时刻只能有一台设备访问这些线路。在现代系统中，共享的 PCI 总线已经被 PCEe(PCI express)总线取代，PCIe 是一组高速串行、通过开关连接的点到点链路，类似于将在第 11 章中学习到的开关以太网。PCIe总线，最大吞吐率为 I6GB/s，比 PCI 总线快一个数量级，PCI 总线的最大吞吐率为 533MB/s。除了测量出的 I/O 性能，不同总线设计之间的区别对应用程序来说是不可见的，所以在本书中，只使用简单的共享总线抽象。

### 6. 访问磁盘
如图 6-12 简洁概要的总结了当 CPU 从磁盘读数据时发生的步骤。

![[NoteAboutStudy/attachments/Pasted image 20251105221152.png]]
CPU 通过 **内存映射 I/O(memory-mapped I/O)** 来向 I/O 设备发射命令，如图 6-12a。在使用这个的系统中：
- 地址空间中有一块地址是用于与 I/O 设备通信的，每个这样的地址称为 I/O **端口(port)**，CPU 通过往这些端口写值来发松命令；
- 当一个设备连接到总线时，它与一个或多个端口相关联（或它被映射到一个或多个端口）；

例：磁盘控制器映射到 `0xa0`  
CPU 写 三条指令到该端口：
1. 写 命令字（读操作 / 是否中断）；
2. 写 逻辑块号；
3. 写 目标内存地址；

在磁盘控制器收到来自 CPU 的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要 CPU 的干涉（图 6-12b)。

设备可以自己执行读或者写总线事务而不需要 CPU 干涉的过程，称为 **直接内存访问(Direct Memory Access, DMA)**。这种数据传送称为 **DMA 传送(DMA transfer)**。

> 在此期间，CPU 可以空出时间去干别的，等待只会浪费指令周期。

在 DMA 传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给 CPU 发送一个中断信号来通知 CPU(图 6-12c)。

基本思想是中断会发信号到 CPU 芯片的一个外部引脚上。这会导致 CPU 暂停它当前正在做的工作，跳转到一个操作系统中断例程。这个程序会记录下 I/O 已经完成，然后将控制返回到 CPU 被中断的地方。

## 6.1.3 固态硬盘
固态硬盘(Solid State Disk，SSD) 是一种基于闪存的存储技术（常见 6.1.1），在某种情况下是传统旋转磁盘的强力替代产品。如图 6-13 展示了它。

![[NoteAboutStudy/attachments/Pasted image 20251105222841.png]]

SSD 封装插到 I/O 总线上标准硬盘插槽（通常是 USB 或 SATA)中，行为就和其他硬盘一样，处理来自 CPU 的读写逻辑磁盘块的请求。一个 SSD 封装由一个或多个闪存芯片和 **闪存翻译层(flash translation layer)** 组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。

> 行为像硬盘，本质是闪存阵列 + 地址映射硬件。

并且，读 SSD 比写要快。这由底层闪存基本属性决定的。如图 6-13 所示，一个闪存由 B 个块的序列组成，每个块由 P 页组成。

通常，页的大小是 512 字节~4KB，块是由 32~128 页组成的，块的大小为 16KB~512KB。

数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为 1）。不过，一旦一个块被擦除了，块中每一个页都可以不需要再进行擦除就写一次。在大约进行 $10^5$ 次重复写之后，块就会磨损坏。一旦一个块磨损坏之后，就不能再使用了。

写很慢有两个原因：
1. 擦除块需要相对较长的时间，1s 级的，比访问页所需时间要高一个数量级；
2. 如果写操作试图修改一个包含已经有数据（也就是不是全为 1)的页 p，那么这个块中所有带有用数据的页都必须被复制到一个新（擦除过的）块，然后才能进行对页 p 的写。
制造商已经在闪存翻译层中实现了复杂的逻辑，试图抵消擦写块的高昂代价，最小化内部写的次数，但是随机写的性能不太可能和读一样好。

SSD vs 机械硬盘
1. 优势：
	- **无机械结构 → 超快随机访问**；
	- 低功耗、抗震；
2. 劣势：
	- 会磨损（但有闪存翻译层中的 **平均磨损 wear leveling** 逻辑通过将擦除平均分布在所有块上来最大化每个块的寿命）；
	- **价格更贵**（约 ×30 / 字节）因此常用的容量较小（约 ÷100）；
	- 不过，随着 SSD 变得越来越受欢迎，它的价格下降得非常快，而两者的价格差也在减少；
3. 趋势：
	- 手机/平板/音乐设备 → **完全替代HDD**；
	- 笔记本/桌面/服务器 → 快速普及；

> 未来主流 + HDD长期用于大容量冷存储

## 6.1.4 存储技术趋势
- **不同存储技术存在“性能—成本”的折中**
    - SRAM > DRAM > SSD > 磁盘；
    - 越快 → 越贵；越慢 → 越便宜、容量更大；
        
- **各类存储技术的性能和成本改善速度不同**
    - 有的技术“提速容易”，有的“降价快但变快难”；
    - 总的来说，提升存储密度（从而降低成本）远比缩短访问时间容易得多；

- **DRAM 和磁盘的性能滞后于 CPU 的性能**
	- CPU 提升更快：1985→2010年间，CPU周期时间提高约 **500×**；若计入多核，则达 **2000×**；
	- 虽然 SRAM 的性能滯后于 CPU 的性能，但还是在保持增长；
	- DRAM 与磁盘性能严重滞后
	    → CPU 与主存/磁盘间的速度差距越来越大；
	    → 出现 “存储墙”（Memory Wall） 问题；
	- 2003 年起，多核架构普及，性能不再单纯看“延迟”，而是取决于 **吞吐量**，多个处理器核并发地发请求）；

为此，现代计算机频繁地使用基于 SRAM 的高速缓存(cache)，如 6.4 节所述，来缓解 CPU 与主存的性能差距，之所以有效，是因为程序具有 **局部性（locality）** —— 即数据访问集中在某些范围内，下一节将阐述这一基本属性。

# 6.2 局部性
一个编写良好的计算机程序常常具有良好的 **局部性(locality)**。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为 **局部性原理(principle of locality)**，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。

局部性通常有两种形式：
 - **时间局部性(temporal locality)**：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在之后被多次引用；
 - **空间局部性(spatial locality)**：在一个具有良好空间局部性的程序中，如果一个内存位置被引用过一次，那么程序很可能在之后引用附近的一个内存位置；
**一般而言，有良好局部性的程序比局部性差的程序运行得更快。**

现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性：
 - 在硬件层，局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快速的存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度；
 - 在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近破引用块的高速缓存。类似地，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块；
 - 在应用程序的设计中，Web 浏览器将最近被引用的文档放在本地磁盘上，利用的就是时间局部性。大容量的 Web 服务器将最近被请求的文档放在前端磁盘高速缓存中，这些缓存能满足对这些文档的请求，而不需要服务器的任何干预；

---
## 6.2.1 对程序数据引用的局部性
这一节从三个代码去讲对程序数据引用的局部性，在这之前，还要讲讲步长：

**步长（stride）**：两次连续访问所间隔的元素数量。
- 步长为 1：连续访问 → **顺序引用模式**（最优空间局部性）；
- 步长为 k：隔 k 个元素访问 → 空间局部性随 k 增大而下降；
**步长越大，缓存命中率越低，性能越差。**

### 一维数组求和
```c
int sumvec(int v[], int n) {
    int i, sum = 0;
    for (i = 0; i < n; i++)
        sum += v[i];
    return sum;
}
```
1. 变量 `sum`：
	- 在每次循环迭代都被引用一次，故有好的时间局部性；
	- `sum` 是标量，没有空间局部性；
2. 向量 `v`：
	- 向量 `v` 的元素是被顺序读取的，即顺序访问数组元素，有很好的空间局部性；
	- 因为每个向量元素只被访问一次，因此时间局部性很差；
**整体上局部性良好**（每个访问都至少利用了一种局部性）。

### 二维数组求和（按行访问）
```c
int sumarrayrows(int a[M][N]) {
    int i, j, sum = 0;
    for (i = 0; i < M; i++)
        for (j = 0; j < N; j++)
            sum += a[i][j];
    return sum;
}
```
双重嵌套循环按照 **行优先顺序(row major order)** 读数组的元素。也就是，内层循环读第一行的元素，然后读第二行，依此类推。函数 `sumarrayrows` 具有良好的空间局部性，因为它按照数组被存储的行优先顺序来访问这个数组。其结果是得到一个很好的步长为 1 的引用模式，具有良好的空间局部性。

### 二维数组求和（按列访问）
```c
int sumarraycols(int a[M][N]) {
    int i, j, sum = 0;
    for (j = 0; j < N; j++)
        for (i = 0; i < M; i++)
            sum += a[i][j];
    return sum;
}
```
函数 `sumarraycols` 的空间局部性很差，因为它按照列顺序来扫描数组，而不是按照行顺序。因为 C 数组在内存中是按照行顺序来存放的，结果就得到步长为 N 的引用模式 -- 实际访问间隔 = 一整行的大小。

## 6.2.2 取指令的局部性
程序运行时不仅要 “取数据”，还要不断 “取指令”（从内存中读取要执行的机器代码）。因此，也能够评价一个**程序的执行流**的局部性。

CPU 在执行时，会从内存中取出一条条指令，因此可以评估：
> “程序对指令的引用是否具有时间局部性或空间局部性”。

这对应着两种情况：
1. 时间局部性
	- **定义**：当某段指令被执行后，不久可能会再次执行。
	- **典型来源**：循环（loop）
	    - 例如：`for (i = 0; i < n; i++) sum += v[i];`
	    - 循环体的指令会被**重复多次执行**，具有良好的**时间局部性**；
2. 空间局部性
	- **定义**：当某条指令被取出后，下一条被取出的指令往往在内存中相邻。
	- **典型来源**：顺序执行的代码块
	    - 例如：`sum += v[i]; i++;`
	    - 程序的指令在内存中是顺序存放的，CPU 通常按照顺序执行（除非遇到跳转或函数调用），具有良好的**空间局部性**；

代码访问和数据访问最大的不同是：
>  **程序指令在运行时几乎不会被修改。**

数据在运行时可能被频繁读写（如数组或变量），但是指令在运行时**只读不写**：CPU只需要从内存取出指令，不会去修改这些指令的内容。

因此：**代码的局部性主要体现在 “取指令的模式” 上**（即执行顺序），**不会存在 “写指令” 的时间局部性**。

## 6.2.3 局部性小结
在这一节中，介绍了局部性的基本思想，还给出了量化评价程序中局部性的一些简单原则：
- 重复引用相同变量的程序有良好的时间局部性；
- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好。具有步长为的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差；
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好；

# 6.3 存储器层次结构
