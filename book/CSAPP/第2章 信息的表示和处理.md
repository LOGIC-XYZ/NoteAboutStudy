孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。

比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。

在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。将研究三种最重要的数字表示：
- **无符号(unsigned)编码**基于传统的二进制表示法，表示大于或者等于零的数字。
- **补码(two's-complement)编码**是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
- **浮点数(floating-point)编码**是表示实数的科学记数法的以 2 为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出（overflow）**。

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $+∞$，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。（整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同 -- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的）

---
# 2.1 信息存储
大多数计算机使用 8 位的块，或者字节(byte)，作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。**机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)**。**内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)**，**所有可能地址的集合就称为虚拟地址空间(virtual address space)**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

## 2.1.1 十六进制表示法
一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_{2}$ ~ $11111111_{2}$。如果看成十进制整数，它的值域就是 $0_{10}$ ~ $255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制（简写为“hex”)使用数字 ‘0’~‘9’ 以及字符 ‘A’~‘F’ 来表示16个可能的值。
![[../../attachments/Pasted image 20250826164553.png]]
> [!tip]
> 在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’~‘F' 既可以是大写，也可以是小写。

## 2.1.2 字数据的大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w一1$ ，程序最多访问 $2^w$ 个字节。

由于从 32 位字长机器向 64 位字长机器的迁移，虚拟地址空间也扩展了。

不过大多数 64 位机器也可以运行为 32 位机器编译的程序（这是一种向后兼容）-- 但是为 64 位机器编译的程序只能在 64 位机器上运行。因此，我们将程序称为 ”32 位程序“ 或 ”64 位程序“ 时，区别在于该程序是如何编译的，而不是其运行的机器类型。
![[../../attachments/Pasted image 20250826170304.png]]
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t`和`int64_t`,它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。而程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

## 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

排列表示一个对象的字节有两个通用的规则。考虑一个 $w$ 位的整数，其位表示为$[x_{w-1}, x_{w-2},…,x_{1},x_{0}]$，其中 $x_{w-1}$ 是最高有效位，而 $x_{0}$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},…,x_{w-8}]$，而最低有效字节包含位$[x_{7},x_{6},…,x_{0}]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则一最低有效字节在最前面的方式，称为小端法(little endian)。后一种规则一最高有效字节在最前面的方式，称为大端法(big endian)。
![[../../attachments/Pasted image 20250826192558.png]]
以下为字节顺序重要的三种情况：
1. 对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
2. 第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。例如，当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反。
3. 字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用 *强制类型转换(cast)* 或 *联合(union)* 来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

## 2.1.4 表示字符串
C 语言中字符串被编码为一个以 `null`(其值为 0 )字符**结尾**的**字符数组**。**每个字符**都由某个标准编码来表示，最常见的是 ASCⅡ 字符码。因此，如果我们以参数 “12345” 和 6 (包括终止符)来运行例程 `show_bytes` ，我们得到结果 31 32 33 34 35 00。请注意，十进制数字 `x` 的 ASCⅡ 码正好是 `0x3x` ，而终止字节的十六进制表示为 `0x00`。在使用 ASCⅡ 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

## 2.1.5 表示代码
不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

## 2.1.6 布尔代数简介
二进制值 1 和 0 表示逻辑值 TRUE 或者 FALSE，而运算符 ~、 &、 | 和 ^ 分别表示逻辑运算 NOT、 AND、 OR 和 EXCLUSIVE-OR（即 非、与、或、异或）。

可以将上述 4 个布尔运算扩展到**位向量**的运算，位向量就是固定长度为 $w$、由 0 和 1 组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。

位向量一个很有用的应用就是表示有限集合。布尔运算 | 和 & 分别对应于集合的并和交，而 ~ 对应于集合的补。（学离散的时候就觉得和集合很像）

## 2.1.7 C 语言中的位级运算
C 语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C 语言所使用的：| 就是OR（或），& 就是AND（与），～ 就是NOT（取反），而就是EXCLUSIVE-OR（异或）。这些运算能运用到任何 “整型” 的数据类型上。

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从**一个字**中选出的**位的集合**。（就是用来**选择**或**屏蔽**某些二进制位，子网掩码就是这样的）

## 2.1.8 C 语言中的逻辑运算
C 语言还提供了一组逻辑运算符 `||`、`&&` 和 `!`，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有**非零的参数**都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

## 2.1.9 C 语言中的移位运算
C 语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为$[x_{w-1},x_{w-2}，…，x_{0}]$的操作数 $x$，C 表达式 `x<<k` 会生成一个值，其位表示为$[x_{w-k-1}，x_{w-k-2}，…，x_{0}，0，…，0]$。也就是说，$x$ 向左移动 $k$ 位，丢弃最高的 $k$ 位，并在**右端补 $k$ 个 $0$**。移位量应该是一个 $0$ ～ $w-1$ 之间的值。移位运算是从左至右可结合的，所以 `x<<j<<k` 等价于 `(x<<j)<<k`。

有一个相应的右移运算 `x>>k`，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：逻辑右移和算术右移。**逻辑右移在左端补 $k$ 个 $0$**，得到的结果是$[0，…，0，x_{w-1}，x_{w-2}，…，x_{k}]$。**算术右移是在左端补 $k$ 个最高有效位的值**，得到的结果是$[x_{w-1}，…，x_{w-1}，x_{w-1}，x_{w-2}，…，x_{k}]$。这种做法看上去可能有点奇特，但是它对有符号整数数据的运算非常有用。

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移 -- 算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对**有符号数使用算术右移**，且许多程序员也都假设机器会使用这种右移。另一方面，**对于无符号数，右移必须是逻辑的**。

> [!tip]
> 与 C 相比，Java 对于如何进行右移有明确的定义。表达是 `x>>k` 会将 x 算术右移 k 个位置，而 `x>>>k` 会对 x 做逻辑右移。

# 2.2 整数表示
将描述用位来编码整数的两种不同的方式：一种只能表示非负数，而一种能够表示负数、零和正数。

如图为引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。
![[../../attachments/Pasted image 20250827195250.png]]

## 2.2.1 整数数据类型
![[../../attachments/Pasted image 20250827195714.png]]
![[../../attachments/Pasted image 20250827195810.png]]
> [!important]
> 如上图，负数与整数的取值范围是不对称的 -- 负数的范围比整数的范围大 1

## 2.2.2 无符号数的编码
讲述了无符号数编码的定义以及说明了无符号数编码的唯一性（让我有点不知道怎么做笔记，满脑子只有 8421 (〃・・)σ(・・〃) ）

假设有一个整数数据类型有 $w$ 位。可以将位向量写成 $\vec{x}$，表示整个向量，或者写成 $[x_{w-1},x_{w-2},…,x_{0}]$，表示向量中的每一位。把 $\vec{x}$ 看做一个二进制表示的数，就获得了它的无符号表示。在这个编码中，每个位 $x_i$ 都取值为 0 或 1，后一种曲子意味着数值 $2^i$ 应该为数字值的一部分。

> 定义 -- 对向量 $\vec{x} = [x_{w-1},x_{w-2},…,x_{0}]$: $$B2U_{w}(\vec{x})\dot{=}\sum_{i=0}^{w-1} x_{i}2^i$$

示例如图：
![[../../attachments/Pasted image 20250827201252.png]]

## 2.2.3 补码编码
除了整数，还需要表示负数值。最常见的有符号数的计算机表示方式就是**补码（two's-complement）**。在这个定义中，将字的最高位解释为负权（negative weight）-- 符号位。符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负。

> 定义 -- 对向量 $\vec{x} = [x_{w-1},x_{w-2},…,x_{0}]$: $$B2T_{w}(\vec{x})\dot{=}-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2} x_{i}2^i$$

示例如图：
![[../../attachments/Pasted image 20250827203949.png]]
补码编码也具有唯一性。

图 2-14 展示了针对不同字长，几个重要数字的位模式和数值。前三个给出的是可表示的整数的范围，用 $UMax_w$、$TMin_w$ 和 $TMax_w$ 来表示。
![[../../attachments/Pasted image 20250827204450.png]]
关于这些，有两点需要注意：
1. 补码的范围是不对称的：$|TMin|=|TMax|+1$，也就是说，$TMin$ 没有与之对应的正数。这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所以会有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示负数，而另一半(符号位设置为 0 的数)表示非负数。因为 0 是非负数，也就意味着能表示的整数比负数少一个；
2. 最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图 2-14 也给出了常数 -1 和 0 的表示。注意 -1 和 $UMax$ 有同样的位表示 -- 一个全 1 的串。数值 0 在两种表示方式中都是全 0 的串。

C 库中的文件 `<limits.h>` 定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。比如，它定义了常量 `INT_MAX`、`INT_MIN` 和 `UINT_MAX`，它们描述了有符号和无符号整数的范围。对于一个补码的机器，数据类型 `int` 有 $w$ 位，这些常量就对应于 $TMax_w$、$TMin_x$ 和 $UMax_w$ 的值。
![[../../attachments/Pasted image 20250827205418.png]]
![[../../attachments/Pasted image 20250827205437.png]]

## 2.2.4 有符号数和无符号数之间的转换
C 语言允许在各种不同的数字数据类型之间做强制类型转换。

从数学的角度来说，可以想象到几种不同的规则。很明显，对于在两种形式中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到 0。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到 $TMax$。不过，对于大多数 C 语言的实现来说，对这个问题的回答都是从位级角度来看的，而不是数的角度。

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

定义函数 $U2B_w$ 和 $T2B_w$，它们将数值映射为无符号数和补码形式的位表示。也就是说，给定 $0≤x≤UMax_w$ 范围内的一个整数 $x$，函数 $U2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位无符号表示。相似地，当 $x$ 满足 $TMin_w≤x≤TMax_w$，函数 $T2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位补码表示。

将函数 $T2U_w$ 定义为 $T2U_w(x)\dot{=}B2U_w(T2B_w(x))$。这个函数的输人是一个 $TMin_w$ ~ $TMax_w$ 的数，结果得到一个 $0$ ~ $UMax_w$ 的值，这里两个数有相同的位模式，除了参数是无符号的，而结果是以补码表示的。类似地，对于 $0$ ~ $UMax_w$ 之间的值 $x$，定义函数 $U2T_w$ 为$U2T_w(x)\dot{=}B2T_w(U2B_w(x))$。生成一个数的无符号表示和 $x$ 的补码表示相同。

> **补码转换为无符号数**，对满足 $TMin_w≤x≤TMax_w$ 的 $x$ 有：$$B2U_w(T2B_w(x))=T2U_w(x)=x+x
> _{w-1}2^w$$

示例如图：
![[../../attachments/Pasted image 20250827212054.png]]

> **无符号数转换为补码**，对满足 $0≤u≤UMax_w$ 的 $u$ 有：$$U2T_w(x)=-u_{w-1}2^w+u$$ 

以下是两个函数的转换行为图：
![[../../attachments/Pasted image 20250827212611.png]]

总结，考虑无符号与补码表示之间互相转换的结果。对于在范围 $0≤x≤ TMax_w$ 之内的值 $x$ 而言，我们得到 $T2U_w(x)=x$ 和 $U2T_w(x)=x$。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去 $2^w$。

## 2.2.5 C 语言中的有符号数与无符号数
![[../../attachments/Pasted image 20250828211032.png]]
在这两种情况下，`printf` 首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。

## 2.2.6 扩展一个数字的位表示
要将一个无符号数转换为一个更大的数据类型门只要简单地在表示的开头添加0。这种运算被称为**零扩展（zero extension）**。

> 定义 -- **无符号数的零扩展**：定义宽度为 $w$ 的位向量 $\vec{u}=[u_{w-1},u_{w-2},…,u_{0}]$ 和宽度为 $w'$ 的位向量 $\vec{u}'=[0,…,0,u_{w-1},u_{w-2},…,u_{0}]$，其中 $w'>w$。则 $B2U_w(\vec{u})=B2U_{w'}(\vec{u}')$。


要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展（sign extension）**，在表示中添加最高有效位的值。

> 定义 -- **补码数的符号扩展**：定义宽度为 $w$ 的位向量 $\vec{x}=[x_{w-1},x_{w-2},…,x_{0}]$ 和宽度为 $w'$ 的位向量 $\vec{x}'=[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_{0}]$，其中 $w'>w$。则 $B2U_w(\vec{x})=B2U_{w'}(\vec{x}')$。
![[../../attachments/Pasted image 20250828214711.png]]

## 2.2.7 截断数字
当将一个 $w$ 位的数 $\vec{x}=[x_{w-1},x_{w-2},…,x_0]$ 截断为一个 $k$ 位的数字时，丢弃高 $w-k$ 位，得到一个位向量  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$，截断一个数字可能会改变它的值 -- 溢出的一种形式。

> 定义 -- **截断无符号数**：令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},…,x_0]$，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果 -  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$。令 $x=B2U_w(\vec{x})$，$x'=B2U_k(\vec{x}')$。则 $x'=x mod 2^k$。

> 定义 -- **截断补码数值**：令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},…,x_0]$，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果 -  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$。令 $x=B2U_w(\vec{x})$，$x'=B2T_k(\vec{x}')$。则 $x'=U2T_k(x mod 2^k)$。

截断补码数值与截断无符号数的区别在于前者还需要将无符号数转为补码。

## 2.2.8 关于有符号数与无符号数的建议
因为隐式类型转换可能导致错误或者漏洞，所以默认使用有符号数，仅在有需要时使用无符号数。

# 2.3 整数运算
## 2.3.1 无符号加法
考虑两个非负整数 $x$ 和 $y$，满足 $0 \leq x$，$y<2^w$，每个数都能表示为 $w$ 位无符号数字。然而，如果计算它们的和，就有一个可能的范围 $0 \leq x+y \leq w^{w+1}-2$。表示这个和可能需要 $w+1$ 位。
![[../../attachments/Pasted image 20250829154737.png]]

定义运算 $+_{w}^{u}$，其中 $0 \leq x$，$y<2^w$，该操作是把整数和 $x+y$ 截断为 $w$  位得到的结果，再把这个结果看做是一个无符号数。这个过程可以被视为一种形式的模运算，对  $x+y$ 的位级表示，丢弃任何权重大于 $2^{w-1}$ 的位就可以计算出和模 $2^w$ 的结果一致的数。

> 定义 -- **无符号数加法**：对满足 $0 \leq x$，$y<2^w$ 的 $x$ 和 $y$ 有 - $$
x+_{w}^uy=
\begin{cases}
 x+y, & x+y<2^w & 正常\\
x+y-2^w, & 2^w \leq x+y < 2^{w+1} & 溢出
 \end{cases}$$
![[../../attachments/Pasted image 20250829162131.png]]

> 定义 -- **检测无符号数加法中的溢出**：对在范围 $0 \leq x$，$y \leq UMax_w$ 中的 $x$ 和 $y$，令 $s\dot{=}x+_{w}^uy$。则对计算 $s$，当且仅当 $s<x$ （或者等价地 $s<y$）时，发生了溢出。

模 $2^w$ 下的加法形成了一种数学结构称为**阿贝尔群（Abelian group）**，满足交换律与结合律。它有一个单位元 0，并且每个元素有一个加法逆元（两者相加后，在模 $2^w$ 下结果为 0）.考虑 $w$ 位的无符号数的集合，执行加法运算 $+_{w}^{u}$。对于每个值 $x$，必然有某个值 $-_{w}^ux$ 满足 $-_{w}^ux+_{w}^ux=0$ 。

> 定义 -- **无符号数的取反**：对满足 $0 \leq x<2^w$ 的任意 $x$，其 $w$ 位的无符号逆元 $$
 -_{w}^ux=
 \begin{cases}
 x, & x = 0 \\
 2^w-x, & x > 0
 \end{cases}$$

## 2.3.2 补码加法
给定在范围 $-2^{w-1} \leq x，y \leq 2_{w-1}-1$ 之内的整数值 $x$ 和 $y$，它们的和就在范围 $-2^w \leq x+y \leq 2^w-2$ 之内，要想准确表示，考虑需要 $w+1$ 位。就需要通过将表示截断到 $w$ 位，来避免数据大小的不断扩张。

定义 $x+_{w}^ty$ 为整数和 $x+y$ 被截断为 $w$ 位的结果，并将这个结果看做是补码数。

> 定义 -- **补码加法**：对满足 $-2^{w-1} \leq x，y \leq 2_{w-1}-1$ 的整数 $x$ 和 $y$，有 - $$
 x+_{w}^ty=
 \begin{cases}
 x+y-2^w, & 2^{w-1} \leq x+y & 正溢出\\
 x+y, & -2^w \leq x+y \leq 2^w-2 & 正常\\
 x+y+2^w, & x+y < -2^{w-1} & 负溢出
 \end{cases}
 $$
![[../../attachments/Pasted image 20250829194817.png]]

> 定义 -- **检测补码加法中的溢出**：对满足 $TMin_w \leq x,y \leq TMax_w$ 的 $x$ 和 $y$，令 $s \dot{=} x+_{w}^ty$。当且仅当 $x>0,y>0$，但 $s \leq 0$ 时，计算 $s$ 发生了正溢出。当且仅当 $x<0,y<0$，但 $s \geq 0$ 时，计算 $s$ 发生了负溢出。

## 2.3.3 补码的非
范围在 $TMin_w \leq x \leq TMax_w$ 中的每个数字 $x$ 都有 $+_{w}^t$ 下的加法逆元。

> 定义 -- **补码的非**：对满足 $TMin_w \leq x \leq TMax_w$ 的 $x$，其补码的非 $$-_{w}^tx=
\begin{cases}
TMin_w, & x = TMin_w \\
-x, & x > TMin_w
\end{cases}
$$

## 2.3.4 无符号乘法
范围在 $0≤x,y≤2^w-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x·y$ 的取值范围为 $0$ ~ $(2^w-1)^2=2^{2w}-2^{w+1}+1$ 之间。这可能需要 $2w$ 位来表示。不过，C语言中的无符号乘法被定义为产生 $w$ 位的值，就是 $2w$ 位的整数乘积的低 $w$ 位表示的值（就截断啊）。将这个值表示为 $x*_{w}^uy$。而将一个无符号数截断为 $w$ 位等价于计算该值模 $2^w$。

> 定义 -- **无符号数乘法**：对满足 $0 \leq x,y \leq UMax_w$ 的 $x$ 和 $y$ 有 - $x*_{w}^uy=(x·y)mod 2^w$

## 2.3.5 补码乘法
范围在 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的补码数字，但是它们的乘积 $x·y$ 的取值范围为 $-2^{w-1}·(2^{w-1}-1)=-2^{2w-2}+2^{w-1}$ ~ $-2^{w-1}·-2^{w-1}=-2^{2w-2}$ 之间。若想用补码来表示这个乘积，可能需要 $2w$ 位。然而，C 语言中的有符号乘法是通过将 $2w$ 位的乘积截断为 $w$ 位来实现的。将这个数值表示为 $x*_{w}^ty$。将一个补码数截断为 $w$  位相当于先计算该值模 $2^w$，再把无符号数转换为补码。

> 定义 -- **补码乘法**：对满足 $TMin_w \leq x,y \leq TMax_w$ 的 $x$ 和 $y$ 有 - $x*_{w}^t=U2T_w((x·y)mod2^w)$

对于无符号和补码乘法来说，乘法运算（截断后的乘积）的位级表示都是一样的。

## 2.3.6 乘以常数
以往，在大多数机器上，整数乘法指令相当慢，需要远多于其他整数运算（例如加法、减法、位级运算和移位只需要1个时钟周期，这个，10 个起步）的时钟周期。因此，编译器使用了一项重要的优化，试着用**移位和加法运算的组合**来代替乘以常数因子的乘法。

在该节，先考虑乘以 2 幂的情况，再概括成乘以任意常数。

> 定义 -- **乘以 2 的幂**：设 $x$ 为位模式 $[x_{w-1},x_{w-2},…,x_0]$ 表示的无符号整数。那么，对于任何 $k \geq 0$，都认为 $[x_{w-1},x_{w-2},…,x_0,0,…,0]$ 给出了 $x2^k$ 的 $w+k$ 位的无符号表示，这里右边增加了 $k$ 个 $0$。即 $B2U_{w+k}([x_{w-1},x_{w-2},…,x_0,0,…,0])=x2^k$。

**左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。**

> 定义 -- **与 2 的幂相乘的无符号乘法**：C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$，且 $0≤k<w$，则 C 表达式 $x << k$ 产生数值 $x*_{w}^u2^k$。

由于固定大小的补码算术运算的位级操作与其无符号运算等价，因此可对补码运算的 2 的幂的乘法与左移之间的关系进行类似的表述：

> 定义 -- **与 2 的幂相乘的补码乘法**：C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0≤k<w$，则 C 表达式 $x << k$ 产生数值 $x*_{w}^t2^k$。

> [!tip]
> 注意，无论是无符号运算还是补码运算，乘以 2 的幂都可能会导致溢出。但是结果表明，即使溢出，通过移位得到的结果也还是一样的。

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。
- 例如，假设一个程序包含表达式 $x*14$。利用 $14=2^3+2^2+2^1$，编译器会将乘法重写为 $(x<<3)+(x<<2)+(x<<1)$，将一个乘法替换为三个移位和两个加法。无论 $x$ 是无符号的还是补码，甚至当乘法会导致溢出时，两个计算都会得到一样的结果。（根据整数运算的属性可以证明这一点。）更好的是，编译器还可以利用属性 $14=2^4-2^1$，将乘法重写为 $(x<<4)-(x<<1)$，这时只需要两个移位和一个减法。

考虑一个任务，对于某个常数 K 的表达式 $x*K$ 生成代码。编译器会将 $K$ 的二进制表示表达为一组 $0$ 和 $1$ 交替的序列：$[(0…0)(1…1)(0…0)…(1…1)]$。考虑这组从位位置 $n$ 到位位置 $m$ 的连续的 $1(n \geq m)$ -- 此处位位置是权值的位，则可以用下面两种不同形式中的一种来计算这些位对乘积的影响：
 - 形式A：$(x<<n)+(x<<(n-1))+…+(x<<m)$
 - 形式B：$(x<<(n+1))-(x<<m)$
把每个这样连续的 1 的结果加起来，不用做任何乘法，就能计算出 $x*K$。

当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化。

## 2.3.7 除以 2 的幂
在大多数机器上，整数除法要比整数乘法更慢 -- 需要 30 个或者更多的时钟周期。因此，除以 2 的幂也用移位运算来实现，但是是右移。无符号和补码数分别使用逻辑移位和算术移位来达到目的。

整数除法总是舍入到零，为了准确进行定义，于是引入了取整符：
 - 定义 $\lfloor a \rfloor$ 为唯一的整数 $a'$，使得 $a' \leq a < a'+1$。
 - 定义 $\lceil a \rceil$ 为唯一的整数 $a'$，使得 $a'-1 < a \leq a'$。
对于 $x \geq 0$ 和 $y>0$，结果会是 $\lfloor x/y \rfloor$，而对于 $x<0$ 和 $y>0$，结果会是 $\lceil x/y \rceil$。-- 即向下舍入一个正值，而向上舍入一个负值。

> 定义 -- **除以 2 的幂的无符号除法**：C 变量 $x$ 和 $k$ 有无符号数值 $x$ 和 $k$，且 $0≤k<w$，则 C 表达式 $x>>k$ 产生数值 $\lfloor x/2^k \rfloor$。
- 设 $x$ 为位模式 $[x_{w-1},x_{w-2},…,x_0]$ 表示的无符号整数，而 $k$ 的取值范围为 $0≤k<w$。设 $x'$ 为 $w-k$ 位位表示 $[x_{w-1},x_{w-2},…,x_k]$ 的无符号数，而 $x''$ 为 $k$ 位位表示 $[x_{k-1},…,x_0]$ 的无符号数。由此，可以看到 $x=2^kx'+x''$，而 $0 \leq x'' <2^k$，可得 $\lfloor x/2^k \rfloor = x'$。
 - 对位向量 $[x_{w-1},x_{w-2},…,x_0]$ 逻辑右移 $k$ 位会得到位向量 $[0,…,0,x_{w-1},x_{w-2},…,x_k]$，该位向量有数值 $x'$，而该值可以通过 $x>>k$ 得到。

> 定义 -- **除以 2 的幂的补码除法，向下舍入**：C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0≤k<w$，则当执行算术移位时，C 表达式 $x>>k$ 产生数值 $\lfloor x/2^k \rfloor$。
- 设 $x$ 为位模式 $[x_{w-1},x_{w-2},…,x_0]$ 表示的补码整数，而 $k$ 的取值范围为 $0≤k<w$。设 $x'$ 为 $w-k$ 位位表示 $[x_{w-1},x_{w-2},…,x_k]$ 的补码数，而 $x''$ 为低 $k$ 位 $[x_{k-1},…,x_0]$ 的无符号数。由此，$x=2^kx'+x''$，而 $0 \leq x'' <2^k$，可得 $x' = \lfloor x/2^k \rfloor$。
- 若算术右移位向量 $[x_{w-1},x_{w-2},…,x_0]k$ 位，则得到位向量 $[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_k]$，就是将 $[x_{w-1},x_{w-2},…,x_k]$ 从 $w-k$ 位符号扩展到 $w$ 位，该位向量就是 $\lfloor x/2^k \rfloor$ 的补码表示。

也可以通过在移位之前 “偏置（biasing）”，来修正这种不合适的舍入。

> 定义 -- **除以 2 的幂的补码除法，向上舍入**：C 变量 $x$ 和 $k$ 分别有补码值 $x$ 和无符号数值 $k$，且 $0≤k<w$，则当执行算术移位时，C 表达式 $(x+(1<<k)-1)>>k$ 产生数值 $\lfloor x/2^k \rfloor$。
- 偏置技术利用如下属性：对于整数 $x$ 和 $y(y>0)$，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。
- 假设 $x=qy+r$，其中 $0 \leq r <y$，得到 $(x+y-1)/y=q+(r+y-1)/y$，因此 $\lfloor (x+y-1)/y \rfloor=q+ \lfloor (r+y-1)/y \rfloor$。当 $r=0$ 时，后面一项等于 $0$，而当 $r>0$ 时，等于 $1$。也就是说，通过给 $x$ 增加一个偏量 $y-1$，然后再将除法向下舍入，当 $y$ 整除 $x$ 时，得到 $q$，否则，就得到 $q+1$。
- 则，C 表达式 $x+(1<<k)-1$ 得到数值 $x+2^k-1$。将这个值算术右移 $k$ 位即产生 $\lfloor x/2^k \rfloor$。

可以看到，除以 2 的幂都可以通过逻辑或者算术右移来实现。这也正是为什么大多数机器上提供这两种类型的右移。不幸的是，这种方法不能推广到除以任意常数。同乘法不同，不能用除以 2 的幂的除法来表示除以任意常数 K 的除法。

## 2.3.8 关于整数运算的最后思考
正如所见，计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。而补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，**都有完全一样或者非常类似的位级行为**。
C语言中的某些规定还可能会产生令人意想不到的结果，而这些结果可能是难以察觉或理解的缺陷的源头。特别看到了`unsigned`数据类型，虽然它概念上很简单，但可能导致一些意想不到的行为。这种数据类型会以出乎意料的方式出现，比如，当书写整数常数和当调用库函数时。

# 2.4 浮点数
在本节中，将看到 IEEE 浮点格式中数字是如何表示的。还将探讨**舍入**(rounding)的问题，即当一个数字不能被准确地表示为这种格式时，就必须向上调整或者向下调整。然后，将探讨加法、乘法和关系运算符的数学属性。

## 2.4.1 二进制小数
对于熟悉的十进制表示法 $d_{m}d_{m-1}…d_1d_0.d_{-1}d_{-2}…d_{-m}$，其中每个十进制数 $d_i$ 的取值范围是 0~9。而这个表达描述的数值 d 的定义为 $d = \sum_{i=-n}^{m}10^i×d_i$。数字权的定义与十进制小数点符号（`.`）相关，小数点左边的数字的权是 10 的正幂，得到整数值，而小数点右边的数字的权是 10 的负幂，得到小数值。

同理，对于二进制表示法 $b_{m}b_{m-1}…b_1b_0.b_{-1}b_{-2}…b_{-m-1}b_{-m}$，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，表示的数 b 的定义为 $b=\sum_{i=-m}^{m}2^i×b_i$。点的左边的位的权是 2 的正幂，点右边的位的权是 2 的负幂。

假定仅考虑有限长度的编码，那么十进制表示法不能准确地表达像 $\frac{1}{3}$ 和 $\frac{5}{7}$ 这样的数。类似，小数的二进制表示法只能表示那些能够被写成 $x×2^y$ 的数。其他的值只能够被近似地表示，而增加表示的长度可以提高表示的精度。

## 2.4.2 IEEE 浮点表示
2.4.1 中的定点表示法不能有效地表示非常大的数字，而 IEEE 浮点标准用 $V=(-1)^s×M×2^E$ 的形式来表示一个数：
 - **符号（sign）**：s 决定这数是负数（s=1）还是正数（s=0），而对于数值 0 的符号位解释作为特殊情况处理。
 - **尾数（significand）**：M 是一个二进制小数，它的范围是 $[1,2)$，或者是 $[0.1)$，控制有效数字（精度）。
 - **阶码（exponent）**：E 的作用是对浮点数加权，来控制数量级，这个权重是 2 的 E 次幂（可能是负数）。

IEEE 浮点数将浮点数的位表示划分为三个字段，分别对这些值进行编码：
 - 一个单独的符号位 s 直接编码符号 s。
 - k 位的解码字段 $exp=e_{k-1}…e_1e_0$ 编码阶码 E（带偏置 bias）。
 - n 位小数字段 $frac=f_{n-1}…f_1f_0$ 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0（不包含隐含的 1）。

![[../../attachments/Pasted image 20250830171511.png]]
如图为将这三个字段装进字中最常见的格式。在单精度浮点格式（C 语言中的 `float`）中，s、exp 和 frac 字段分别为 1 位、$k=8$ 位和 $n=32$ 位，得到一个 32 位的表示。在双精度浮点格式（C 语言中的 `double`）中，s、exp 和 frac 字段分别为 1 位、$k=11$ 位和 $n=52$ 位，得到一个 64 位的表示。

给定位表示，根据 exp 的值，被编码的值可以分为三种不同的情况（最后一种情况有两个变种）

如图为对单精度格式的情况
![[../../attachments/Pasted image 20250830171959.png]]

### 情况 1：规格化的值
这是最普遍的情况。当 exp 的位模式既不全为 0（数值 0），也不全为 1（单精度数值为 255，双精度数值为 2047)时，都属于这类情况。

在这种情况中，阶码字段被解释为以 **偏置(biased)** 形式表示的有符号整数。也就是说，阶码的值是$E=e-Bias$，其中 e 是无符号数，其位表示为 $e_{k-1}…e_1e_0$，而 $Bias$ 是一个等于 $2^{k-1}-1$（单精度是 127，双精度是 1023）的偏置值。由此产生指数的取值范围，对于单精度是 $-126$ ~ $+127$，而对于双精度是 $1022$ ~ $+1023$。

小数字段 frac 被解释为描述小数值 f，其中 $0≤f<1$，其二进制表示为 $0.f_{n-1}…f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f$。有时，这种方式也叫做 **隐含的以 1 开头的(implied leading 1)** 表示，因为可以把 M 看成一个二进制表达式为 $1.f_{n-1}f_{n-2}…f_0$ 的数字。既然总是能够调整阶码 E，使得尾数 M 在范围 $1≤ M<2$ 之中（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。既然第一位总是等于 1，那么就不需要显式地表示它。

### 情况 2：非规格化的值
当阶码域为全 0 时，所表示的数是非规格化形式。

在这种情况下，阶码值是 $E=1-Bias$，而尾数的值是 $M=f$，也就是小数字段的值，不包含隐含的开头的 1。

非规格化数有两个用途。首先，它们提供了一种表示数值 0 的方法，因为使用规格化数，必须总是使 $M \geq 1$，因此就不能表示 0。实际上，$+0.0$ 的浮点表示的位模式为全 0：符号位是 0，阶码字段全为 0（表明是一个非规格化值），而小数域也全为 0，这就得到 $M=f=0$。令人奇怪的是，当符号位为 1，而其他域全为 0时，得到值 $0.0$。根据 IEEE 的浮点格式，值 $+0.0$ 和 $-0.0$ 在某些方面被认为是不同的，而在其他方面是相同的。

非规格化数的另外一个功能是表示那些非常接近于 $0.0$ 的数。它们提供了一种属性，称为 **逐渐溢出(gradual underflow)**，其中，可能的数值分布均匀地接近于 $0.0$。

这样可以平滑过渡，而不是直接从最小的规格化数跳到 0。

### 情况 3：特殊值
最后一类数值是当指阶码全为 1 的时候出现的。

当小数域全为 0 时，得到的值表示无穷，当 $s=0$ 时是 $+∞$，或者当 $s=1$ 时是 $-∞$。当把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。

当小数域为非零时，结果值被称为 “NaN”，即 “不是一个数(Not a Number)” 的缩写。一些运算的结果不能是实数或无穷，就会返回这样的 NaN 值，比如当计算 $\sqrt{-1}$ 或 $∞-∞$ 时。在某些应用中，表示未初始化的数据时，它们也很有用处。

## 2.4.3 数字示例
用具体的数字示例来说明上一节内容，但略有补充，详情可见 P79

### 关于非规格化数与规格化数的平滑衔接
- **非规格化数**：$exp=0$，E 被定义为 $1−Bias$，尾数 $M=f$，没有 “隐含的 1”。
- **规格化数**：$exp>0$，$E=e−Bias$，尾数 $M=1+f$，有 “隐含的 1”。

为什么会不同？
如果仍然把非规格化的指数定义为 $−Bias$，那么当从 “最大非规格化数” 切换到 “最小规格化数” 时，会出现一个 **数值跳跃**。

但如果定义为 $E=1-Bias$ ，这样：
- 最大非规格化数 $= (1−2^{−n})×2^{1−Bias}$
- 最小规格化数 $= 1.0×2^{1−Bias}$ 
    → 两者正好紧密相邻，数值上连续。

### 关于浮点数位模式与整数排序兼容
如果把浮点数的 **位模式直接当作无符号整数看**：
- 对于正数，它们的二进制模式按大小顺序排列，和浮点数大小一致。
- 所以可以直接用整数排序算法来排序浮点数，而不用真的做浮点比较。
- 对于负数，因为符号位是 `1` 开头，它们在无符号整数里排到“后面”。并且负数越大（数值上越接近 0），二进制编码反而越大。所以负数部分是“降序”的。

## 2.4.4 舍入
因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此，对于值 $x$，一般想使用一种系统的方法，能够找到 “最接近的” 匹配值 $x'$，它可以用期望的浮点形式表示出来。这就是 **舍入(rounding)** 运算的任务。一个关键问题是在两个可能值的中间确定舍入方向。

IEEE 浮点格式定义了四种不同的舍入方式。默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。

如图举例说明了四种舍入方式，将一个金额数舍入到最接近的整数美元数。==向**偶数舍入(round-to-even)**，也被称为 **向最接近的值舍入(round-to-nearest)**，是默认的方式，试图找到一个最接近的匹配值。==因此，它将 1.40 美元舍入成 1 美元，而将 1.60 美元舍入成 2 美元，因为它们是最接近的整数美元值。唯一的设计决策是确定两个可能结果中间数值的舍入效果。向偶数舍入方式采用的方法是：它将数字向上或者向下舍入，使得结果的**最低有效数字是偶数**（如果刚好在“中间”，选**最后一位为偶数的那个**）。因此，这种方法将 1.5 美元和 2.5 美元都舍入成 2 美元。
![[../../attachments/Pasted image 20250830210047.png]]

其他三种方式产生 **实际值的确界(guaranteed bound)**。这些方法在一些数字应用中是很有用的。
- 向零舍入方式把正数向下舍入，把负数向上舍入，得到值 $\hat{x}$，使得 $|\hat{x}|≤|x|$。
- 向下舍入方式把正数和负数都向下舍入，得到值 $x^-$，使得 $xˉ≤x$。
- 向上舍入方式把正数和负数都向上舍入，得到值 $x^+$，满足 $x≤x^+$。

为什么“就近舍入，偶数优先”是默认？
- 如果只做“普通的四舍五入”，在某些情况下会有偏差累积。
    - 比如一堆 0.5 累加，结果会比真实值偏大。
- 偶数优先能让 “+0.5 的情况” 平均分配到上下两个数，避免了系统性偏差。

## 2.4.5 浮点运算
IEEE 标准指定了一个简单的规则，来确定诸如加法和乘法这样的算术运算的结果把浮点值 x 和 y 看成实数，而某个运算 ⊙ 定义在实数上，计算将产生 $Round(x⊙y)$，这是对实际运算的精确结果进行舍入后的结果。

在实际中，浮点单元的设计者使用一些聪明的小技巧来避免执行这种精确的计算，因为计算只要精确到能够保证得到一个正确的舍入结果就可以了。当参数中有一个是特殊值（如 $-0$、$-∞$ 或 `NaN`)时，IEEE 标准定义了一些使之更合理的规则。例如，定义 $1/-0$ 将产生 $-∞$，而定义 $1/+0$ 会产生 $+∞$。

IEEE 标准中指定浮点运算行为方法的一个优势在于，它可以独立于任何具体的硬件或者软件实现。因此，我们可以检查它的抽象数学属性，而不必考虑它实际上是如何实现的。

因为舍入的存在，结合律和交换律可能失效，而交换律一般成立。

另一方面，浮点加法满足了单调性属性：如果 $a≥b$，那么对于任何 $a$、$b$ 以及 $x$ 的值，除了 `NaN`，都有 $x+a≥x+b$。无符号或补码加法不具有这个实数（和整数）加法的属性。

而对于任何 $a$、$b$ 和 $c$，并且 $a$、$b$ 和 $c$ 都不等于 `NaN`，浮点乘法满足下列单调性：$$a≥b且c≥0→a*{}^fc≥b*{}^fc$$ $$a≥b且c≤0→a*{}^fc≤b*{}^fc$$此外，只要 $a≠NaN$，就有 $a*{}^fa≥0$。无符号或补码的乘法也没有这些单调性属性。

## 2.4.6 C 语言中的浮点数
所有的 C 语言版本提供了两种不同的浮点数据类型：`float` 和 `doub1e`。在支持 IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。另外，这类机器使用**向偶数舍入的舍入方式**。不幸的是，因为 C 语言标准不要求机器使用 IEEE 浮点，所以没有标准的方法来改变舍入方式或者得到诸如 $-0$、$+∞$、$-∞$ 或者 `NaN` 之类的特殊值。大多数系统提供 `include(',h')` 文件和读取这些特征的过程库，但是细节随系统不同而不同。

当在 `int`、`f1oat` 和 `double` 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设 `int` 是 32 位的）：
- 从 `int` 转换成 `float`，数字不会溢出，但是可能被舍入。
- 从 $int$ 或 $float$ 转换成 $double$，因为 $double$ 有更大的范围（也就是可表示值的范围)，也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从 $double$ 转换成 $float$，因为范围要小一些，所以值可能溢出成 $+∞$ 或 $-∞$。另外，由于精确度较小，它还可能被舍入。
- 从 `float` 或者 `double` 转换成 `int`，值将会向零舍入。例如 $1.999$ 将被转换成 1，而 $-1.999$ 将被转换成 -1。进一步来说，值可能会溢出。C 语言标准没有对这种情况指定固定的结果。与 Intel 兼容的微处理器指定位模式 $[10…00]$ (字长为 $w$ 时的 $TMin_w$ )为 **整数不确定(integer indefinite)** 值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式 `(int)+1e10` 会得到 $-21483648$，即从一个正值变成了一个负值。


