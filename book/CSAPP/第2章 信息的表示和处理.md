孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。
比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。
在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。将研究三种最重要的数字表示：**无符号(unsigned)编码**基于传统的二进制表示法，表示大于或者等于零的数字。**补码(two's-complement)编码**是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。**浮点数(floating-point)编码**是表示实数的科学记数法的以 2 为基数的版本。
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出（overflow）**。
另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $+∞$，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。（整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同 -- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的）

---
# 2.1 信息存储
大多数计算机使用 8 位的块，或者字节(byte)，作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。**机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)**。**内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)**，**所有可能地址的集合就称为虚拟地址空间(virtual address space)**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
## 2.1.1 十六进制表示法
一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_{2}$ ~ $11111111_{2}$。如果看成十进制整数，它的值域就是 $0_{10}$ ~ $255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制（简写为“hex”)使用数字 ‘0’~‘9’ 以及字符 ‘A’~‘F’ 来表示16个可能的值。![[../../attachments/Pasted image 20250826164553.png]]
在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’~‘F' 既可以是大写，也可以是小写。

## 2.1.2 字数据的大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w一1$ ，程序最多访问 $2^w$ 个字节。
由于从 32 位字长机器向 64 位字长机器的迁移，虚拟地址空间也扩展了。
不过大多数 64 位机器也可以运行为 32 位机器编译的程序（这是一种向后兼容）-- 但是为 64 位机器编译的程序只能在 64 位机器上运行。因此，我们将程序称为 ”32 位程序“ 或 ”64 位程序“ 时，区别在于该程序是如何编译的，而不是其运行的机器类型。
![[../../attachments/Pasted image 20250826170304.png]]
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t`和`int64_t`,它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。而程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

## 2.1.3 寻址和字节顺序
