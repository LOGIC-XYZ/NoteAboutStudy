孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。
比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。
在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。将研究三种最重要的数字表示：**无符号(unsigned)编码**基于传统的二进制表示法，表示大于或者等于零的数字。**补码(two's-complement)编码**是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。**浮点数(floating-point)编码**是表示实数的科学记数法的以 2 为基数的版本。
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出（overflow）**。
另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $+∞$，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。（整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同 -- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的）

---
# 2.1 信息存储
大多数计算机使用 8 位的块，或者字节(byte)，作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。**机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)**。**内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)**，**所有可能地址的集合就称为虚拟地址空间(virtual address space)**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

## 2.1.1 十六进制表示法
一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_{2}$ ~ $11111111_{2}$。如果看成十进制整数，它的值域就是 $0_{10}$ ~ $255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制（简写为“hex”)使用数字 ‘0’~‘9’ 以及字符 ‘A’~‘F’ 来表示16个可能的值。
![[../../attachments/Pasted image 20250826164553.png]]
在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’~‘F' 既可以是大写，也可以是小写。

## 2.1.2 字数据的大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w一1$ ，程序最多访问 $2^w$ 个字节。
由于从 32 位字长机器向 64 位字长机器的迁移，虚拟地址空间也扩展了。
不过大多数 64 位机器也可以运行为 32 位机器编译的程序（这是一种向后兼容）-- 但是为 64 位机器编译的程序只能在 64 位机器上运行。因此，我们将程序称为 ”32 位程序“ 或 ”64 位程序“ 时，区别在于该程序是如何编译的，而不是其运行的机器类型。
![[../../attachments/Pasted image 20250826170304.png]]
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t`和`int64_t`,它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。而程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

## 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
排列表示一个对象的字节有两个通用的规则。考虑一个 $w$ 位的整数，其位表示为$[x_{w-1}, x_{w-2},…,x_{1},x_{0}]$，其中 $x_{w-1}$ 是最高有效位，而 $x_{0}$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},…,x_{w-8}]$，而最低有效字节包含位$[x_{7},x_{6},…,x_{0}]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则一最低有效字节在最前面的方式，称为小端法(little endian)。后一种规则一最高有效字节在最前面的方式，称为大端法(big endian)。
![[../../attachments/Pasted image 20250826192558.png]]
以下为字节顺序重要的三种情况：
1. 对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
2. 第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。例如，当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反。
3. 字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用 *强制类型转换(cast)* 或 *联合(union)* 来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

## 2.1.4 表示字符串
C 语言中字符串被编码为一个以 `null`(其值为 0 )字符**结尾**的**字符数组**。**每个字符**都由某个标准编码来表示，最常见的是 ASCⅡ 字符码。因此，如果我们以参数 “12345” 和 6 (包括终止符)来运行例程 `show_bytes` ，我们得到结果 31 32 33 34 35 00。请注意，十进制数字 `x` 的 ASCⅡ 码正好是 `0x3x` ，而终止字节的十六进制表示为 `0x00`。在使用 ASCⅡ 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

## 2.1.5 表示代码
不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

## 2.1.6 布尔代数简介
二进制值 1 和 0 表示逻辑值 TRUE 或者 FALSE，而运算符 ~、 &、 | 和 ^ 分别表示逻辑运算 NOT、 AND、 OR 和 EXCLUSIVE-OR（即 非、与、或、异或）。
可以将上述 4 个布尔运算扩展到**位向量**的运算，位向量就是固定长度为 $w$、由 0 和 1 组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。
位向量一个很有用的应用就是表示有限集合。布尔运算 | 和 & 分别对应于集合的并和交，而 ~ 对应于集合的补。（学离散的时候就觉得和集合很像）

## 2.1.7 C 语言中的位级运算
C 语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C 语言所使用的：| 就是OR（或），& 就是AND（与），～ 就是NOT（取反），而就是EXCLUSIVE-OR（异或）。这些运算能运用到任何 “整型” 的数据类型上。
位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从**一个字**中选出的**位的集合**。（就是用来**选择**或**屏蔽**某些二进制位，子网掩码就是这样的）

## 2.1.8 C 语言中的逻辑运算
C 语言还提供了一组逻辑运算符 `||`、`&&` 和 `!`，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有**非零的参数**都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

## 2.1.9 C 语言中的移位运算
C 语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为$[x_{w-1},x_{w-2}，…，x_{0}]$的操作数 $x$，C 表达式 `x<<k` 会生成一个值，其位表示为$[x_{w-k-1}，x_{w-k-2}，…，x_{0}，0，…，0]$。也就是说，$x$ 向左移动 $k$ 位，丢弃最高的 $k$ 位，并在**右端补 $k$ 个 $0$**。移位量应该是一个 $0$ ～ $w-1$ 之间的值。移位运算是从左至右可结合的，所以 `x<<j<<k` 等价于 `(x<<j)<<k`。
有一个相应的右移运算 `x>>k`，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：逻辑右移和算术右移。**逻辑右移在左端补 $k$ 个 $0$**，得到的结果是$[0，…，0，x_{w-1}，x_{w-2}，…，x_{k}]$。**算术右移是在左端补 $k$ 个最高有效位的值**，得到的结果是$[x_{w-1}，…，x_{w-1}，x_{w-1}，x_{w-2}，…，x_{k}]$。这种做法看上去可能有点奇特，但是它对有符号整数数据的运算非常有用。
C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移 -- 算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对**有符号数使用算术右移**，且许多程序员也都假设机器会使用这种右移。另一方面，**对于无符号数，右移必须是逻辑的**。
与 C 相比，Java 对于如何进行右移有明确的定义。表达是 `x>>k` 会将 x 算术右移 k 个位置，而 `x>>>k` 会对 x 做逻辑右移。

# 2.2 整数表示
将描述用位来编码整数的两种不同的方式：一种只能表示非负数，而一种能够表示负数、零和正数。
如图为引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。
![[../../attachments/Pasted image 20250827195250.png]]

## 2.2.1 整数数据类型
![[../../attachments/Pasted image 20250827195714.png]]
![[../../attachments/Pasted image 20250827195810.png]]
如上图，负数与整数的取值范围是不对称的 -- 负数的范围比整数的范围大 1

## 2.2.2 无符号数的编码
讲述了无符号数编码的定义以及说明了无符号数编码的唯一性（让我有点不知道怎么做笔记，满脑子只有 8421 (〃・・)σ(・・〃) ）
### 定义
对向量 $\vec{x} = [x_{w-1},x_{w-2},…,x_{0}]$: $$B2U_{w}(\vec{x})\dot{=}$$
![[../../attachments/Pasted image 20250827201252.png]]

## 2.2.3 补码编码
除了整数，还需要表示负数值。最常见的有符号数的计算机表示方式就是**补码（two's-complement）**。在这个定义中，将字的最高位解释为负权（negative weight）-- 符号位