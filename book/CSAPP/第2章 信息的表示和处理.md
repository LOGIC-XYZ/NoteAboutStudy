孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。
比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。
在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。将研究三种最重要的数字表示：**无符号(unsigned)编码**基于传统的二进制表示法，表示大于或者等于零的数字。**补码(two's-complement)编码**是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。**浮点数(floating-point)编码**是表示实数的科学记数法的以 2 为基数的版本。
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出（overflow）**。
另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $+∞$，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。（整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同 -- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的）

---
# 2.1 信息存储
大多数计算机使用 8 位的块，或者字节(byte)，作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。**机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)**。**内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)**，**所有可能地址的集合就称为虚拟地址空间(virtual address space)**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
## 2.1.1 十六进制表示法
一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_{2}$ ~ $11111111_{2}$。如果看成十进制整数，它的值域就是 $0_{10}$ ~ $255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制（简写为“hex”)使用数字 ‘0’~‘9’ 以及字符 ‘A’~‘F’ 来表示16个可能的值。![[../../attachments/Pasted image 20250826164553.png]]
在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’~‘F' 既可以是大写，也可以是小写。

## 2.1.2 字数据的大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w一1$ ，程序最多访问 $2^w$ 个字节。
由于从 32 位字长机器向 64 位字长机器的迁移，虚拟地址空间也扩展了。
不过大多数 64 位机器也可以运行为 32 位机器编译的程序（这是一种向后兼容）-- 但是为 64 位机器编译的程序只能在 64 位机器上运行。因此，我们将程序称为 ”32 位程序“ 或 ”64 位程序“ 时，区别在于该程序是如何编译的，而不是其运行的机器类型。
![[../../attachments/Pasted image 20250826170304.png]]
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t`和`int64_t`,它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。而程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

## 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
排列表示一个对象的字节有两个通用的规则。考虑一个 $w$ 位的整数，其位表示为$[x_{w-1}, x_{w-2},…,x_{1},x_{0}]$，其中 $x_{w-1}$ 是最高有效位，而 $x_{0}$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},…,x_{w-8}]$，而最低有效字节包含位$[x_{7},x_{6},…,x_{0}]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则一最低有效字节在最前面的方式，称为小端法(little endian)。后一种规则一最高有效字节在最前面的方式，称为大端法(big endian)。![[../../attachments/Pasted image 20250826192558.png]]
以下为字节顺序重要的三种情况：
对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。例如，当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反。
字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用 *强制类型转换(cast)* 或 *联合(union)* 来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

## 2.1.4 表示字符串
C 语言中字符串被编码为一个以 `null`(其值为 0 )字符**结尾**的**字符数组**。**每个字符**都由某个标准编码来表示，最常见的是 ASCⅡ 字符码。因此，如果我们以参数 “12345” 和 6 (包括终止符)来运行例程 `show bytes` ，我们得到结果 31 32 33 34 35 00。请注意，十进制数字 `x` 的 ASCⅡ 码正好是 `0x3x` ，而终止字节的十六进制表示为 `0x00`。在使用 ASCⅡ 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

## 2.1.5 表示代码
不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

## 2.1.6 布尔代数简介
