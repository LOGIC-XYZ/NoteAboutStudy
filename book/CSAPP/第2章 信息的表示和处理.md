孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(interpretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。

比如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。

在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。将研究三种最重要的数字表示：
- **无符号(unsigned)编码**基于传统的二进制表示法，表示大于或者等于零的数字。
- **补码(two's-complement)编码**是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。
- **浮点数(floating-point)编码**是表示实数的科学记数法的以 2 为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会**溢出（overflow）**。

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 $+∞$，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。（整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不同 -- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的）

---
# 2.1 信息存储
大多数计算机使用 8 位的块，或者字节(byte)，作为**最小的可寻址的内存单位**，而不是访问内存中单独的位。**机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)**。**内存的每个字节都由一个唯一的数字来标识，称为它的地址(address)**，**所有可能地址的集合就称为虚拟地址空间(virtual address space)**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

## 2.1.1 十六进制表示法
一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_{2}$ ~ $11111111_{2}$。如果看成十进制整数，它的值域就是 $0_{10}$ ~ $255_{10}$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制（简写为“hex”)使用数字 ‘0’~‘9’ 以及字符 ‘A’~‘F’ 来表示16个可能的值。
![[../../attachments/Pasted image 20250826164553.png]]
> [!tip]
> 在C语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A’~‘F' 既可以是大写，也可以是小写。

## 2.1.2 字数据的大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w一1$ ，程序最多访问 $2^w$ 个字节。

由于从 32 位字长机器向 64 位字长机器的迁移，虚拟地址空间也扩展了。

不过大多数 64 位机器也可以运行为 32 位机器编译的程序（这是一种向后兼容）-- 但是为 64 位机器编译的程序只能在 64 位机器上运行。因此，我们将程序称为 ”32 位程序“ 或 ”64 位程序“ 时，区别在于该程序是如何编译的，而不是其运行的机器类型。
![[../../attachments/Pasted image 20250826170304.png]]
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t`和`int64_t`,它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。而程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。

## 2.1.3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

排列表示一个对象的字节有两个通用的规则。考虑一个 $w$ 位的整数，其位表示为$[x_{w-1}, x_{w-2},…,x_{1},x_{0}]$，其中 $x_{w-1}$ 是最高有效位，而 $x_{0}$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位$[x_{w-1},x_{w-2},…,x_{w-8}]$，而最低有效字节包含位$[x_{7},x_{6},…,x_{0}]$，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则一最低有效字节在最前面的方式，称为小端法(little endian)。后一种规则一最高有效字节在最前面的方式，称为大端法(big endian)。
![[../../attachments/Pasted image 20250826192558.png]]
以下为字节顺序重要的三种情况：
1. 对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
2. 第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。例如，当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反。
3. 字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言中，可以通过使用 *强制类型转换(cast)* 或 *联合(union)* 来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

## 2.1.4 表示字符串
C 语言中字符串被编码为一个以 `null`(其值为 0 )字符**结尾**的**字符数组**。**每个字符**都由某个标准编码来表示，最常见的是 ASCⅡ 字符码。因此，如果我们以参数 “12345” 和 6 (包括终止符)来运行例程 `show_bytes` ，我们得到结果 31 32 33 34 35 00。请注意，十进制数字 `x` 的 ASCⅡ 码正好是 `0x3x` ，而终止字节的十六进制表示为 `0x00`。在使用 ASCⅡ 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

## 2.1.5 表示代码
不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

## 2.1.6 布尔代数简介
二进制值 1 和 0 表示逻辑值 TRUE 或者 FALSE，而运算符 ~、 &、 | 和 ^ 分别表示逻辑运算 NOT、 AND、 OR 和 EXCLUSIVE-OR（即 非、与、或、异或）。

可以将上述 4 个布尔运算扩展到**位向量**的运算，位向量就是固定长度为 $w$、由 0 和 1 组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。

位向量一个很有用的应用就是表示有限集合。布尔运算 | 和 & 分别对应于集合的并和交，而 ~ 对应于集合的补。（学离散的时候就觉得和集合很像）

## 2.1.7 C 语言中的位级运算
C 语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使用的那些符号就是C 语言所使用的：| 就是OR（或），& 就是AND（与），～ 就是NOT（取反），而就是EXCLUSIVE-OR（异或）。这些运算能运用到任何 “整型” 的数据类型上。

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从**一个字**中选出的**位的集合**。（就是用来**选择**或**屏蔽**某些二进制位，子网掩码就是这样的）

## 2.1.8 C 语言中的逻辑运算
C 语言还提供了一组逻辑运算符 `||`、`&&` 和 `!`，分别对应于命题逻辑中的 OR、AND 和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑运算认为所有**非零的参数**都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。

## 2.1.9 C 语言中的移位运算
C 语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为$[x_{w-1},x_{w-2}，…，x_{0}]$的操作数 $x$，C 表达式 `x<<k` 会生成一个值，其位表示为$[x_{w-k-1}，x_{w-k-2}，…，x_{0}，0，…，0]$。也就是说，$x$ 向左移动 $k$ 位，丢弃最高的 $k$ 位，并在**右端补 $k$ 个 $0$**。移位量应该是一个 $0$ ～ $w-1$ 之间的值。移位运算是从左至右可结合的，所以 `x<<j<<k` 等价于 `(x<<j)<<k`。

有一个相应的右移运算 `x>>k`，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：逻辑右移和算术右移。**逻辑右移在左端补 $k$ 个 $0$**，得到的结果是$[0，…，0，x_{w-1}，x_{w-2}，…，x_{k}]$。**算术右移是在左端补 $k$ 个最高有效位的值**，得到的结果是$[x_{w-1}，…，x_{w-1}，x_{w-1}，x_{w-2}，…，x_{k}]$。这种做法看上去可能有点奇特，但是它对有符号整数数据的运算非常有用。

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移 -- 算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对**有符号数使用算术右移**，且许多程序员也都假设机器会使用这种右移。另一方面，**对于无符号数，右移必须是逻辑的**。

> [!tip]
> 与 C 相比，Java 对于如何进行右移有明确的定义。表达是 `x>>k` 会将 x 算术右移 k 个位置，而 `x>>>k` 会对 x 做逻辑右移。

# 2.2 整数表示
将描述用位来编码整数的两种不同的方式：一种只能表示非负数，而一种能够表示负数、零和正数。

如图为引入的数学术语，用于精确定义和描述计算机如何编码和操作整数。
![[../../attachments/Pasted image 20250827195250.png]]

## 2.2.1 整数数据类型
![[../../attachments/Pasted image 20250827195714.png]]
![[../../attachments/Pasted image 20250827195810.png]]
> [!important]
> 如上图，负数与整数的取值范围是不对称的 -- 负数的范围比整数的范围大 1

## 2.2.2 无符号数的编码
讲述了无符号数编码的定义以及说明了无符号数编码的唯一性（让我有点不知道怎么做笔记，满脑子只有 8421 (〃・・)σ(・・〃) ）

假设有一个整数数据类型有 $w$ 位。可以将位向量写成 $\vec{x}$，表示整个向量，或者写成 $[x_{w-1},x_{w-2},…,x_{0}]$，表示向量中的每一位。把 $\vec{x}$ 看做一个二进制表示的数，就获得了它的无符号表示。在这个编码中，每个位 $x_i$ 都取值为 0 或 1，后一种曲子意味着数值 $2^i$ 应该为数字值的一部分。

> 定义 -- 对向量 $\vec{x} = [x_{w-1},x_{w-2},…,x_{0}]$: $$B2U_{w}(\vec{x})\dot{=}\sum_{i=0}^{w-1} x_{i}2^i$$

示例如图：
![[../../attachments/Pasted image 20250827201252.png]]

## 2.2.3 补码编码
除了整数，还需要表示负数值。最常见的有符号数的计算机表示方式就是**补码（two's-complement）**。在这个定义中，将字的最高位解释为负权（negative weight）-- 符号位。符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负。

> 定义 -- 对向量 $\vec{x} = [x_{w-1},x_{w-2},…,x_{0}]$: $$B2T_{w}(\vec{x})\dot{=}-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2} x_{i}2^i$$

示例如图：
![[../../attachments/Pasted image 20250827203949.png]]
补码编码也具有唯一性。

图 2-14 展示了针对不同字长，几个重要数字的位模式和数值。前三个给出的是可表示的整数的范围，用 $UMax_w$、$TMin_w$ 和 $TMax_w$ 来表示。
![[../../attachments/Pasted image 20250827204450.png]]
关于这些，有两点需要注意：
1. 补码的范围是不对称的：$|TMin|=|TMax|+1$，也就是说，$TMin$ 没有与之对应的正数。这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所以会有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示负数，而另一半(符号位设置为 0 的数)表示非负数。因为 0 是非负数，也就意味着能表示的整数比负数少一个；
2. 最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图 2-14 也给出了常数 -1 和 0 的表示。注意 -1 和 $UMax$ 有同样的位表示 -- 一个全 1 的串。数值 0 在两种表示方式中都是全 0 的串。

C 库中的文件 `<limits.h>` 定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。比如，它定义了常量 `INT_MAX`、`INT_MIN` 和 `UINT_MAX`，它们描述了有符号和无符号整数的范围。对于一个补码的机器，数据类型 `int` 有 $w$ 位，这些常量就对应于 $TMax_w$、$TMin_x$ 和 $UMax_w$ 的值。
![[../../attachments/Pasted image 20250827205418.png]]
![[../../attachments/Pasted image 20250827205437.png]]

## 2.2.4 有符号数和无符号数之间的转换
C 语言允许在各种不同的数字数据类型之间做强制类型转换。

从数学的角度来说，可以想象到几种不同的规则。很明显，对于在两种形式中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到 0。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到 $TMax$。不过，对于大多数 C 语言的实现来说，对这个问题的回答都是从位级角度来看的，而不是数的角度。

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

定义函数 $U2B_w$ 和 $T2B_w$，它们将数值映射为无符号数和补码形式的位表示。也就是说，给定 $0≤x≤UMax_w$ 范围内的一个整数 $x$，函数 $U2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位无符号表示。相似地，当 $x$ 满足 $TMin_w≤x≤TMax_w$，函数 $T2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位补码表示。

将函数 $T2U_w$ 定义为 $T2U_w(x)\dot{=}B2U_w(T2B_w(x))$。这个函数的输人是一个 $TMin_w$ ~ $TMax_w$ 的数，结果得到一个 $0$ ~ $UMax_w$ 的值，这里两个数有相同的位模式，除了参数是无符号的，而结果是以补码表示的。类似地，对于 $0$ ~ $UMax_w$ 之间的值 $x$，定义函数 $U2T_w$ 为$U2T_w(x)\dot{=}B2T_w(U2B_w(x))$。生成一个数的无符号表示和 $x$ 的补码表示相同。

> **补码转换为无符号数**，对满足 $TMin_w≤x≤TMax_w$ 的 $x$ 有：$$B2U_w(T2B_w(x))=T2U_w(x)=x+x
> _{w-1}2^w$$

示例如图：
![[../../attachments/Pasted image 20250827212054.png]]

> **无符号数转换为补码**，对满足 $0≤u≤UMax_w$ 的 $u$ 有：$$U2T_w(x)=-u_{w-1}2^w+u$$ 

以下是两个函数的转换行为图：
![[../../attachments/Pasted image 20250827212611.png]]

总结，考虑无符号与补码表示之间互相转换的结果。对于在范围 $0≤x≤ TMax_w$ 之内的值 $x$ 而言，我们得到 $T2U_w(x)=x$ 和 $U2T_w(x)=x$。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去 $2^w$。

## 2.2.5 C 语言中的有符号数与无符号数
![[../../attachments/Pasted image 20250828211032.png]]
在这两种情况下，`printf` 首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。

## 2.2.6 扩展一个数字的位表示
要将一个无符号数转换为一个更大的数据类型门只要简单地在表示的开头添加0。这种运算被称为**零扩展（zero extension）**。

> 定义 -- **无符号数的零扩展**：定义宽度为 $w$ 的位向量 $\vec{u}=[u_{w-1},u_{w-2},…,u_{0}]$ 和宽度为 $w'$ 的位向量 $\vec{u}'=[0,…,0,u_{w-1},u_{w-2},…,u_{0}]$，其中 $w'>w$。则 $B2U_w(\vec{u})=B2U_{w'}(\vec{u}')$。


要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展（sign extension）**，在表示中添加最高有效位的值。

> 定义 -- **补码数的符号扩展**：定义宽度为 $w$ 的位向量 $\vec{x}=[x_{w-1},x_{w-2},…,x_{0}]$ 和宽度为 $w'$ 的位向量 $\vec{x}'=[x_{w-1},…,x_{w-1},x_{w-1},x_{w-2},…,x_{0}]$，其中 $w'>w$。则 $B2U_w(\vec{x})=B2U_{w'}(\vec{x}')$。
![[../../attachments/Pasted image 20250828214711.png]]

## 2.2.7 截断数字
当将一个 $w$ 位的数 $\vec{x}=[x_{w-1},x_{w-2},…,x_0]$ 截断为一个 $k$ 位的数字时，丢弃高 $w-k$ 位，得到一个位向量  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$，截断一个数字可能会改变它的值 -- 溢出的一种形式。

> 定义 -- **截断无符号数**：令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},…,x_0]$，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果 -  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$。令 $x=B2U_w(\vec{x})$，$x'=B2U_k(\vec{x}')$。则 $x'=x mod 2^k$。

> 定义 -- **截断补码数值**：令 $\vec{x}$ 等于位向量 $[x_{w-1},x_{w-2},…,x_0]$，而 $\vec{x}'$ 是将其截断为 $k$ 位的结果 -  $\vec{x}'=[x_{k-1},x_{k-2},…,x_0]$。令 $x=B2U_w(\vec{x})$，$x'=B2T_k(\vec{x}')$。则 $x'=U2T_k(x mod 2^k)$。

截断补码数值与截断无符号数的区别在于前者还需要将无符号数转为补码。

## 2.2.8 关于有符号数与无符号数的建议
因为隐式类型转换可能导致错误或者漏洞，所以默认使用有符号数，仅在有需要时使用无符号数。

# 2.3 整数运算
## 2.3.1 无符号加法
考虑两个非负整数 $x$ 和 $y$，满足 $0 \leq x$，$y<2^w$，每个数都能表示为 $w$ 位无符号数字。然而，如果计算它们的和，就有一个可能的范围 $0 \leq x+y \leq w^{w+1}-2$。表示这个和可能需要 $w+1$ 位。
![[../../attachments/Pasted image 20250829154737.png]]

定义运算 $+_{w}^{u}$，其中 $0 \leq x$，$y<2^w$，该操作是把整数和 $x+y$ 截断为 $w$  位得到的结果，再把这个结果看做是一个无符号数。这个过程可以被视为一种形式的模运算，对  $x+y$ 的位级表示，丢弃任何权重大于 $2^{w-1}$ 的位就可以计算出和模 $2^w$ 的结果一致的数。

> 定义 -- **无符号数加法**：对满足 $0 \leq x$，$y<2^w$ 的 $x$ 和 $y$ 有 - $$
x+_{w}^uy=
\begin{cases}
 x+y, & x+y<2^w & 正常\\
x+y-2^w, & 2^w \leq x+y < 2^{w+1} & 溢出
 \end{cases}$$
![[../../attachments/Pasted image 20250829162131.png]]

> 定义 -- **检测无符号数加法中的溢出**：对在范围 $0 \leq x$，$y \leq UMax_w$ 中的 $x$ 和 $y$，令 $s\dot{=}x+_{w}^uy$。则对计算 $s$，当且仅当 $s<x$ （或者等价地 $s<y$）时，发生了溢出。

模 $2^w$ 下的加法形成了一种数学结构称为**阿贝尔群（Abelian group）**，满足交换律与结合律。它有一个单位元 0，并且每个元素有一个加法逆元（两者相加后，在模 $2^w$ 下结果为 0）.考虑 $w$ 位的无符号数的集合，执行加法运算 $+_{w}^{u}$。对于每个值 $x$，必然有某个值 $-_{w}^ux$ 满足 $-_{w}^ux+_{w}^ux=0$ 。

> 定义 -- **无符号数的取反**：对满足 $0 \leq x<2^w$ 的任意 $x$，其 $w$ 位的无符号逆元 $$
 -_{w}^ux=
 \begin{cases}
 x, & x = 0 \\
 2^w-x, & x > 0
 \end{cases}$$

## 2.3.2 补码加法
给定在范围 $-2^{w-1} \leq x，y \leq 2_{w-1}-1$ 之内的整数值 $x$ 和 $y$，它们的和就在范围 $-2^w \leq x+y \leq 2^w-2$ 之内，要想准确表示，考虑需要 $w+1$ 位。就需要通过将表示截断到 $w$ 位，来避免数据大小的不断扩张。

定义 $x+_{w}^ty$ 为整数和 $x+y$ 被截断为 $w$ 位的结果，并将这个结果看做是补码数。

> 定义 -- **补码加法**：对满足 $-2^{w-1} \leq x，y \leq 2_{w-1}-1$ 的整数 $x$ 和 $y$，有 - $$
 x+_{w}^ty=
 \begin{cases}
 x+y-2^w, & 2^{w-1} \leq x+y & 正溢出\\
 x+y, & -2^w \leq x+y \leq 2^w-2 & 正常\\
 x+y+2^w, & x+y < -2^{w-1} & 负溢出
 \end{cases}
 $$
![[../../attachments/Pasted image 20250829194817.png]]

> 定义 -- **检测补码加法中的溢出**：对满足 $TMin_w \leq x,y \leq TMax_w$ 的 $x$ 和 $y$，令 $s \dot{=} x+_{w}^ty$。当且仅当 $x>0,y>0$，但 $s \leq 0$ 时，计算 $s$ 发生了正溢出。当且仅当 $x<0,y<0$，但 $s \geq 0$ 时，计算 $s$ 发生了负溢出。

## 2.3.3 补码的非
范围在 $TMin_w \leq x \leq TMax_w$ 中的每个数字 $x$ 都有 $+_{w}^t$ 下的加法逆元。

> 定义 -- **补码的非**：对满足 $TMin_w \leq x \leq TMax_w$ 的 $x$，其补码的非 $$-_{w}^tx=
\begin{cases}
TMin_w, & x = TMin_w \\
-x, & x > TMin_w
\end{cases}
$$

## 2.3.4 无符号乘法
范围在 $0≤x,y≤2^w-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的无符号数，但是它们的乘积 $x·y$ 的取值范围为 $0$ ~ $(2^w-1)^2=2^{2w}-2^{w+1}+1$ 之间。这可能需要 $2w$ 位来表示。不过，C语言中的无符号乘法被定义为产生 $w$ 位的值，就是 $2w$ 位的整数乘积的低 $w$ 位表示的值（就截断啊）。将这个值表示为 $x*_{w}^uy$。而将一个无符号数截断为 $w$ 位等价于计算该值模 $2^w$。

> 定义 -- **无符号数乘法**：对满足 $0 \leq x,y \leq UMax_w$ 的 $x$ 和 $y$ 有 - $x*_{w}^uy=(x·y)mod 2^w$

## 2.3.5 补码乘法
范围在 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$ 内的整数 $x$ 和 $y$ 可以被表示为 $w$ 位的补码数字，但是它们的乘积 $x·y$ 的取值范围为 $-2^{w-1}·(2^{w-1}-1)=-2^{2w-2}+2^{w-1}$ ~ $-2^{w-1}·-2^{w-1}=-2^{2w-2}$ 之间。若想用补码来表示这个乘积，可能需要 $2w$ 位。然而，C 语言中的有符号乘法是通过将 $2w$ 位的乘积截断为 $w$ 位来实现的。将这个数值表示为 $x*_{w}^ty$。将一个补码数截断为 $w$  位相当于先计算该值模 $2^w$，再把无符号数转换为补码。

> 定义 -- **补码乘法**：对满足 $TMin_w \leq x,y \leq TMax_w$ 的 $x$ 和 $y$ 有 - $x*_{w}^t=U2T_w((x·y)mod2^w)$

对于无符号和补码乘法来说，乘法运算（截断后的乘积）的位级表示都是一样的。

## 2.3.6 乘以常数
