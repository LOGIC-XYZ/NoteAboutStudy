在处理器有电时，程序计数器会根据一个全是指令地址的序列去依次执行指令，这个过程称为 **控制转移（control transfer）**，这样的序列称为处理器的 **控制器（control flow）**。

正常情况下，控制流是线性的，但是程序自身逻辑导致的跳转、调用、返回会造成正常控制流的 “突变”（），同时，系统事件也会打断控制流：硬件定时器、网络包到达、磁盘 I/O 完成、子进程退出等事件，都必须使 CPU 停下当前执行，转去处理这些事件。

把这些来自系统状态变化的突变统称为 **异常控制流（Exceptional Control Flow，ECF）**。ECF 在系统各层都存在：
- **硬件层**：中断、异常 → 转到异常处理程序；
- **操作系统层**：内核执行进程切换；
- **应用层**：进程之间的信号、非本地跳转（来对错误做出反应）；

**程序员必须理解 ECF 的原因：**
- 理解 OS 内部机制（I/O、进程、虚拟内存）的基础；
- 解释了应用程序如何通过系统调用与操作系统交互；
- 创建 shell、Web 服务器等系统级应用的必备知识；
- 并发的根机制（中断、线程、进程、信号）；
- 帮助理解高级语言的异常机制（try/catch）是如何构建的；

---
# 8.1 异常
异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。因为有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同，但是基本思想都是相同的。

异常本质上就是：CPU 在执行某条指令时遇到某个事件 → 立刻强制跳到 OS 的异常处理程序 → 处理完再决定跳回哪里或是否终止程序。如图 8.1 展示了基本的思想。
![[NoteAboutStudy/attachments/Pasted image 20251212155627.png]]

当处理器正在执行当前指令，发生了某个状态变化（在处理器中，状态被编码为不同的位和信号），这个状态变化称为 **事件（event）**，可能和当前指令直接相关（同步异常，包括虚拟内存缺页、访问非法地址、算术溢出、除 0），也可能和当前指令的执行无关（异步异常，包括定时器中断、外部硬件信号）。

在任何情况下，当处理器检测到有事件发生时，会通过一张称为 **异常表（exception table）** 的跳转表，根据事件类型找到专门设计用来处理这类事件的操作系统子程序（**异常处理程序，exception handler**）并调用。

当异常处理程序处理完后，根据引起异常的事件的类型，执行以下三种返回方式的一个：
- 将控制返回给当前指令，重新执行；
- 将控制返回给当前指令的下一条指令；
- 处理程序终止被中断的程序；
8.1.2 节将讲述关于这些可能性的更多内容。

---
## 8.1.1 异常处理
处理异常需要硬件和软件一起合作：CPU 负责检测事件并跳到异常处理程序、OS 负责写异常处理程序并初始化异常表。

系统中可能的每种类型的异常都分配了唯一的非负整数的 **异常号（exception number）**，用于区分是哪种事件。异常号的来源有两部分：
- 处理器的设计者分配的，包括除 0、缺页、内存访问违例、断点以及算术运算溢出；
- 操作系统内核的设计者分配的，包括系统调用、外部 I/O 设备的信号；
异常号就是 “异常表” 的索引。

在系统启动时，操作系统分配和初始化 **异常表**，使得条目 $k$ 包含异常号为 $k$ 的异常处理程序的地址。

如图 8-3 展示了处理器如何使用异常表来形成适当的一场处理程序的地址，异常号为异常表中的索引，异常表的起始地址放在一个称为 **异常表基址寄存器（exception table base register）** 的特殊 CPU 寄存器中。
![[NoteAboutStudy/attachments/Pasted image 20251212162921.png]]

异常类似过程调用，但是有一些重要的不同之处：
- **返回地址由事件类型决定** -- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令，要么是下一条指令；
- **CPU 会自动保存一些额外的处理器状态** -- 在处理程序返回时，重新开始执行被中断的程序会需要这些状态；
- **转入内核时使用内核栈而不是用户栈** -- 保存的状态全部压入内核栈，内核栈不能被用户访问，这样能确保安全性 - 用户不能伪造异常上下文；
- **异常处理程序在内核模式下执行**（详情见 8.2.4 节） -- 意味着对所有系统资源都有完全的访问权限；

硬件触发了异常，完成了以下：
1. 检测事件；
2. 查异常表；
3. 保存状态；
4. 切换到内核态；
5. 切换到内核栈；
6. 跳转到异常处理程序入口；
剩下的就是由异常处理程序在软件中完成。

在处理程序处理完事件后，通过执行一条特殊的 ”从中断返回“ 的指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断是一个用户程序，就将状态恢复为 **用户模式**（详情见 8.2.4 节），然后将控制返回给被中断的程序。

## 8.1.2 异常的类别
异常可分为四类：**中断（interrupt）**、**陷阱（trap）**、**故障（fault）** 和 **终止（abort）**。图 8-4 中的表对这些类别的属性做了小结：

![[NoteAboutStudy/attachments/Pasted image 20251212172037.png]]

除中断外的其他异常都是同步发生的，是执行当前指令的结果，把这类指令称为 **故障指令（fault instruction）**。

---
### 中断
中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。与当前正在执行的指令无关（硬件中断不由任何一条专门的指令造成的），所以称为异步。硬件中断的异常处理程序常常称为中断处理程序。

![[NoteAboutStudy/attachments/Pasted image 20251212172732.png]]
图 8-5 概述了一个中断的处理，外设通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

中断流程：`当前指令执行完 → CPU 发现中断线被拉高 → 读取异常号 → 进入中断处理程序 → 返回下一条指令`

对用户程序而言，中断 “仿佛不存在”。

### 陷阱和系统调用
陷阱是程序主动发起的异常。最主要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为 **系统调用**。

用户程序进程需要向内核请求服务（读一个文件、创建一个新的进程、加载一个新的程序或者终止当前进程）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 `syscall n` 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 `syscall` 指令会导致一个到y
### 故障

### 终止
