在处理器有电时，程序计数器会根据一个全是指令地址的序列去依次执行指令，这个过程称为 **控制转移（control transfer）**，这样的序列称为处理器的 **控制器（control flow）**。

正常情况下，控制流是线性的，但是程序自身逻辑导致的跳转、调用、返回会造成正常控制流的 “突变”（），同时，系统事件也会打断控制流：硬件定时器、网络包到达、磁盘 I/O 完成、子进程退出等事件，都必须使 CPU 停下当前执行，转去处理这些事件。

把这些来自系统状态变化的突变统称为 **异常控制流（Exceptional Control Flow，ECF）**。ECF 在系统各层都存在：
- **硬件层**：中断、异常 → 转到异常处理程序；
- **操作系统层**：内核执行进程切换；
- **应用层**：进程之间的信号、非本地跳转（来对错误做出反应）；

**程序员必须理解 ECF 的原因：**
- 理解 OS 内部机制（I/O、进程、虚拟内存）的基础；
- 解释了应用程序如何通过系统调用与操作系统交互；
- 创建 shell、Web 服务器等系统级应用的必备知识；
- 并发的根机制（中断、线程、进程、信号）；
- 帮助理解高级语言的异常机制（try/catch）是如何构建的；

---
# 8.1 异常
异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。因为有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同，但是基本思想都是相同的。

异常本质上就是：CPU 在执行某条指令时遇到某个事件 → 立刻强制跳到 OS 的异常处理程序 → 处理完再决定跳回哪里或是否终止程序。如图 8.1 展示了基本的思想。
![[NoteAboutStudy/attachments/Pasted image 20251212155627.png]]

当处理器正在执行当前指令，发生了某个状态变化（在处理器中，状态被编码为不同的位和信号），这个状态变化称为 **事件（event）**，可能和当前指令直接相关（同步异常，包括虚拟内存缺页、访问非法地址、算术溢出、除 0），也可能和当前指令的执行无关（异步异常，包括定时器中断、外部硬件信号）。

在任何情况下，当处理器检测到有事件发生时，会通过一张称为 **异常表（exception table）** 的跳转表，根据事件类型找到专门设计用来处理这类事件的操作系统子程序（**异常处理程序，exception handler**）并调用。

当异常处理程序处理完后，根据引起异常的事件的类型，执行以下三种返回方式的一个：
- 将控制返回给当前指令，重新执行；
- 将控制返回给当前指令的下一条指令；
- 处理程序终止被中断的程序；
8.1.2 节将讲述关于这些可能性的更多内容。

---
## 8.1.1 异常处理
处理异常需要硬件和软件一起合作：CPU 负责检测事件并跳到异常处理程序、OS 负责写异常处理程序并初始化异常表。

系统中可能的每种类型的异常都分配了唯一的非负整数的 **异常号（exception number）**，用于区分是哪种事件。异常号的来源有两部分：
- 处理器的设计者分配的，包括除 0、缺页、内存访问违例、断点以及算术运算溢出；
- 操作系统内核的设计者分配的，包括系统调用、外部 I/O 设备的信号；
异常号就是 “异常表” 的索引。

在系统启动时，操作系统分配和初始化 **异常表**，使得条目 $k$ 包含异常号为 $k$ 的异常处理程序的地址。

如图 8-3 展示了处理器如何使用异常表来形成适当的一场出，