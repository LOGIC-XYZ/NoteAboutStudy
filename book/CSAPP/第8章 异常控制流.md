在处理器有电时，程序计数器会根据一个全是指令地址的序列去依次执行指令，这个过程称为 **控制转移（control transfer）**，这样的序列称为处理器的 **控制器（control flow）**。

正常情况下，控制流是线性的，但是程序自身逻辑导致的跳转、调用、返回会造成正常控制流的 “突变”（），同时，系统事件也会打断控制流：硬件定时器、网络包到达、磁盘 I/O 完成、子进程退出等事件，都必须使 CPU 停下当前执行，转去处理这些事件。

把这些来自系统状态变化的突变统称为 **异常控制流（Exceptional Control Flow，ECF）**。ECF 在系统各层都存在：
- **硬件层**：中断、异常 → 转到异常处理程序；
- **操作系统层**：内核执行进程切换；
- **应用层**：进程之间的信号、非本地跳转（来对错误做出反应）；

**程序员必须理解 ECF 的原因：**
- 理解 OS 内部机制（I/O、进程、虚拟内存）的基础；
- 解释了应用程序如何通过系统调用与操作系统交互；
- 创建 shell、Web 服务器等系统级应用的必备知识；
- 并发的根机制（中断、线程、进程、信号）；
- 帮助理解高级语言的异常机制（try/catch）是如何构建的；

---
# 8.1 异常
异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。因为有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同，但是基本思想都是相同的。

异常本质上就是：CPU 在执行某条指令时遇到某个事件 → 立刻强制跳到 OS 的异常处理程序 → 处理完再决定跳回哪里或是否终止程序。如图 8.1 展示了基本的思想。
![[NoteAboutStudy/attachments/Pasted image 20251212155627.png]]

当处理器正在执行当前指令，发生了某个状态变化（在处理器中，状态被编码为不同的位和信号），这个状态变化称为 **事件（event）**，可能和当前指令直接相关（同步异常，包括虚拟内存缺页、访问非法地址、算术溢出、除 0），也可能和当前指令的执行无关（异步异常，包括定时器中断、外部硬件信号）。

在任何情况下，当处理器检测到有事件发生时，会通过一张称为 **异常表（exception table）** 的跳转表，根据事件类型找到专门设计用来处理这类事件的操作系统子程序（**异常处理程序，exception handler**）并调用。

当异常处理程序处理完后，根据引起异常的事件的类型，执行以下三种返回方式的一个：
- 将控制返回给当前指令，重新执行；
- 将控制返回给当前指令的下一条指令；
- 处理程序终止被中断的程序；
8.1.2 节将讲述关于这些可能性的更多内容。

---
## 8.1.1 异常处理
处理异常需要硬件和软件一起合作：CPU 负责检测事件并跳到异常处理程序、OS 负责写异常处理程序并初始化异常表。

系统中可能的每种类型的异常都分配了唯一的非负整数的 **异常号（exception number）**，用于区分是哪种事件。异常号的来源有两部分：
- 处理器的设计者分配的，包括除 0、缺页、内存访问违例、断点以及算术运算溢出；
- 操作系统内核的设计者分配的，包括系统调用、外部 I/O 设备的信号；
异常号就是 “异常表” 的索引。

在系统启动时，操作系统分配和初始化 **异常表**，使得条目 $k$ 包含异常号为 $k$ 的异常处理程序的地址。

如图 8-3 展示了处理器如何使用异常表来形成适当的一场处理程序的地址，异常号为异常表中的索引，异常表的起始地址放在一个称为 **异常表基址寄存器（exception table base register）** 的特殊 CPU 寄存器中。
![[NoteAboutStudy/attachments/Pasted image 20251212162921.png]]

异常类似过程调用，但是有一些重要的不同之处：
- **返回地址由事件类型决定** -- 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令，要么是下一条指令；
- **CPU 会自动保存一些额外的处理器状态** -- 在处理程序返回时，重新开始执行被中断的程序会需要这些状态；
- **转入内核时使用内核栈而不是用户栈** -- 保存的状态全部压入内核栈，内核栈不能被用户访问，这样能确保安全性 - 用户不能伪造异常上下文；
- **异常处理程序在内核模式下执行**（详情见 8.2.4 节） -- 意味着对所有系统资源都有完全的访问权限；

硬件触发了异常，完成了以下：
1. 检测事件；
2. 查异常表；
3. 保存状态；
4. 切换到内核态；
5. 切换到内核栈；
6. 跳转到异常处理程序入口；
剩下的就是由异常处理程序在软件中完成。

在处理程序处理完事件后，通过执行一条特殊的 ”从中断返回“ 的指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断是一个用户程序，就将状态恢复为 **用户模式**（详情见 8.2.4 节），然后将控制返回给被中断的程序。

## 8.1.2 异常的类别
异常可分为四类：**中断（interrupt）**、**陷阱（trap）**、**故障（fault）** 和 **终止（abort）**。图 8-4 中的表对这些类别的属性做了小结：

![[NoteAboutStudy/attachments/Pasted image 20251212172037.png]]

除中断外的其他异常都是同步发生的，是执行当前指令的结果，把这类指令称为 **故障指令（fault instruction）**。

---
### 中断
中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。与当前正在执行的指令无关（硬件中断不由任何一条专门的指令造成的），所以称为异步。硬件中断的异常处理程序常常称为中断处理程序。

![[NoteAboutStudy/attachments/Pasted image 20251212172732.png]]

   图 8-5 概述了一个中断的处理，外设通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

中断流程：`当前指令执行完 → CPU 发现中断线被拉高 → 读取异常号 → 进入中断处理程序 → 返回下一条指令`

对用户程序而言，中断 “仿佛不存在”。

### 陷阱和系统调用
陷阱是程序主动发起的异常。最主要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为 **系统调用**。

用户程序进程需要向内核请求服务（读一个文件、创建一个新的进程、加载一个新的程序或者终止当前进程）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 `syscall n` 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 `syscall` 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。如图 8-6 概述了一个系统调用的处理。

![[NoteAboutStudy/attachments/Pasted image 20251212200107.png]]

尽管从程序员的角度来看，系统调用和普通的函数调用是一样的。但是它们的实现并不同：
- 普通的函数运行在 **用户模式** 中，用户模式限制了函数可以执行的指令的类型，而且只能访问与调用函数相同的栈；
- 系统调用运行在 **内核模式** 中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈；
8.2.4 节会更详细地讨论用户模式和内核模式。

### 故障
故障由错误情况引起，可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序：
- 如果处理程序能够修正这个错误情况，就将控制返回到引起故障的指令，并重新执行；
- 如果不能修正，处理程序返回到内核中的 `abort` 例程，这个例程会终止引起故障的应用程序。
如图 8-7 概述了一个故障的处理。

![[NoteAboutStudy/attachments/Pasted image 20251212200853.png]]

典型例子：**缺页异常（page fault）**
步骤：
1. 程序访问虚拟地址 A；
2. CPU 发现 A 不在内存（页表中 P=0）；
3. 触发 page fault（属于 fault）；
4. 内核加载所需页面到内存；
5. 内核返回到 **引起 fault 的那条指令**；
6. 那条指令重新执行，这次成功；
这就是虚拟内存能工作的根本机制。

### 终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，终止处理程序从不将控制返回给应用程序。如图 8-8 所示，处理程序将控制返回给了 `abort` 例程。

![[NoteAboutStudy/attachments/Pasted image 20251212201313.png]]

## 8.1.3 Linux/x86-64 系统中的异常
为了使描述更具体，如图 8-9 所示为 x86-64 系统定义的一些异常，有高达 256 种不同的异常类型。0~31 的号码是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都一样。32~255 的号码对应的是操作系统定义的中断和陷阱。

![[NoteAboutStudy/attachments/Pasted image 20251212202123.png]]

---
### 1. Linux/x86-64 故障和终止
- **除法错误**。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说过大时，就会发生除法错误（异常 0）。Unix 选择终止程序，Linux shell 通常会把除法错误报告为 ”浮点异常（Floating exception）“。
- **一般保护故障**。许多原因都会导致不为人知的一般保护故障（异常 13）。通常是一个程序引用了一个未定义的虚拟内存区域，或者程序试图写入一个只读的文本段（指的是 **程序自己的代码段 .text segment**，也就是机器指令所在的内存区域）。Linux 选择终止进程，Linux shell 通常会把这种一般保护故障报告为 ”段故障（Segmentation fault）“。
- **缺页**。是一个会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。
- **机器检查**。是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。

### 2. Linux/x86-64 系统调用
Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。如图 8-10 所示为一些常见的 Linux 系统调用。每个系统调用都有唯一的整数号，对应于一个到内核中跳转表的偏移量。

![[NoteAboutStudy/attachments/Pasted image 20251212203944.png]]

> [!info]+
> C 程序用 syscall 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。在本书中，将系统调用和与它们相关联的包装函数都称为**系统级函数**，这两个术语可以互换地使用。

在 X86-64 系统上，系统调用是通过一条称为 syscall 的陷阱指令来提供的。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的。调用约定：
- `%rax`：系统调用号；
- `%rdi`、`%rsi`、`%rdx`、`%r10`、`%r8`、`%r9`：最多 6 个参数；
- 返回：
    - `%rax` = 返回值；
    - 负值（−4095 ~ −1）表示错误（对应 errno）；
    - `%rcx` 和 `%r11` 会被破坏；

# 8.2 进程
进程的经典定义就是一个 **正在执行的程序实例**。系统中的每个程序都运行在某个进程的 **上下文（context）** 中。而上下文是由程序正确运行所需的状态组成的，包括：
- 存放在内存中的程序的代码和数据；
- 栈 -- 程序执行到哪以及调用关系；
- 通用目的寄存器 -- 程序正在算的结果；
- 程序计数器；
- 环境变量 -- 程序运行的外部配置；
- 打开的 文件描述符 的集合 -- 程序与如何外界交互；

进程的创建：
- 用户在 shell 中运行程序，shell 就会创建新进程，并在这个新进程的上下文中运行这个可执行文件；
- 应用程序也可以创建新进程，并在这个新进程的上下文中运行自己的代码或其他应用程序；

进程通过异常、上下文切换等机制，向程序提供两大抽象：
- **一个独立的控制流**，提供一个假象关于程序独占使用 CPU（指令像是连续、不被打断地执行）；
- **一个私有的地址空间**】，提供一个假象关于程序独占使用 内存（无法直接访问其他进程的内存）；

---
## 8.2.1 逻辑控制流
**逻辑控制流（logical flow）** 就是进程所以为的指令执行顺序，并不是 CPU 实际的执行顺序（简称 **逻辑流**）。（异常处理程序、进程、信号处理程序、线程、Java 进程都是逻辑流）

即使在系统中通常有许多其他程序在运行，但是如果用调试器单步执行程序，会看到一系列的程序计数器的值，这些值全部来自这个程序的代码，并且是顺序执行的，不包含其他进程的指令。这条 PC 序列就是逻辑控制流，是进程私有的，与 CPU 实际运行顺序并不完全一致。

![[NoteAboutStudy/attachments/Pasted image 20251214184333.png]]
如图 8-12 所示，进程轮流使用处理器，每个进程执行它的逻辑控制流的一段，然后被 **抢占（preempted，暂时挂起）**，然后轮到其他进程。因为抢占会保存当前进程的上下文，恢复后继续执行程序时，除了时间并没有什么不同，所以进程只会觉得 CPU 一直在执行它。

## 8.2.2 并发流
两个或多个逻辑流在 ==时间== 上发生重叠，称为 **并发流（concurrent flow）**。这些流被称为 **并发地运行**。

> 多个流并发地执行的一般现象称为 **并发**（单核 CPU 执行多个流也是）。

> 一个进程和其他进程轮流运行称为 **多任务（multitasking）**。

> 一个进程连续占用 CPU 的一小段时间称为 **时间片（time slice）**。

**并行流（parallel flow）** 是并发流的真子集：两个并发流 **同时** 运行在不同的处理器核或不同的机器上。

## 8.2.3 私有地址空间
在一台 n 位地址的机器上，**地址空间** 是 $2^n$ 个可能地址（$0$~$2^n-1$）的集合，进程为每个程序提供 **私有地址空间**，此处的地址指的是虚拟地址。一般而言，同一个虚拟地址在不同进程中指向的是不同的物理内存，同时，一个进程不能随意读写另一个进程的内存，也就是访问隔离。

尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。如图 8-13 所示为一个 x86-64 Linux 进程的地址空间的组织结构。

![[NoteAboutStudy/attachments/Pasted image 20251214192153.png]]

从低地址到高地址，分别是：
1. **用户空间** -- 应用程序能直接访问的部分，包括通常的代码、数据、堆和栈段
	- 代码段，总是从地址 `0x400000`;
2. **内核空间** -- 保留给内核的部分，包含内核在代表进程执行指令时（系统调用、异常、中断）使用的代码、数据和栈；

## 8.2.4 用户模式和内核模式
处理器需要提供一个机制用以限制一个应用可以执行的指令以及可以访问的地址空间范围，以实现进程抽象。为此，通常用某个控制寄存器中的一个 **模式位** 来提供这种功能，该寄存器描述了进程当前享有的特权：
- 当设置了模式位，进程就运行在 **内核模式** 中（有时也叫超级用户模式），一个运行在内核模式的进程可以执行指令集中的任何指令，也可以访问系统中的任何内存位置；
- 没有设置模式位时，进程运行在 **用户模式** 中，用户模式中的进程不允许执行特权指令，也不能直接引用地址空间中内核区的代码和数据（任何这样的尝试都会导致硬件触发保护故障，用户程序必须通过异常间接访问内核代码和数据）；

用户程序使用系统资源的方式：
1. 运行应用程序代码的进程初始时是在用户模式中的；
2. 进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常；
3. 当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式；
4. 处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式；

而 Linux 提供了 `/proc` 文件系统和 `/sys` 文件系统，它们将内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构（后者输出关于系统总线和设备的额外的底层信息），访问的是 “内核生成的数据副本”，不是内核内存本身。

## 8.2.5 上下文切换
操作系统内核使用一种称为 **上下文切换（context switch）** 的异常控制流来实现多任务。内核为每个进程维持一个 **上下文**，就是内核重新启动一个被抢占的进程所需的状态，包括：
- 通用目的寄存器；
- 浮点寄存器；
- 程序计数器；
- 用户栈；
- 状态寄存器；
- 内核栈；
- 各种内核数据结构（比如，描述地址空间的 **页表**、包含有关当前进程信息的 **进程表**、包含进程已打开文件的信息的 **文件表**）；

当进程执行的某些时刻，内核可以决定抢占当前进程，并恢复某个先前被抢占的进程，这种决策称之为 **调度（scheduling）**，是由内核中称为 **调度器（scheduler）** 的代码处理的。

发生上下文切换的常见三类触发点：
- **系统调用阻塞** -- 当系统调用因等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到其他可运行进程；
- **即使不阻塞，内核也可能切换** -- 而不是将控制返回给调用进程；
- **中断** -- 比如所有的系统都有定时器产生周期性中断的机制，每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新进程；

上下文切换的步骤：
1. **保存当前进程上下文**；
2. **恢复另一个进程的上下文**；
3. **控制权转移**，执行新进程的下一条指令；
全在内核模式下完成。

# 8.3 系统调用错误处理
当 Unix 系统中，几乎所有的系统调用函数（如 `fork`, `wait`, `open` 等）在遇到错误时，通常会返回 -1，并设置全局整数变量 `errno` 来指明具体失败原因。

比如下面是调用 `Unix fork` 函数时检查错误的标准写法：
```c
if ((pid = fork()) < 0) { // 1. 调用并判断返回值 
	fprintf(stderr, "fork error: %s\n", strerror(errno)); // 2. 打印错误信息 
	exit(0); // 3. 终止程序 
}
```
但是这种重复的 `if` 检查使代码臃肿，增加阅读理解难度。但程序不能没有检查，为此，通过定义如下的 **错误报告函数**，可以在某种程度上简化代码：
```c
void unix_error(char *msg) { 
	fprintf(stderr, "%s: %s\n", msg, strerror(errno)); // 自动获取 errno 的含义 
	exit(0); // 直接结束程序 
}
```
现在，调用就从 4 行变成了 2 行：
```c
if ((pid = fork()) < 0) 
	unix_error("fork error");
```

通过使用 **错误处理包装** 函数，可以进一步简化代码。包装函数调用基本函数，检查错误，如果有任何问题就终止，并将首字母大写。比如，下面是 `fork` 函数的错误处理包装函数：
```c
pid_t Fork(void) { 
	pid_t pid; 
	if ((pid = fork()) < 0) // 在内部进行系统调用和检查 
		unix_error("Fork error"); // 出错直接挂掉 
	return pid; // 没出错才返回 
}
```
这样，调用就缩减为 1 行了：
```c
pid = Fork();
```

本书剩余部分将都使用错误处理包装函数。它们能够保持代码示例简洁，专注于业务逻辑而不是错误处理逻辑中。注意，当本书中谈到系统调用函数时，总是用它们的小写字母的基本名字来引用它们，而不是它们的大写首字母的包装函数名来引用。

# 8.4 进程控制
Unix 提供了大量从 C 程序中操作进程的系统调用。这一节将描述这些重要函数，并说明如何使用。

---
## 8.4.1 获取进程 ID
每个进程都有一个唯一的正数（非零）**进程 ID（PID）**。

- `getpid` 函数返回当前调用进程的 PID；
- `getppid` 函数返回它的 parent 进程的 PID（创建调用进程的进程）；
两个函数都返回一个类型为 `pid_t` 的整数值（在 Linux 系统上，它在 `types.h` 中被定义为 `int`）。

## 8.4.2 创建和终止进程
从 程序员的角度 来说，可以认为进程总是处于下面的三种状态之一：
- **运行**。进程要么在 CPU 上执行，要么等待被执行且最终会被内核调度；
- **停止**。进程的执行被 **挂起（suspended）**，且不会被调度。当收到 `SIGSTOP`、`SIGTSTP`、`SIGTTIN` 或 `SIGTTOU` 信号时，进程就停止，并且保持停止直到收到一个 `SIGCONT` 信号时，进程再次开始运行；
- **终止**。进程彻底停止了，不会再运行。进程有三种原因会终止：
	1. 收到一个默认行为是终止进程的信号；
	2. 从主程序 `main` 返回；
	3. 调用 `exit` 函数；

## 8.4.3 回收子进程
当一个进程终止时，内核并不会把它立即从系统中清除，而是保持在一种已终止的状态中，直到被它的 parent 进程 **回收**：
- 当回收进行时，内核将子进程的退出状态传递给 parent 进程，然后抛弃已终止的进程，这个时候，这个进程才不存在了。
而一个终止了但还没有被回收的进程称为 **僵死进程（zombie）**。

> 因为退出状态需要被接收，所以：
 - 子进程通过 `exit(status)` 或 `return` 把结果交给父进程；
 - 内核负责暂存；
 - parent 进程负责取走；
而如果 parent 进程：
- 不调用 `wait / waitpid`；
- 或者是一个长期运行的进程（shell 或 服务器）；
那么，僵死进程会不断积累，消耗系统的内存资源，并会导致 PID 和 内核表项耗尽。

如果 parent 进程比子进程先终止，内核会把这些子进程托管给 `init` 进程（该进程 PID 为 1，是在系统启动时由内核创建的，不会终止，是所有进程的祖先），该进程会自动回收它们。

一个进程可以通过调用 `waitpid` 函数来等待它的子进程终止或者停止。
```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
```
- 如果成功返回子进程的 PID；
- 如果 WNOHANG，则返回 0；
- 如果其他错误，则为 -1；
默认情况下（当 options = 0）时，`waitpid` 挂起调用进程的执行，直到它的 **等待集合（wait set）** 里有子进程终止时，执行回收。
1. **判定等待集合的成员** -- 由参数 `pid` 决定：
	- 如果 `pid > 0`，那么等待集合就是一个单独的子进程，即只等待进程 ID 为 `pid` 的子进程；
	- 如果 `pid = -1`，那么等待集合就是由该进程的所有子进程组成的；

2. **修改默认行为** -- 可以将 `options` 设置为 WNOHANG、WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为（阻塞或不阻塞）：
	- 默认行为（`options = 0`）：直到等待集合里有子进程终止时，立即回收它；
	- WNOHANG：如果等待集合中的任何子进程都没有终止，立即返回 0（如果还想做其他工作，比如服务器主循环、事件驱动程序之类的，可以用这个不耽误工作）；
	- WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回的 PID 为该子进程的 PID；
	- WCONTINUED：挂起调用进程的执行，直到等待集合中的一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行；
	- 组合起来，例如 -- WNOHANG | WUNTRACED：立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为 0，如果有一个停止或终止，则返回值为该子进程的 PID；

3. **检查已回收子进程的退出状态** -- 如果 `statusp` 参数是非空的，那么 `waitpid` 就会在 `status` 中关于袋子返回的子进程的状态信息，`status` 是 `statusp` 指向的值。`wait.h` 头文件定义了解释 `status` 参数的宏：
	- WIFEXITED(status)：如果子进程通过调用 exit 或者一个返回（return）正常终止，就返回真；
	- WEXITSTATUS(status)：返回一令正常终止的子进程的退出状态。只有在 `WIFEXITED()` 返回为真时，才会定义这个状态；
	- WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，那么就返回真；
	- WTERMSIG(status)：返回导致子进程终止的信号的编号。只有在 `WIFSIGNALED()` 返回为真时，才定义这个状态；
	- WIFSTOPPED(status)：如果引起返回的子进程当前是停止的，那么就返回真；
	- WSTOPSIG(status)：返回引起子进程停止的信号的编号。只有在` WIFSTOPPED()` 返回为真时，才定义这个状态；
	- WIFCONTINUED(status)：如果子进程收到 SIGCONT 信号重新启动，则返回真；

4. **错误条件**：
	- 如果调用进程没有子进程，那么 `waitpid` 返回 -1，并且设置 `errno` 为 ECHILD；
	- 如果 `waitpid` 函数被一个信号中断，那么返回 -1，并设置 `errno` 为 ENTER；

5. **`wait` 函数** -- 是 `waitpid` 函数的简单版本 `pid_t wait(int *statusp)`，调用 `wait(&status)` 等价于调用 `waitpid(-1, &status, 0)`；

6. 结束子进程的顺序有两种：
	- 符合真实并发系统，先结束的先处理，但是在不同的机器上或者每一次运行的顺序都可能不一样；
	- 人为设置顺序，但是会阻塞某些进程，设置顺序的代码容易 bug；

## 8.4.4 让进程休眠
`sleep` 函数将一个进程挂起一段指定时间：
```c
#include <unistd.h>
unsigned int sleep(unsigned int secs);
```
如果请求的时间量已经到了，返回 0，否则返回还剩下的要休眠的秒数（后一种情况是有可能的，如果该函数被一个信号中断而过早地返回）。

`pause` 函数让调用函数休眠，直到该进程收到一个信号，返回 -1：
```c
#include <unistd.h>
int pause(void);
```

## 8.4.5 加载并运行程序
`execve` 函数在当前进程的上下文中加载并运行一个新程序 -- 可执行目标文件 `filename`，且带参数列表 `argv` 和环境变量列表 `envp`。：
```c
#include <unistd.h>
int execve(const char *filename, const char *argv[], const char *envp[]);
```
如果成功，则不返回，如果错误（找不到文件、权限错误、非可执行），则返回 -1到调用程序。

参数列表是由图 8-20 中的数据结构表示的。`argv` 变量指向一个以 `null` 结尾的指针数组，其中每个指针都指向一个参数字符串（按照惯例，`argv[0]` 是可执行目标文件的名字）。
![[NoteAboutStudy/attachments/Pasted image 20251230215415.png]]

环境列表是由一个与参数列表类似的数据结构表示的，如图 8-21 所示。`envp` 变量指向一个以 `null` 结尾的指针数组，其中每个指针都指向一个环境变量字符串，每个字符串都是形如 `name = value` 的 `名字-值` 对。
![[NoteAboutStudy/attachments/Pasted image 20251230215711.png]]

在 `execve` 加载了 `filename` 后，它调用 7.9 节中所描述的启动代码，该代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型：
- `int main(int argc, char **argv, char **envp);`
- `int main(int argc, char *argv[], char *envp[]);`

当 `main` 函数开始执行时，用户栈的组织结构如图 8-22 所示。从高地址到低地址：
	- 参数字符串本体（图中的命令行字符串）
	- 环境变量字符串本体
	- `envp[]`（指针数组，以 NULL 结尾，每个指针都指向栈中的一个环境变量字符串，全局变量 `environ` 指向 `envp[0]`）
	- `argv[]`（指针数组，以 NULL 结尾，每个指针都指向栈中的一个参数字符串）
	- 栈顶为系统启动函数 `__libc_start_main` （见 7.9 节）的栈帧
![[NoteAboutStudy/attachments/Pasted image 20251230221237.png]]

`main` 函数有 3 个参数：
	1. `argc`，给出 `argv[]` 数组中非空指针的数量；
	2. `argv`，指向 `argv[]` 数组中的第一个条目；
	3. `envp`，指向 `envp[]` 数组中的第一个条目；

Linux 提供了几个函数来操作环境数组：
1. 
	```c	
	char *getenv(const char *name);
	```
	`getenv` 函数在环境数组中搜索字符串 `name = value`。如果找到了，就返回指向 `value` 的指针，否则就返回 `NULL`。
2. 
	```c
	int setenv(const char *name, const char *newvalue, int overwrite); // 成功返回 0，错误返回 -1
	void unsetenv(const char *name);
	```
	- 如果环境数组包含一个形如 `name = value` 的字符串，那么 `unsetenv` 会删除它，`setenv` 会用 `newvalue` 代替 `oldvalue`，但是只有在 `overwrite` 非零时才会这样；
	- 如果 `name` 不存在，那么 `setenv` 就把 `name = newvalue` 添加到数组中；

> [!tip]+ 程序与进程
> **程序 (Program)：** 是一堆在磁盘上的代码和数据（如 `.o` 文件或可执行文件）。 
>     
> **进程 (Process)：** 是程序运行起来后的一个具体实例。一个程序可以同时对应多个进程（比如开了三个终端窗口，就是运行了三个 `bash` 进程，但它们对应磁盘上同一个 `bash` 程序）。

| **特性**    | **fork()**             | **execve()**        |
| --------- | ---------------------- | ------------------- |
| **动作逻辑**  | **Clone**              | **Overwrite**       |
| **进程数量**  | **+1** (创建了一个全新的子进程)   | **不变** (还是当前那个进程)   |
| **程序代码**  | **不变** (运行和父进程一模一样的代码) | **变了** (加载全新的代码和数据) |
| **地址空间**  | 复制父进程的地址空间             | **清空并覆盖**当前地址空间     |
| **PID**   | 子进程获得**新 PID**         | 保持**旧 PID** 不变      |
| **文件描述符** | 子进程继承父进程的              | 新程序**继承**旧程序打开的文件   |

## 8.4.6 利用 `fork` 和 `execve` 运行程序
像 Unix shell 和 Web 服务器这样的程序大量使用了 `fork` 和 `execve` 函数。shell 执行一系列的 **读 / 求值（read / evaluate)** 步骤，然后终止：
- 读步骤读取一个来自用户的命令行；
- 求值步骤解析命令行，并代表用户运行程序。

如图 8-23 所示为一个简单的 shell 的 `main` 例程。shell 打印一个命令提示符，等待用户在 `stdin` 上输入命令行，然后对这个命令行求值：
	![[NoteAboutStudy/attachments/Pasted image 20260101210209.png]]
		 ![[NoteAboutStudy/attachments/ee88f0d8551ad904d42940f47c26edd7.jpg]]
			![[NoteAboutStudy/attachments/Pasted image 20260101210545.png]]
如图 8-24 所示为对命令行求值的代码：
1. 首先调用 `parseline` 函数（如图 8-25 所示），该函数解析以空格分割的命令行参数，并构造最终会传递给 `execve` 的 `argv` 向量：
	- 如果最后一个参数是一个 "&" 字符，那么 `parseline` 返回 1，表示应该在后台执行该程序（shell 不会等待它完成，它会返回到循环的顶部，等待下一个命令行）。否则，它返回 0，表示应该在前台执行这个程序（shell 会使用 `waitpid` 函数等待它完成，当完成时，才开始下一轮迭代）；
	- 如果最后一个参数是一个 "&" 字符，它并不出现在最终传给 `execve` 的 `argv` 里，它只是 shell 控制语法，并不是用户程序参数；
2. 在解析了命令行之后，`eval` 函数调用 `builtin_command` 函数，该函数检查第一个命令行参数是否是一个内置的 shell 命令（是否改变 shell 状态）：
	- 如果是，就立即在当前 shell 进程中执行这个命令并返回 1；
	- 否则返回 0；
3. 在检查内置的 shell 命令后，不是内置命令的话则执行 `fork`，给 “用户程序” 一个独立的执行容器（创建子进程），并在这个独立的执行容器中调用 `execve` 来覆盖 `fork` 创建的独立的地址空间从而加载和运行程序（不过，这个简单的 shell 并不能回收它的后台子进程，而修补这个要求使用下一节中所讲述的信号）；

# 8.5 信号
此前讲述了硬件和软件是如何合作以提供基本的低层异常机制以及操作系统如何利用异常来支持进程上下文切换的异常控制流形式。而本节中，将讲述一种更高层的软件形式的异常，称为 **Linux 信号**，它允许进程和内核中断其他进程。

一个信号就是一条消息，它通知进程系统中发生了一个某种类型的事件。如图 8-28 展示了 Linux 系统上支持的 30 种不同类型的信号：
![[NoteAboutStudy/attachments/Pasted image 20260101214400.png]]

每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下对用户进程而言是不可见的。而信号提供了一种机制，通知用户进程发生了这些异常。

---
## 8.5.1 信号术语
