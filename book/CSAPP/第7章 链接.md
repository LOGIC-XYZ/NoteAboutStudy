**链接（linking）** 是把多个代码与数据片段组合成一个可执行文件，使其能够被 **加载**（复制）到内存并执行的过程，可以执行于：
- **编译时（compile time）**：源代码被翻译成机器代码时；
- **加载时（load time）**：程序被 **加载器（loader）** 加载到内存并执行时；
- **运行时（run time）**：由应用程序来执行；
在现代系统中，链接由叫作 **链接器（linker）** 的程序自动执行的。

链接器使 **分离编译（separate compilation）** 成为可能：
- 大型程序可拆分为多个独立的更小、更好管理的模块；
- 可以独立修改和编译这些模块，修改某一模块只需重新编译该模块再链接；
- 不必重新编译全部源文件；

**什么需要理解链接？**
- **处理大型程序中的链接错误**：缺模块、缺库、库版本冲突等；
- **避免隐蔽的错误**：例如多个同名全局变量导致难以调试的运行时问题；
- **理解作用域实现原理**：如 global、local、static 实际影响；
- **理解系统关键机制**：程序加载、虚拟内存、内存映射等都依赖链接器生成的可执行文件；
- **使用共享库的能力**：动态链接带来节省空间、运行时升级、Web 服务动态内容等现代特性；

 本章将基于一个运行 Linux 并使用标准的 ELF-64(此后称为 ELF)的目标文件格式的 x86-64 的系统来讨论关于链接的各个方面，包括：
- 静态链接
- 加载时动态链接（共享库）
- 运行时动态链接（共享库）

---
# 7.1 编译器驱动程序
源代码从 `.c` 文件变成最终可以运行的 **可执行文件**，依靠大多数编译系统所提供的 **编译驱动程序（compiler driver）**，它需要经过多个独立的工具：  **预处理器 → 编译器 → 汇编器 → 链接器**。

但平时在 GNU 编译系统中只需要一句：`gcc -Og -o prog main.c sum.c`，**GCC 驱动程序统一调用了所有步骤**。它收到命令后，会按顺序自动调用：
1. **预处理器 cpp**
2. **编译器 cc1**
3. **汇编器 as**
4. **链接器 ld**
每一步都把上一阶段的输出当成输入，最终生成程序 **prog**。

## 实际流程
下面是 GCC 在构建程序时真实执行的命令（简化版）：

---
### (1) 预处理（cpp）
处理 `#include`、`#define`、删除注释，生成纯 C 文件：
```
cpp main.c → main.i
```
输出：`main.i`（展开完所有宏的 C 代码）

---
### (2) 编译（cc1）
把 C 转成汇编：
```
cc1 main.i → main.s
```
输出：`main.s`（汇编语言文件）

---
### (3) 汇编（as）
把汇编转成机器码，生成可重定位目标文件：
```
as main.s → main.o
```
输出：`main.o`（二进制，未链接）
对 `sum.c` 做同样的流程生成 `sum.o`。

---
### (4) 链接（ld）
把多个 `.o` 文件 + 系统提供的库文件合并，生成最终可执行文件：
```
ld main.o sum.o + system objects → prog
```
这个阶段解决函数调用的地址问题，为程序分配最终内存布局。
输出：`prog`（可执行文件）

---

## 执行：加载器负责把程序搬到内存
当运行：
```sh
./prog
```
shell 会调用 **加载器 loader**：
1. 把可执行文件的代码段、数据段读入内存
2. 设置栈和堆
3. 跳到程序入口点 `_start`
4. 程序开始运行

# 7.2 静态链接
**静态链接器（static linker）** 的输入（如 Linux LD）：
- 一组可重定位目标文件；
	- 各种不同的代码；
	- 各种不同的 **数据节（section）**，每一节都是一个连续的字节序列：
		- 指令在一节中；
		- 已初始化的全局变量在另一节中；
		- 未初始化的变量在另外一节中；
	- 引导链接器和加载器的数据结构；
- 命令行参数；
输出：一个完全链接的、可以加载和运行的可执行目标文件。

为了构造可执行文件，连接器必须完成两个主要任务：
- **符号解析（symbol resolution）**。目标文件定义和引用的 **符号**，每个符号对应于一个函数、一个全局变量或一个静态变量。而符号解析的目的就是将每个符号的 **引用** 和一个符号的 **定义** 关联起来；
- **重定位（relocation）** 。编译器和汇编器生成的是从地址 0 开始的代码和数据节（地址为假）。链接器通过把每个符号定义与一个内存位置关联起来，从而 **重定位** 这些节，然后修改所有对这些符号的引用，使得它们指向真实地址。（链接器使用汇编器产生的 **重定位条目 relocation entry** 的详细指令，直接执行）；

接下来的章节将更详细地描述这些实现，**本质上，目标文件就是一堆 “字节块” 的集合**，这些字节块分成几类：
- “代码块”；
- “数据块”（已初始化/未初始化）；
- “元数据块”（符号表、重定位表等）；
    
链接器所做的就是：
1. 按照规则把这些区块串接在一起；
2. 为每个块决定最终的内存位置；
3. 修改代码里的地址引用，让它们指向正确的真实地址；

链接器不是编译器，不负责生成指令，只是“把别人生成的片段拼起来”。

编译器 + 汇编器 会：
- 生成指令机器码；
- 决定局部变量布局；
- 决定函数栈帧结构；
- 创建重定位条目（告诉链接器具体该改哪里）；
    
链接器则按规则修改这些已准备好的机器码片段，但不会理解指令内容。

# 7.3 目标文件
目标文件有三种形式：
- **可重定位目标文件** -- 包含二进制代码和数据，由 **编译器/汇编器** 产生，不能直接执行，内部地址不是实际地址，等待链接器统一分配，其形式可以与其他可重定位目标文件合并起来，创建一个可执行目标文件；
- **可执行目标文件** -- 包含二进制代码和数据，由 **链接器** 产生，内部地址都是实际运行地址，其形式可以被直接加载到内存并执行；
- **共享目标文件** -- 一种特殊类型的可重定位目标文件，由 **编译器/汇编器** 产生，可以在加载或者运行时被动态地加载进内存并链接；

从技术上来说：
- **目标模块（object module）**：纯字节序列，本质就是一堆二进制数据。
- **目标文件（object file）**：把字节序列存成磁盘文件（`.o`、`.so`、`a.out`）。
实际使用中，书上会混用这两个词，不需要纠结本质差别。

> 目标文件是按照特定的目标文件格式来组织的，不同系统使用不同的目标文件格式，但结构思想相同。

常见目标文件格式：

|系统|格式|
|---|---|
|早期 Unix|`a.out`|
|Windows|PE（Portable Executable）|
|macOS|Mach-O|
|Linux / 现代 Unix|ELF（Executable and Linkable Format）|

# 7.4 可重定位目标文件
## 1. 整体结构：ELF 文件的布局
![[NoteAboutStudy/attachments/Pasted image 20251128220105.png]]
如图 7-3 为一个典型的 ELF 可重定位目标文件的格式。**ELF 头（ELF header）** 以一个 16 字节的序列开始在最前，**节头部表（section header table）** 在最后，中间夹着各种节（section）。

## 2. ELF 头
这个部分负责让链接器能解析、遍历文件结构，包含：
- 文件使用的字长（32/64 bit）
- 字节序（小端/大端）
- 文件类型（relocatable / executable / shared）
- 目标机器架构（如 x86-64）
- 节头部表的偏移地址
- 节头部表中条目的大小与数量

## 3. 节头部表
目标文件中每个节在节头部表中都有一个固定大小的条目（entry），记录：
- 每个节的名字
- 文件偏移
- 内存地址（如果可执行）
- 大小
- 标志位（可读/可写/可执行）

## 4. 典型的 ELF 可重定位文件所包含的节
- `.text` -- 已编译程序的机器代码，包含函数的指令；
- `.rodata` -- 只读数据（常量），比如字符串字面量、`printf` 格式串、switch 的跳转表；
- `.data` -- **已初始化**的全局变量和静态变量（局部变量在运行时被保存在栈中，既不出现在 `.data` 节中，也不出现在  `.bss` 节中）；
- `.bss` -- **未初始化**的全局变量或静态变量以及所有被初始化为 **0** 的全局或静态变量（`.bss` 在文件中不占实际空间，只是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据实际的磁盘空间，运行时系统会分配内存并设置初始值为 0）；
- `.symtab` -- 一个符号表，用于支持链接器的符号解析，包含全局变量、函数、静态变量（文件作用域），**不包含局部变量**，无需 `-g` 默认就有符号表信息，除非显式地用 STRIP 命令去除；
- `.rel.text` -- 一个 `.text` 节中位置的列表，记录其中哪些位置的指令需要在链接时被 “修正“（一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息）；
- `.rel.data` -- 记录 `.data` 中哪些内容引用了外部符号（外部定义函数或全局变量）；
- `.debug` -- 一个调试符号表，只有使用 `-g` 编译时才生成，包含程序中定义的局部变量和类型定义、程序中定义和引用的全局变量、原始的源文件内容等，被调试器使用，不参与链接；
- `.line` -- 原始源程序中的行号和 `.text` 节中的机器指令之间的映射，只有使用 `-g` 调用编译器驱动程序时才生成；
- `.strtab` -- 一个字符串表，存储：`.symtab` 中符号的名字、`.debug` 中的名字以及各 section 的名字，字符串表由一系列以 `\0` 结尾的字符串组成；

# 7.5 符号和符号表

# 7.6 符号解析

# 7.7 重定位

# 7.8 可执行目标文件

# 7.9 加载可执行目标文件

# 7.10 动态链接共享库

# 7.11 从应用程序中加载和链接共享库

# 7.12 位置无关代码

# 7.13 库打桩机制

# 7.14 处理目标文件的工具

# 7.15 小结
