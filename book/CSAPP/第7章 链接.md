**链接（linking）** 是把多个代码与数据片段组合成一个可执行文件，使其能够被 **加载**（复制）到内存并执行的过程，可以执行于：
- **编译时（compile time）**：源代码被翻译成机器代码时；
- **加载时（load time）**：程序被 **加载器（loader）** 加载到内存并执行时；
- **运行时（run time）**：由应用程序来执行；
在现代系统中，链接由叫作 **链接器（linker）** 的程序自动执行的。

链接器使 **分离编译（separate compilation）** 成为可能：
- 大型程序可拆分为多个独立的更小、更好管理的模块；
- 可以独立修改和编译这些模块，修改某一模块只需重新编译该模块再链接；
- 不必重新编译全部源文件；

**什么需要理解链接？**
- **处理大型程序中的链接错误**：缺模块、缺库、库版本冲突等；
- **避免隐蔽的错误**：例如多个同名全局变量导致难以调试的运行时问题；
- **理解作用域实现原理**：如 global、local、static 实际影响；
- **理解系统关键机制**：程序加载、虚拟内存、内存映射等都依赖链接器生成的可执行文件；
- **使用共享库的能力**：动态链接带来节省空间、运行时升级、Web 服务动态内容等现代特性；

 本章将基于一个运行 Linux 并使用标准的 ELF-64(此后称为 ELF)的目标文件格式的 x86-64 的系统来讨论关于链接的各个方面，包括：
- 静态链接
- 加载时动态链接（共享库）
- 运行时动态链接（共享库）

---
# 7.1 编译器驱动程序
源代码从 `.c` 文件变成最终可以运行的 **可执行文件**，依靠大多数编译系统所提供的 **编译驱动程序（compiler driver）**，它需要经过多个独立的工具：  **预处理器 → 编译器 → 汇编器 → 链接器**。

但平时在 GNU 编译系统中只需要一句：`gcc -Og -o prog main.c sum.c`，**GCC 驱动程序统一调用了所有步骤**。它收到命令后，会按顺序自动调用：
1. **预处理器 cpp**
2. **编译器 cc1**
3. **汇编器 as**
4. **链接器 ld**
每一步都把上一阶段的输出当成输入，最终生成程序 **prog**。

## 实际流程
下面是 GCC 在构建程序时真实执行的命令（简化版）：

---
### (1) 预处理（cpp）
处理 `#include`、`#define`、删除注释，生成纯 C 文件：
```
cpp main.c → main.i
```
输出：`main.i`（展开完所有宏的 C 代码）

---
### (2) 编译（cc1）
把 C 转成汇编：
```
cc1 main.i → main.s
```
输出：`main.s`（汇编语言文件）

---
### (3) 汇编（as）
把汇编转成机器码，生成可重定位目标文件：
```
as main.s → main.o
```
输出：`main.o`（二进制，未链接）
对 `sum.c` 做同样的流程生成 `sum.o`。

---
### (4) 链接（ld）
把多个 `.o` 文件 + 系统提供的库文件合并，生成最终可执行文件：
```
ld main.o sum.o + system objects → prog
```
这个阶段解决函数调用的地址问题，为程序分配最终内存布局。
输出：`prog`（可执行文件）

---

## 执行：加载器负责把程序搬到内存
当运行：
```sh
./prog
```
shell 会调用 **加载器 loader**：
1. 把可执行文件的代码段、数据段读入内存
2. 设置栈和堆
3. 跳到程序入口点 `_start`
4. 程序开始运行

# 7.2 静态链接
**静态链接器（static linker）** 的输入（如 Linux LD）：
- 一组可重定位目标文件；
	- 各种不同的代码；
	- 各种不同的 **数据节（section）**，每一节都是一个连续的字节序列：
		- 指令在一节中；
		- 已初始化的全局变量在另一节中；
		- 未初始化的变量在另外一节中；
	- 引导链接器和加载器的数据结构；
- 命令行参数；
输出：一个完全链接的、可以加载和运行的可执行目标文件。

为了构造可执行文件，链接器必须完成两个主要任务：
- **符号解析（symbol resolution）**。目标文件定义和引用的 **符号**，每个符号对应于一个函数、一个全局变量或一个静态变量。而符号解析的目的就是将每个符号的 **引用** 和一个符号的 **定义** 关联起来；
- **重定位（relocation）** 。编译器和汇编器生成的是从地址 0 开始的代码和数据节（地址为假）。链接器通过把每个符号定义与一个内存位置关联起来，从而 **重定位** 这些节，然后修改所有对这些符号的引用，使得它们指向真实地址。（链接器使用汇编器产生的 **重定位条目 relocation entry** 的详细指令，直接执行）；

接下来的章节将更详细地描述这些实现，**本质上，目标文件就是一堆 “字节块” 的集合**，这些字节块分成几类：
- “代码块”；
- “数据块”（已初始化/未初始化）；
- “元数据块”（符号表、重定位表等）；
    
链接器所做的就是：
1. 按照规则把这些区块串接在一起；
2. 为每个块决定最终的内存位置；
3. 修改代码里的地址引用，让它们指向正确的真实地址；

链接器不是编译器，不负责生成指令，只是“把别人生成的片段拼起来”。

编译器 + 汇编器 会：
- 生成指令机器码；
- 决定局部变量布局；
- 决定函数栈帧结构；
- 创建重定位条目（告诉链接器具体该改哪里）；
    
链接器则按规则修改这些已准备好的机器码片段，但不会理解指令内容。

# 7.3 目标文件
目标文件有三种形式：
- **可重定位目标文件** -- 包含二进制代码和数据，由 **编译器/汇编器** 产生，不能直接执行，内部地址不是实际地址，等待链接器统一分配，其形式可以与其他可重定位目标文件合并起来，创建一个可执行目标文件；
- **可执行目标文件** -- 包含二进制代码和数据，由 **链接器** 产生，内部地址都是实际运行地址，其形式可以被直接加载到内存并执行；
- **共享目标文件** -- 一种特殊类型的可重定位目标文件，由 **编译器/汇编器** 产生，可以在加载或者运行时被动态地加载进内存并链接；

从技术上来说：
- **目标模块（object module）**：纯字节序列，本质就是一堆二进制数据。
- **目标文件（object file）**：把字节序列存成磁盘文件（`.o`、`.so`、`a.out`）。
实际使用中，书上会混用这两个词，不需要纠结本质差别。

> 目标文件是按照特定的目标文件格式来组织的，不同系统使用不同的目标文件格式，但结构思想相同。

常见目标文件格式：

|系统|格式|
|---|---|
|早期 Unix|`a.out`|
|Windows|PE（Portable Executable）|
|macOS|Mach-O|
|Linux / 现代 Unix|ELF（Executable and Linkable Format）|

# 7.4 可重定位目标文件
## 1. 整体结构：ELF 文件的布局
![[NoteAboutStudy/attachments/Pasted image 20251128220105.png]]
如图 7-3 为一个典型的 ELF 可重定位目标文件的格式。**ELF 头（ELF header）** 以一个 16 字节的序列开始在最前，**节头部表（section header table）** 在最后，中间夹着各种节（section）。

## 2. ELF 头
这个部分负责让链接器能解析、遍历文件结构，包含：
- 文件使用的字长（32/64 bit）
- 字节序（小端/大端）
- 文件类型（relocatable / executable / shared）
- 目标机器架构（如 x86-64）
- 节头部表的偏移地址
- 节头部表中条目的大小与数量

## 3. 节头部表
目标文件中每个节在节头部表中都有一个固定大小的条目（entry），记录：
- 每个节的名字
- 文件偏移
- 内存地址（如果可执行）
- 大小
- 标志位（可读/可写/可执行）

## 4. 典型的 ELF 可重定位文件所包含的节
- `.text` -- 已编译程序的机器代码，包含函数的指令；
- `.rodata` -- 只读数据（常量），比如字符串字面量、`printf` 格式串、switch 的跳转表；
- `.data` -- **已初始化**的全局变量和静态变量（局部变量在运行时被保存在栈中，既不出现在 `.data` 节中，也不出现在  `.bss` 节中）；
- `.bss` -- **未初始化**的全局变量或静态变量以及所有被初始化为 **0** 的全局或静态变量（`.bss` 在文件中不占实际空间，只是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据实际的磁盘空间，运行时系统会分配内存并设置初始值为 0）；
- `.symtab` -- 一个符号表，用于支持链接器的符号解析，包含全局变量、函数、静态变量（文件作用域），**不包含局部变量**，无需 `-g` 默认就有符号表信息，除非显式地用 STRIP 命令去除；
- `.rel.text` -- 一个 `.text` 节中位置的列表，记录其中哪些位置的指令需要在链接时被 “修正“（一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息）；
- `.rel.data` -- 记录 `.data` 中哪些内容引用了外部符号（外部定义函数或全局变量）；
- `.debug` -- 一个调试符号表，只有使用 `-g` 编译时才生成，包含程序中定义的局部变量和类型定义、程序中定义和引用的全局变量、原始的源文件内容等，被调试器使用，不参与链接；
- `.line` -- 原始源程序中的行号和 `.text` 节中的机器指令之间的映射，只有使用 `-g` 调用编译器驱动程序时才生成；
- `.strtab` -- 一个字符串表，存储：`.symtab` 中符号的名字、`.debug` 中的名字以及各 section 的名字，字符串表由一系列以 `\0` 结尾的字符串组成；

# 7.5 符号和符号表
每个可重定位目标模块都有一个符号表，它包含该模块定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：
- 由该模块定义并且能被其他模块引用的 **全局符号**。全局链接器符号对应于 **非静态的** 函数和全局变量；
- 由其他模块定义并被该模块所引用的 **全局符号**。这些符号称为 **外部符号**，对应于其他模块中定义的 **非静态的** 函数和全局变量；
- 只被当前模块定义和引用的 **局部符号**。对应于带 **static** 属性的函数和全局变量，只能被当前模块使用，不能被其他模块引用；

> `.symtab` 中的符号表不包含 **局部的非静态变量**，在运行时由栈管理。

而对于带 static 属性的局部变量，编译器在 `.data` 或 `.bss` 中为它的定义分配空间，并在符号表中创建一个有唯一名字的局部链接器符号（若在同一模块的两个函数中各自定义了一个静态局部变量，则编译器会向汇编器输出两个不同名字的局部链接器符号）。

> [!tip]- 利用 static 属性隐藏变量和函数名字
> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像在 Java 和 C++ 中使用 public 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有  static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来保护变量和函数是很好的编程习惯。

符号表是由汇编器构造的，使用编译器输出到汇编语言 `.s` 文件中的符号。`.symtab` 节中包含 ELF 符号表。每一个符号都是一个条目。如图 7-4 展示了每个条目的格式。
![[NoteAboutStudy/attachments/Pasted image 20251129175621.png]]

| 字段        | 意义                                            |
| --------- | --------------------------------------------- |
| `name`    | 字符串表中的偏移 → 指向符号的以 `null` 结尾的字符串名字             |
| `value`   | 该符号的地址（可重定位时是相对当前节开头的偏移，对于可执行文件来说是一个绝对运行时的地址） |
| `size`    | 大小（字节数）                                       |
| `type`    | 函数 / 对象（变量）                                   |
| `binding` | 局部 / 全局                                       |
| `section` | 该符号属于哪个节                                      |

> 每个符号都被分配到目标文件的某个节，由 `section` 字段表示，该字段也是一个到节头部表的索引。

有三个特殊的伪节（pseudosection），在节头部表中是没有条目的：
- `ABS` - 不能被重定位的符号；
- `UNDEF` - 未定义的符号（在该目标模块中引用，但是在其他模块中定义的符号）；
- `COMMON` - 未分配位置的未初始化的数据目标（`value` 字段给出对齐要求，而 `size` 给出最小的大小）
只有可重定位目标文件中才有这些伪节，可执行目标文件中并没有。

`COMMON` 和 `.bss` 的区别很细微，现代的 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 `COMMON` 和 `.bss` 中：
- `COMMON` -- 未初始化的全局变量；
- `.bss` -- 未初始化的静态变量，以及初始化为 0 的全局或静态变量；
采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，将会在  7.6 节中加以解释。

GNU READELF 程序是一个查看目标文件内容的很方便的工具。

# 7.6 符号解析
链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来：
- 对那些和引用定义在相同模块中的局部符号的引用（包括 static 变量和 static 函数）：
	- 编译器只允许每个模块中每个局部符号有一个定义；
	- 静态局部变量会编译成具有唯一名称的本地链接器符号；
	- 链接器直接在本模块中找到它们，不会冲突；
- 对于全局符号的引用解析：
	- **外部引用需要在其他模块中找到定义** -- 当编译器看到一个“当前模块未定义的名字”，它会先把它当成 “别的模块会定义” 的外部符号，然后在符号表中生成一条 “未定义符号（UNDEF）” 记录，最后交给链接器解决（链接器如果最终找不到定义 → 报错）；
	- **多个模块可能重复定义同名全局符号** -- 此时，链接器必须决定是 **报错** 还是 **选择一个定义，丢弃其他定义**（在 Linux ELF/GCC 中，这件事涉及 C 语言规则 + 编译器 + 汇编器 + 链接器三方协作，可能导致意料之外的 “符号覆盖” 问题）；

> [!tip]- 对 C++ 和 Java 中链接器符号的重整
> C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做 重整(mangling)，而相反的过程叫做 恢复(demangling)。
> 
> 幸运的是，C++ 和 Java 使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo::bax(int, long) 被编码为 bar__3Fooil。重整全局变量和模板名字的策略是相似的。

---
## 7.6.1 链接器如何解析多重定义的全局符号
可重定位目标文件中可能出现多个模块定义同名全局符号的问题。为了保持可控性，Linux/GCC/ELF 工具链对“如何选择最终定义”制定了明确的规则，下面是 Linux 编译系统采用的方法：
- 在编译时，编译器向汇编器输出每个全局符号，要么是 **强符号** 要么是 **弱符号**，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里 -- **函数和已初始化的全局变量** 是强符号，**未初始化的全局变量** 是弱符号；
- 根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：
	- 规则一 -- **不允许有多个同名的强符号**（这是为了保证全局变量、函数的唯一性）；
	- 规则二 -- **如果有一个强符号和多个弱符号同名，选择强符号**；
	- 规则三 -- **如果有多个弱符号同名，那么链接器从这些弱符号中任选一个，**（潜在危险点）；

> 因为不同模块对同名变量的定义可能不一致，故规则三可能会导致 bug，且构建顺序一变就有可能触发或消失、运行时表现与出错点距离极远、链接器只给出一个对齐警告，因此难以发现与修复。此时就可以：
> - 让编译器将未初始化的全局变量也视为强符号；
> - 将警告变成错误；

在上一节（7.5）中讲述了编译器按照一个规则来把符号分配为 **COMMON** 和 `.bss`，采用这个惯例的原因是
- **未初始化的全局变量** 是弱符号，可能在多个模块中被多次定义。编译器无法确定最终采用哪个定义，也无法确定大小和对齐，只能把决定权交给链接器，因此放入 COMMON；
- 已初始化变量（包括初始化为 0）是强符号，唯一，可直接放 .bss/.data；
- 静态变量永远唯一，也可直接放 .bss/.data；

## 7.6.2 与静态库链接
迄今为止，都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为 **静态库(static library)**，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

如果没有库，一些函数就无法使用，此时，有三种方案可以在不使用静态库的情况下提供函数：
- 让编译器辨认出对标准函数的调用，并直接生成相应的代码（Pascal 只提供一小部分标准函数，所以采用这种方案），但是
	- C 的函数太多，需要写一堆内建支持 → 编译器臃肿；
	- 任何标准函数变动都要重写编译器 → 崩溃；
	- 所有程序把所有函数“编译进去” → 内存/磁盘浪费；
- 将所有的标准 C 函数都放在一个单独的可重定位目标模块中，这样只链接这个模块到可执行文件中就行了，但是
	- 每个程序都要在可执行文件里包含一份标准函数集合的完全副本，对于磁盘空间来说很浪费；
	- 每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费；
	- 对任何标准函数的任何改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂；
- 可以通过为每个标准函数创建一个独立的可重定位文件（.o 文件），但是
	- 程序员必须手动列出所有依赖，极易出错且耗费时间；

静态库概念被提出来，以解决这些不同方法的缺点：**相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件**。然后，应用程序就可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数：
- 在链接时，链接器将 **只复制被程序引用的目标模块**，这就减少了可执行文件在磁盘和内存中的大小；
- 应用程序中只需要包含较少的库文件的名字；

在 Linux 系统中，静态库以一种称为 **存档(archive)** 的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 `.a` 标识，可使用 AR 工具创建。

## 7.6.3 链接器如何使用静态库来解析引用
在符号解析阶段，链接器采用 **从左到右** 出现在编译器驱动程序命令行的顺序来扫描可重定位文件和存档文件，在扫描过程中，会维护三个集合，初始化皆为空：
- E：最终会被加入可执行文件的可重定位目标文件的集合；
- U：目前为止遇到的 "未解析符号" 的集合（引用了但尚未定义的符号）；
- D：目前已经出现过的 "已定义符号" 集合；

对于命令行上的每个输入文件，链接器首先会判断它是一个目标文件还是一个存档文件：
- 如果是一个目标文件，
	- 那么链接器会把它添加到 E 中，并修改 U 和 D 来反映该目标文件中的符号定义和引用，然后继续下一个输入文件；
- 如果是一个存档文件，
	- 那么链接器会尝试匹配 U 中为解析的符号和由存档文件成员所定义的符号；
	- 如果某个存档文件成员定义了一个符号来解析 U 中的一个引用，那么就把这个存档文件成员加到 E 中，并修改 U 和 D 来反映该存档文件成员中的符号定义和引用；
	- 对存档文件中所有的成员目标文件都依次进行上一条的过程，直到 U 和 D 都不再发生变化，此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，任何继续处理下一个输入文件；
如果当链接器完成对命令行上输入文件的扫描后，U 是 非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，并构建输出的可执行文件。

> **静态库必须出现在引用它的目标文件之后**
    因为链接器不会 “回头找库”，它只在处理库的那一刻查看 U 中是否有未解析符号。

> **如果库之间存在依赖时还必须排序**

> **如果两个库循环依赖**
> - 命令行重复库
> - 把两个库合并成一个

# 7.7 重定位
当链接器完成了符号解析这一步（把代码中的每个符号引用和一个符号定义关联起来），此时链接器知道所有输入模块的代码段、数据段的大小，因此可以开始 **重定位（relocation）**，在此期间，将合并输入模块，并为每个符号分配运行地址，包含两个步骤：
- **重定位节和符号定义**。链接器将所有相同类型的节合并为同一类型的新的聚合节，然后将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号 -- 此时，程序中的每条指令和全局变量都有唯一的运行时地址；
- **重定位节中的符号引用**。链接器修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址（依赖于可重定位目标模块中称为 **重定位条目** 的数据结构）；

---
## 7.7.1 重定位条目
当汇编器生成一个目标模块时，可能：
- **不知道代码最终会被放到内存中的什么位置**；
- **不知道外部函数或全局变量（在其他文件中定义）的位置**；
因此，当汇编器遇到一个对 “位置” 未知的目标引用时，首先生成一个 **重定位条目（relocation entry）**，告诉链接器在将目标文件合并成可执行文件时该如何修改这个引用。

ELF 中：
- **代码 section（.text） 的重定位条目** 放在 `.rel.text`；
- **已初始化数据 section（.data） 的重定位条目** 放在 `.rel.data`；

![[NoteAboutStudy/attachments/Pasted image 20251201223202.png]]
如图 7-9 所示，`offset` 是需要被修改的引用的节偏移。`symbol` 标识被修改引l用应该指向的符号。`type` 告知链接器如何修改新的引用。`addend` 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

ELF 定义了 32 种不同的重定位类型，有些相当隐秘。本书只讲述其中两种最基本的重定位类型：
- R_X86_64_PC32。对 **32 位 PC 相对寻址** 的引用进行重定位；
- R_X86_64_32。**32 位绝对地址** 的重定位；
这两种重定位类型支持 **x86-64 小型代码模型（small code model）**，该模型假设可执行目标文件中的代码和数据的总体大小小于 2GB，因此在运行时可以用 32 位 PC 相对地址来访问。 GCC 默认使用小型代码模型。大于 2GB 的程序可以用 `-mcmodel = medium`（中型代码模型）和 `-mcmodel = large`（大型代码模型）标志来编译，不过本书在此不讨论这些模型。

## 7.7.2 重定位符号引用
当链接器进入重定位阶段时，它已经知道：
- 每个节（.text、.data …）最终在可执行文件中的起始运行时地址 `ADDR(s)`
- 每个符号（函数、全局变量）的最终运行时地址 `ADDR(symbol)`
接下来它要做的，就是把**目标文件里的所有“引用符号的地方”改成正确的地址**。这些“待修改的地方”由**重定位条目（relocation entry）** 指定，每一个重定位条目告诉链接器：
- 代码或数据中的哪 4 字节（或 8 字节）需要修改
- 这个引用使用的是 **PC 相对寻址** 还是 **绝对寻址**
- 这个引用应该指向哪个符号

![[NoteAboutStudy/attachments/Pasted image 20251202211828.png]]
如图 7-10 展示了链接器的重定位算法的伪代码（同时本书也通过具体实例讲述这两种方式 -- P480）：
1. PC 相对寻址（`R_X86_64_PC32`）
	- 目标：让指令中的 32-bit 偏移量，使得运行时 -- PC + 偏移量 = 要跳转的目标地址；
	- 链接器填入 -- offset = 目标地址 - (当前指令后面一条指令的地址) + addend，也就是伪代码中的 `*refptr = ADDR(symbol) + addend - refaddr`（其中 `refaddr` = 这条指令后面紧随的指令地址）；
2. 绝对寻址（`R_X86_64_32`）
	- 目标：把立即数直接替换成符号的绝对地址；
	- 链接器填入 -- `*refptr = ADDR(symbol) + addend`；

所有重定位完成后：
- `.text` 节变成 “可直接执行的机器码”；
- `.data` 节也完全带有正确地址；
- 加载器把节复制进内存，不再做修改；
程序即可运行。

# 7.8 可执行目标文件
![[NoteAboutStudy/attachments/Pasted image 20251202212838.png]]
如图 7-13 所示，可执行目标文件的格式类似于可重定位目标文件的格式，但：

|可重定位目标文件（.o）|可执行文件（a.out / prog）|
|---|---|
|符号未最终确定，仍需重定位|所有符号已确定，已完成重定位|
|每个 section 独立存在|会组合成可加载的 memory segments|
|没有入口点|有入口点（entry point），程序从这执行|
可执行文件包含：
- **ELF 头** -- 描述文件的总体格式，包括程序的入口点（当程序运行时要执行的第一条指令的地址）、程序头部表偏移位置、段和节的布局信息；
- **程序头部表（program header table，即图中的段头部表）** ← _这是执行需要的_
- 各种已重定位完成的 section，例如  
    `.text, .rodata, .data, .bss`
- `.init` 节定义了一个名为 `_init` 的函数，程序的初始化代码会调用它；
- **不再包含 .rel sections**，因为可执行文件是完全链接的（已被重定位），不再需要了；

可执行文件的连续的片被映射到连续的内存段中，因此 ELF 可执行文件可以很容易地加载到内存，而程序头部表描述了这种映射关系（书中展示了 可执行文件 `prog` 的程序头部表的两个内存段 - P483）。

可执行文件能 “一次性” 加载到内存，因为：
- **把 section 合并成两个 segment**
	- 所有可执行代码 + 只读数据 → text segment；
	- 所有全局可写数据 → data segment；
- **选择 segment 的虚拟地址，使其满足对齐要求**
	- `vaddr mod align = off mod align`（`vaddr` = 段的起始虚拟地址、`off` = 段在文件中的起始偏移、`align` = 在 Program Header 中规定的对齐）；

而对齐是因为操作系统的虚拟内存是按 **页面（page）** 组织的，常见页大小 -- 4KB，但 ELF 允许段按更大的对齐，例如 2MB（Huge Pages）。**如果文件偏移与虚拟地址满足对齐规则，加载器就可以直接把文件内容映射到内存，而不需要额外复制或调整。** 这将极大提升：加载速度、页面缓存（page cache）效率、内存映射的简洁性，将在第 9 章总讲述虚拟内存相关的知识。

# 7.9 加载可执行目标文件
当要运行可执行目标文件时，可以直接在 Shell 的命令行总输入它的名字（地址要传达正确，否则会找不到），此时，Shell 会调用某个驻留在存储器中称为 **加载器（loader）** 的操作系统代码来运行它，加载器的任务有两个：
1. 把可执行文件的代码和数据从磁盘复制到内存；
2. 跳转到程序的第一条指令或入口点开始执行该程序；
而任何 Linux 程序都可以通过调用 `execve` 函数来调用加载器（将在 8.4.6 节中详细描述这个函数，shell 内部其实也是调用这个系统调用） 。

每个 Linux 程序都有一个运行时内存映像，类似图 7-15 所示（顺序固定，具体地址因 ASLR 不固定）：
![[NoteAboutStudy/attachments/Pasted image 20251202222730.png]]
- **代码段** 从 **0x400000** 开始，是 Linux x86-64 的默认加载地址，后面是数据段；
- **堆** 自底向上增长（由 malloc 扩展），堆在数据段之后（将在 9.9 节中详细描述 `malloc` 和堆）；
- **栈** 自顶向下增长（从最高的合法用户地址 $2^{48}-1$ 开始）;
- **共享库**（如 libc.so）加载在堆和栈之间；
- 从地址 $2^{48}$ 开始，是为 **内核（kernel -- 操作系统驻留在内存的部分）** 中的代码和数据保留的；
- **ASLR（地址空间布局随机化，详情请看 3.10.4 节）** 会随机化这些区域的实际地址，但相对顺序不变；
为了简洁，图中堆、数据段和代码段彼此相邻，并把栈顶放在了最大的合法用户地址处，实际上，由于 `.data` 段有对齐要求（如 上一节 7.8 节所述），代码段和数据段之间有空隙。

当加载器运行时，它将创建类似 图 7-15 所示的内存映像：
1. 在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段；
2. 加载器跳转到程序的入口点，也就是 `_start` 函数的地址（在系统目标文件 `ctrl.o` 中定义）；
3. `_start` 函数调用系统启动函数 `__libc_start_main`（定义在 `libc.so`中），该函数初始化执行函数，调用用户层的 `main` 函数，处理 `main` 函数的返回值，并把控制权还给内核；

> [!important]- 加载器实际是如何工作的
> Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，parent shell 进程生成一个子进程，它是 parent 进程的一个复制。子进程通过 `execve` 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的 片（chunk），新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到 `_start` 地址，它最终会调用应用程序的 `main` 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

# 7.10 动态链接共享库
## 1. 静态库的问题
静态库编译时需要把库中的代码复制进每个可执行文件中，因此会导致一些缺点：
- **更新困难**：库更新后，应用必须重新链接；
- **浪费内存**：几乎所有程序都用 `printf`、`scanf`，如果每个进程都嵌入一份，那么系统内存中将会有一堆重复的代码（而内存资源很稀缺）；

## 2. 共享库
**共享库（shared library）** 是致力于解决静态库缺陷的一个现代创新产物：
- 是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程称为 **动态链接**，由 **动态链接器** 来执行；
- 也称为 **共享目标（shared object）**，在 Linux 系统中通常用 `.so` 后缀来表示，微软的操作系统大量地使用了共享库，称为 DLL(动态链接库)；
通过两种不同的方式来 “共享”：
- 对于一个库只有一个 `.so` 文件，所有引用该库的可执行目标文件共享这个 `.so` 文件中的代码和数据；
- 在内存中，一个共享库的 `.text` 节的一个副本可以被多个正在运行的进程共享；

## 3. 如何生成共享库
例如生成 libvector.so：
```sh
gcc -shared -fpic -o libvector.so addvec.c multvec.c
```
- `-fpic`：生成位置无关代码（PIC），使共享库能加载到任意地址
- `-shared`：让链接器输出一个共享目标文件 `.so`
然后将它链接到应用程序：
```sh
gcc -o prog2l main2.c ./libvector.so
```
**注意：此时共享库的代码并未复制进可执行文件**，可执行文件仅保存：
- 对库中符号的引用；
- 相关的重定位信息；
- 稍后加载动态链接器所需的信息；

## 4. 运行时如何链接动态链接
当运行某个程序时，如：
```sh
./prog2l
```
因为可执行文件包含 `.interp` 段，其中保存 **动态链接器的路径**，加载器不会马上跳到 `_start`，而是先加载 `prog2l`，然后根据 `.interp` **加载动态链接器**，并将控制权移交给动态链接器，然后动态链接器通过执行下面的重定位完成链接任务：
- 重定位 `libc.so` 的文本的数据到某个内存段；
- 重定位 `libvector.so` 的文本和数据到另一个内存段；
- 重定位 `prog2l` 中所有对 `libc.so` 和 `libvector.so` 定义的符号的引用；
最后，动态链接器将控制传递给应用程序（跳转到可执行文件的入口点）。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

# 7.11 从应用程序中加载和链接共享库
上一节讲述的是动态链接发生在：
- 程序刚被加载进内存；
- 程序尚未开始运行；
而本节讨论的是：在程序 **运行过程中**，要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。

---
## 1. 为什么需要在运行时动态链接
这类技术在现实软件中非常常见，并且功能十分强大：
- **分发软件**。微软 Windows 应用的开发者常常利用共享库来分发软件更新，开发者发布新的 DLL，用户替换这个 DLL 文件，下次启动程序时，应用将自动链接和加载新的共享库，而无需重新编译可执行文件；
- **构建高性能 Web 服务器**。许多 Web 服务器生成动态内容，比如个性化的 Web 页面、账户余额和广告标语，可以使用基于动态链接的更有效和完善的方法来生成动态内容，将每个生成动态内容的函数打包在共享库中，当一个来自 Web 浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，在运行时无需停止服务器；

## 2. Linux 提供的运行时动态链接接口
Linux 系统为动态链接提供一些简单的接口，允许应用程序在运行时加载和链接共享库，这些接口统一在 `<dlfcn.h>` 中：

---
### `dlopen` -- 加载共享库
```c
void *dlopen(const char *filename, int flag);
```
返回：
- 成功 → 指向句柄的指针
- 失败 → NULL
该函数加载和链接共享库 `filename`，使用已经用带 `RTLD_GLOBAL` 选项（该选项表明该库的符号可被后续加载的库使用）打开了的库解析该共享库中的外部符号。
- 若当前可执行文件是带 `-rdynamic` 选项编译的，那么对符号解析而言，它的全局符号是可用的；
- 对于 `flag` 参数，要么包括 `RTLD_NOW`（立即解析库中所有未解析的符号），要么包括 `RTLD_LAZY`（只有在真正调用函数时才解析符号 - 常用于性能），这两个都可以和 `RTLD_GLOBAL` 标志取或（注意：`RTLD_NOW` 与 `RTLD_LAZY` 必须二选一）；

### `dlsym` -- 取符号地址（函数指针、全局变量等）
```c
void *dlsym(void *handle, char *symbol);
```
返回：
- 成功 → 指向符号的地址（函数指针等）
- 失败 → NULL
`dlsym` 函数的输入是一个指向前面已经打开了的共享库的句柄和一个 `symbol` 名字。

### `dlclose` -- 卸载共享库
```c
int dlclose(void *handle);
```
若没有其他库依赖此库，则卸载，反之不会立即卸载。
    
返回：
- 成功 → 0
- 出错 → -1

### `dlerror` -- 返回错误信息
```c
const char *dlerror(void);
```
如果最近一次 `dlopen/dlsym/dlclose` 出错，返回描述字符串，没有就返回 NULL。

# 7.12 位置无关代码
共享库的一个主要目的就是允许多个正在运行的进程共享内存中系统的库代码，来节约内存资源，因此它的代码段必须能被多个进程映射到同一份内存页面，使得可以把代码段加载到内存的任何位置且无需链接器修改（每个进程仍然有自己的读/写数据块）。

可以被加载而无需重定位的代码称为 **位置无关代码（Position-Independent Code，PIC）**。GCC 用 `-fpic` 选项指示 GNU 编译系统生成 PIC 代码（共享库的编译必须使用该选项）。

在 x86-64 系统中对同一个目标模块中的符号引用，可以用 **PC 相对寻址** 来编译这些引用，构造目标文件时由静态链接器重定位，而 **对共享模块定义的外部过程** 和 **对全局变量** 的引用需要一些机制：

---
## 1. PIC 数据引用
无论在内存中的何处加载一个目标模块（包括共享目标模块），**数据段与代码段的距离总是保持不变**。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个常量，与代码段和数据段的绝对内存位置是无关的。

想要生成对全局变量 PIC 引用的编译器通过这个，在数据段开始的地方创建一张表，称为 **全局偏移量表（Global Offset Table，GOT)**：
- 在 GOT 中，每个被这个目标模块引用的全局数据目标（外部过程或全局变量）都有一个条目（8 字节），编译器为 GOT 中的条目生成一个重定位记录；
- 在加载时，动态链接器会重定位 GOT 中的每个条目，使得它包含目标的正确的绝对地址；
- 每个引用全局目标的目标模块都有自己的 GOT；

## 2. PIC 函数调用
假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它，但它需要链接器修改所调用的代码段。

为此，GNU 编译系统采用 **延迟绑定（lazy binding）**-- 将过程地址的绑定推迟到第一次调用该过程时，来解决这个问题。

同时，一个典型的应用程序只会使用共享库中很少的一部分，把函数地址的解析推迟到它实际被调用的地方，也能避免动态链接器在加载时进行成百上千个其实并不需要的重定位，第一次调用过程



# 7.13 库打桩机制

# 7.14 处理目标文件的工具

# 7.15 小结
