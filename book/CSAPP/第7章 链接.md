**链接（linking）** 是把多个代码与数据片段组合成一个可执行文件，使其能够被 **加载**（复制）到内存并执行的过程，可以执行于：
- **编译时（compile time）**：源代码被翻译成机器代码时；
- **加载时（load time）**：程序被 **加载器（loader）** 加载到内存并执行时；
- **运行时（run time）**：由应用程序来执行；
在现代系统中，链接由叫作 **链接器（linker）** 的程序自动执行的。

链接器使 **分离编译（separate compilation）** 成为可能：
- 大型程序可拆分为多个独立的更小、更好管理的模块；
- 可以独立修改和编译这些模块，修改某一模块只需重新编译该模块再链接；
- 不必重新编译全部源文件；

**什么需要理解链接？**
- **处理大型程序中的链接错误**：缺模块、缺库、库版本冲突等；
- **避免隐蔽的错误**：例如多个同名全局变量导致难以调试的运行时问题；
- **理解作用域实现原理**：如 global、local、static 实际影响；
- **理解系统关键机制**：程序加载、虚拟内存、内存映射等都依赖链接器生成的可执行文件；
- **使用共享库的能力**：动态链接带来节省空间、运行时升级、Web 服务动态内容等现代特性；

 本章将基于一个运行 Linux 并使用标准的 ELF-64(此后称为 ELF)的目标文件格式的 x86-64 的系统来讨论关于链接的各个方面，包括：
- 静态链接
- 加载时动态链接（共享库）
- 运行时动态链接（共享库）

---
# 7.1 编译器驱动程序
源代码从 `.c` 文件变成最终可以运行的 **可执行文件**，依靠大多数编译系统所提供的 **编译驱动程序（compiler driver）**，它需要经过多个独立的工具：  **预处理器 → 编译器 → 汇编器 → 链接器**。

但平时在 GNU 编译系统中只需要一句：`gcc -Og -o prog main.c sum.c`，**GCC 驱动程序统一调用了所有步骤**。它收到命令后，会按顺序自动调用：
1. **预处理器 cpp**
2. **编译器 cc1**
3. **汇编器 as**
4. **链接器 ld**
每一步都把上一阶段的输出当成输入，最终生成程序 **prog**。

## 实际流程
下面是 GCC 在构建程序时真实执行的命令（简化版）：

---
### (1) 预处理（cpp）
处理 `#include`、`#define`、删除注释，生成纯 C 文件：
```
cpp main.c → main.i
```
输出：`main.i`（展开完所有宏的 C 代码）

---
### (2) 编译（cc1）
把 C 转成汇编：
```
cc1 main.i → main.s
```
输出：`main.s`（汇编语言文件）

---
### (3) 汇编（as）
把汇编转成机器码，生成可重定位目标文件：
```
as main.s → main.o
```
输出：`main.o`（二进制，未链接）
对 `sum.c` 做同样的流程生成 `sum.o`。

---
### (4) 链接（ld）
把多个 `.o` 文件 + 系统提供的库文件合并，生成最终可执行文件：
```
ld main.o sum.o + system objects → prog
```
这个阶段解决函数调用的地址问题，为程序分配最终内存布局。
输出：`prog`（可执行文件）

---

## 执行：加载器负责把程序搬到内存
当运行：
```sh
./prog
```
shell 会调用 **加载器 loader**：
1. 把可执行文件的代码段、数据段读入内存
2. 设置栈和堆
3. 跳到程序入口点 `_start`
4. 程序开始运行

# 7.2 静态链接
**静态链接器（static linker）** 的输入（如 Linux LD）：
- 一组可重定位目标文件；
	- 各种不同的代码；
	- 各种不同的 **数据节（section）**，每一节都是一个连续的字节序列：
		- 指令在一节中；
		- 已初始化的全局变量在另一节中；
		- 未初始化的变量在另外一节中；
	- 引导链接器和加载器的数据结构；
- 命令行参数；
输出：一个完全链接的、可以加载和运行的可执行目标文件。

为了构造可执行文件，链接器必须完成两个主要任务：
- **符号解析（symbol resolution）**。目标文件定义和引用的 **符号**，每个符号对应于一个函数、一个全局变量或一个静态变量。而符号解析的目的就是将每个符号的 **引用** 和一个符号的 **定义** 关联起来；
- **重定位（relocation）** 。编译器和汇编器生成的是从地址 0 开始的代码和数据节（地址为假）。链接器通过把每个符号定义与一个内存位置关联起来，从而 **重定位** 这些节，然后修改所有对这些符号的引用，使得它们指向真实地址。（链接器使用汇编器产生的 **重定位条目 relocation entry** 的详细指令，直接执行）；

接下来的章节将更详细地描述这些实现，**本质上，目标文件就是一堆 “字节块” 的集合**，这些字节块分成几类：
- “代码块”；
- “数据块”（已初始化/未初始化）；
- “元数据块”（符号表、重定位表等）；
    
链接器所做的就是：
1. 按照规则把这些区块串接在一起；
2. 为每个块决定最终的内存位置；
3. 修改代码里的地址引用，让它们指向正确的真实地址；

链接器不是编译器，不负责生成指令，只是“把别人生成的片段拼起来”。

编译器 + 汇编器 会：
- 生成指令机器码；
- 决定局部变量布局；
- 决定函数栈帧结构；
- 创建重定位条目（告诉链接器具体该改哪里）；
    
链接器则按规则修改这些已准备好的机器码片段，但不会理解指令内容。

# 7.3 目标文件
目标文件有三种形式：
- **可重定位目标文件** -- 包含二进制代码和数据，由 **编译器/汇编器** 产生，不能直接执行，内部地址不是实际地址，等待链接器统一分配，其形式可以与其他可重定位目标文件合并起来，创建一个可执行目标文件；
- **可执行目标文件** -- 包含二进制代码和数据，由 **链接器** 产生，内部地址都是实际运行地址，其形式可以被直接加载到内存并执行；
- **共享目标文件** -- 一种特殊类型的可重定位目标文件，由 **编译器/汇编器** 产生，可以在加载或者运行时被动态地加载进内存并链接；

从技术上来说：
- **目标模块（object module）**：纯字节序列，本质就是一堆二进制数据。
- **目标文件（object file）**：把字节序列存成磁盘文件（`.o`、`.so`、`a.out`）。
实际使用中，书上会混用这两个词，不需要纠结本质差别。

> 目标文件是按照特定的目标文件格式来组织的，不同系统使用不同的目标文件格式，但结构思想相同。

常见目标文件格式：

|系统|格式|
|---|---|
|早期 Unix|`a.out`|
|Windows|PE（Portable Executable）|
|macOS|Mach-O|
|Linux / 现代 Unix|ELF（Executable and Linkable Format）|

# 7.4 可重定位目标文件
## 1. 整体结构：ELF 文件的布局
![[NoteAboutStudy/attachments/Pasted image 20251128220105.png]]
如图 7-3 为一个典型的 ELF 可重定位目标文件的格式。**ELF 头（ELF header）** 以一个 16 字节的序列开始在最前，**节头部表（section header table）** 在最后，中间夹着各种节（section）。

## 2. ELF 头
这个部分负责让链接器能解析、遍历文件结构，包含：
- 文件使用的字长（32/64 bit）
- 字节序（小端/大端）
- 文件类型（relocatable / executable / shared）
- 目标机器架构（如 x86-64）
- 节头部表的偏移地址
- 节头部表中条目的大小与数量

## 3. 节头部表
目标文件中每个节在节头部表中都有一个固定大小的条目（entry），记录：
- 每个节的名字
- 文件偏移
- 内存地址（如果可执行）
- 大小
- 标志位（可读/可写/可执行）

## 4. 典型的 ELF 可重定位文件所包含的节
- `.text` -- 已编译程序的机器代码，包含函数的指令；
- `.rodata` -- 只读数据（常量），比如字符串字面量、`printf` 格式串、switch 的跳转表；
- `.data` -- **已初始化**的全局变量和静态变量（局部变量在运行时被保存在栈中，既不出现在 `.data` 节中，也不出现在  `.bss` 节中）；
- `.bss` -- **未初始化**的全局变量或静态变量以及所有被初始化为 **0** 的全局或静态变量（`.bss` 在文件中不占实际空间，只是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据实际的磁盘空间，运行时系统会分配内存并设置初始值为 0）；
- `.symtab` -- 一个符号表，用于支持链接器的符号解析，包含全局变量、函数、静态变量（文件作用域），**不包含局部变量**，无需 `-g` 默认就有符号表信息，除非显式地用 STRIP 命令去除；
- `.rel.text` -- 一个 `.text` 节中位置的列表，记录其中哪些位置的指令需要在链接时被 “修正“（一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息）；
- `.rel.data` -- 记录 `.data` 中哪些内容引用了外部符号（外部定义函数或全局变量）；
- `.debug` -- 一个调试符号表，只有使用 `-g` 编译时才生成，包含程序中定义的局部变量和类型定义、程序中定义和引用的全局变量、原始的源文件内容等，被调试器使用，不参与链接；
- `.line` -- 原始源程序中的行号和 `.text` 节中的机器指令之间的映射，只有使用 `-g` 调用编译器驱动程序时才生成；
- `.strtab` -- 一个字符串表，存储：`.symtab` 中符号的名字、`.debug` 中的名字以及各 section 的名字，字符串表由一系列以 `\0` 结尾的字符串组成；

# 7.5 符号和符号表
每个可重定位目标模块都有一个符号表，它包含该模块定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：
- 由该模块定义并且能被其他模块引用的 **全局符号**。全局链接器符号对应于 **非静态的** 函数和全局变量；
- 由其他模块定义并被该模块所引用的 **全局符号**。这些符号称为 **外部符号**，对应于其他模块中定义的 **非静态的** 函数和全局变量；
- 只被当前模块定义和引用的 **局部符号**。对应于带 **static** 属性的函数和全局变量，只能被当前模块使用，不能被其他模块引用；

> `.symtab` 中的符号表不包含 **局部的非静态变量**，在运行时由栈管理。

而对于带 static 属性的局部变量，编译器在 `.data` 或 `.bss` 中为它的定义分配空间，并在符号表中创建一个有唯一名字的局部链接器符号（若在同一模块的两个函数中各自定义了一个静态局部变量，则编译器会向汇编器输出两个不同名字的局部链接器符号）。

> [!tip]- 利用 static 属性隐藏变量和函数名字
> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像在 Java 和 C++ 中使用 public 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有  static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来保护变量和函数是很好的编程习惯。

符号表是由汇编器构造的，使用编译器输出到汇编语言 `.s` 文件中的符号。`.symtab` 节中包含 ELF 符号表。每一个符号都是一个条目。如图 7-4 展示了每个条目的格式。
![[NoteAboutStudy/attachments/Pasted image 20251129175621.png]]

| 字段        | 意义                                            |
| --------- | --------------------------------------------- |
| `name`    | 字符串表中的偏移 → 指向符号的以 `null` 结尾的字符串名字             |
| `value`   | 该符号的地址（可重定位时是相对当前节开头的偏移，对于可执行文件来说是一个绝对运行时的地址） |
| `size`    | 大小（字节数）                                       |
| `type`    | 函数 / 对象（变量）                                   |
| `binding` | 局部 / 全局                                       |
| `section` | 该符号属于哪个节                                      |

> 每个符号都被分配到目标文件的某个节，由 `section` 字段表示，该字段也是一个到节头部表的索引。

有三个特殊的伪节（pseudosection），在节头部表中是没有条目的：
- `ABS` - 不能被重定位的符号；
- `UNDEF` - 未定义的符号（在该目标模块中引用，但是在其他模块中定义的符号）；
- `COMMON` - 未分配位置的未初始化的数据目标（`value` 字段给出对齐要求，而 `size` 给出最小的大小）
只有可重定位目标文件中才有这些伪节，可执行目标文件中并没有。

`COMMON` 和 `.bss` 的区别很细微，现代的 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 `COMMON` 和 `.bss` 中：
- `COMMON` -- 未初始化的全局变量；
- `.bss` -- 未初始化的静态变量，以及初始化为 0 的全局或静态变量；
采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，将会在  7.6 节中加以解释。

GNU READELF 程序是一个查看目标文件内容的很方便的工具。

# 7.6 符号解析
链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来：
- 对那些和引用定义在相同模块中的局部符号的引用（包括 static 变量和 static 函数）：
	- 编译器只允许每个模块中每个局部符号有一个定义；
	- 静态局部变量会编译成具有唯一名称的本地链接器符号；
	- 链接器直接在本模块中找到它们，不会冲突；
- 对于全局符号的引用解析：
	- **外部引用需要在其他模块中找到定义** -- 当编译器看到一个“当前模块未定义的名字”，它会先把它当成 “别的模块会定义” 的外部符号，然后在符号表中生成一条 “未定义符号（UNDEF）” 记录，最后交给链接器解决（链接器如果最终找不到定义 → 报错）；
	- **多个模块可能重复定义同名全局符号** -- 此时，链接器必须决定是 **报错** 还是 **选择一个定义，丢弃其他定义**（在 Linux ELF/GCC 中，这件事涉及 C 语言规则 + 编译器 + 汇编器 + 链接器三方协作，可能导致意料之外的 “符号覆盖” 问题）；

> [!tip]- 对 C++ 和 Java 中链接器符号的重整
> C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做 重整(mangling)，而相反的过程叫做 恢复(demangling)。
> 
> 幸运的是，C++ 和 Java 使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo::bax(int, long) 被编码为 bar__3Fooil。重整全局变量和模板名字的策略是相似的。

---
## 7.6.1 链接器如何解析多重定义的全局符号
可重定位目标文件中可能出现多个模块定义同名全局符号的问题。为了保持可控性，Linux/GCC/ELF 工具链对“如何选择最终定义”制定了明确的规则，下面是 Linux 编译系统采用的方法：
- 在编译时，编译器向汇编器输出每个全局符号，要么是 **强符号** 要么是 **弱符号**，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里 -- **函数和已初始化的全局变量** 是强符号，**未初始化的全局变量** 是弱符号；
- 根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：
	- 规则一 -- **不允许有多个同名的强符号**（这是为了保证全局变量、函数的唯一性）；
	- 规则二 -- **如果有一个强符号和多个弱符号同名，选择强符号**；
	- 规则三 -- **如果有多个弱符号同名，那么链接器从这些弱符号中任选一个，**（潜在危险点）；

> 因为不同模块对同名变量的定义可能不一致，故规则三可能会导致 bug，且构建顺序一变就有可能触发或消失、运行时表现与出错点距离极远、链接器只给出一个对齐警告，因此难以发现与修复。此时就可以：
> - 让编译器将未初始化的全局变量也视为强符号；
> - 将警告变成错误；

在上一节（7.5）中讲述了编译器按照一个规则来把符号分配为 **COMMON** 和 `.bss`，采用这个惯例的原因是
- **未初始化的全局变量** 是弱符号，可能在多个模块中被多次定义。编译器无法确定最终采用哪个定义，也无法确定大小和对齐，只能把决定权交给链接器，因此放入 COMMON；
- 已初始化变量（包括初始化为 0）是强符号，唯一，可直接放 .bss/.data；
- 静态变量永远唯一，也可直接放 .bss/.data；

## 7.6.2 与静态库链接
迄今为止，都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为 **静态库(static library)**，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

如果没有库，一些函数就无法使用，此时，有三种方案可以在不使用静态库的情况下提供函数：
- 让编译器辨认出对标准函数的调用，并直接生成相应的代码（Pascal 只提供一小部分标准函数，所以采用这种方案），但是
	- C 的函数太多，需要写一堆内建支持 → 编译器臃肿；
	- 任何标准函数变动都要重写编译器 → 崩溃；
	- 所有程序把所有函数“编译进去” → 内存/磁盘浪费；
- 将所有的标准 C 函数都放在一个单独的可重定位目标模块中，这样只链接这个模块到可执行文件中就行了，但是
	- 每个程序都要在可执行文件里包含一份标准函数集合的完全副本，对于磁盘空间来说很浪费；
	- 每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费；
	- 对任何标准函数的任何改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变得很复杂；
- 可以通过为每个标准函数创建一个独立的可重定位文件（.o 文件），但是
	- 程序员必须手动列出所有依赖，极易出错且耗费时间；

静态库概念被提出来，以解决这些不同方法的缺点：**相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件**。然后，应用程序就可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数：
- 在链接时，链接器将 **只复制被程序引用的目标模块**，这就减少了可执行文件在磁盘和内存中的大小；
- 应用程序中只需要包含较少的库文件的名字；

在 Linux 系统中，静态库以一种称为 **存档(archive)** 的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 `.a` 标识，可使用 AR 工具创建。

## 7.6.3 链接器如何使用静态库来解析引用
在符号解析阶段，链接器采用 **从左到右** 出现在编译器驱动程序命令行的顺序来扫描可重定位文件和存档文件，在扫描过程中，会维护三个集合，初始化皆为空：
- E：最终会被加入可执行文件的可重定位目标文件的集合；
- U：目前为止遇到的 "未解析符号" 的集合（引用了但尚未定义的符号）；
- D：目前已经出现过的 "已定义符号" 集合；

对于命令行上的每个输入文件，链接器首先会判断它是一个目标文件还是一个存档文件：
- 如果是一个目标文件，
	- 那么链接器会把它添加到 E 中，并修改 U 和 D 来反映该目标文件中的符号定义和引用，然后继续下一个输入文件；
- 如果是一个存档文件，
	- 那么链接器会尝试匹配 U 中为解析的符号和由存档文件成员所定义的符号；
	- 如果某个存档文件成员定义了一个符号来解析 U 中的一个引用，那么就把这个存档文件成员加到 E 中，并修改 U 和 D 来反映该存档文件成员中的符号定义和引用；
	- 对存档文件中所有的成员目标文件都依次进行上一条的过程，直到 U 和 D 都不再发生变化，此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，任何继续处理下一个输入文件；
如果当链接器完成对命令行上输入文件的扫描后，U 是 非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，并构建输出的可执行文件。

> **静态库必须出现在引用它的目标文件之后**
    因为链接器不会 “回头找库”，它只在处理库的那一刻查看 U 中是否有未解析符号。

> **如果库之间存在依赖时还必须排序**

> **如果两个库循环依赖**
> - 命令行重复库
> - 把两个库合并成一个

# 7.7 重定位
当链接器完成了符号解析这一步（把代码中的每个符号引用和一个符号定义关联起来），此时链接器知道所有输入模块的代码段、数据段的大小，因此可以开始 **重定位（relocation）**，在此期间，将合并输入模块，并为每个符号分配运行地址，包含两个步骤：
- **重定位节和符号定义**。链接器将所有相同类型的节合并为同一类型的新的聚合节，然后将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号 -- 此时，程序中的每条指令和全局变量都有唯一的运行时地址；
- **重定位节中的符号引用**。链接器修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址（依赖于可重定位目标模块中称为 **重定位条目** 的数据结构）；

---
## 7.7.1 重定位条目
当汇编器生成一个目标模块时，可能：
- **不知道代码最终会被放到内存中的什么位置**；
- **不知道外部函数或全局变量（在其他文件中定义）的位置**；
因此，当汇编器遇到一个对 “位置” 未知的目标引用时，首先生成一个 **重定位条目（relocation entry）**，告诉链接器在将目标文件合并成可执行文件时该如何修改这个引用。

ELF 中：
- **代码 section（.text） 的重定位条目** 放在 `.rel.text`；
- **已初始化数据 section（.data） 的重定位条目** 放在 `.rel.data`；

![[NoteAboutStudy/attachments/Pasted image 20251201223202.png]]
如图 7-9 所示，`offset` 是需要被修改的引用的节偏移。`symbol` 标识被修改引l用应该指向的符号。`type` 告知链接器如何修改新的引用。`addend` 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

ELF 定义了 32 种不同的重定位类型，有些相当隐秘。本书只讲述其中两种最基本的重定位类型：
- R_X86_64_PC32。对 **32 位 PC 相对寻址** 的引用进行重定位；
- R_X86_64_32。**32 位绝对地址** 的重定位；
这两种重定位类型支持 **x86-64 小型代码模型（small code model）**，该模型假设可执行目标文件中的代码和数据的总体大小小于 2GB，因此在运行时可以用 32 位 PC 相对地址来访问。 GCC 默认使用小型代码模型。大于 2GB 的程序可以用 `-mcmodel = medium`（中型代码模型）和 `-mcmodel = large`（大型代码模型）标志来编译，不过本书在此不讨论这些模型。

## 7.7.2 重定位符号引用
当链接器进入重定位阶段时，它已经知道：
- 每个节（.text、.data …）最终在可执行文件中的起始运行时地址 `ADDR(s)`
- 每个符号（函数、全局变量）的最终运行时地址 `ADDR(symbol)`
接下来它要做的，就是把**目标文件里的所有“引用符号的地方”改成正确的地址**。这些“待修改的地方”由**重定位条目（relocation entry）** 指定，每一个重定位条目告诉链接器：
- 代码或数据中的哪 4 字节（或 8 字节）需要修改
- 这个引用使用的是 **PC 相对寻址** 还是 **绝对寻址**
- 这个引用应该指向哪个符号

![[NoteAboutStudy/attachments/Pasted image 20251202211828.png]]
如图 7-10 展示了链接器的重定位算法的伪代码（同时本书也通过具体实例讲述这两种方式 -- P480）：
1. PC 相对寻址（`R_X86_64_PC32`）
	- 目标：让指令中的 32-bit 偏移量，使得运行时 -- PC + 偏移量 = 要跳转的目标地址；
	- 链接器填入 -- offset = 目标地址 - (当前指令后面一条指令的地址) + addend，也就是伪代码中的 `*refptr = ADDR(symbol) + addend - refaddr`（其中 `refaddr` = 这条指令后面紧随的指令地址）；
2. 绝对寻址（`R_X86_64_32`）
	- 目标：把立即数直接替换成符号的绝对地址；
	- 链接器填入 -- `*refptr = ADDR(symbol) + addend`；

所有重定位完成后：
- `.text` 节变成 “可直接执行的机器码”；
- `.data` 节也完全带有正确地址；
- 加载器把节复制进内存，不再做修改；
程序即可运行。

# 7.8 可执行目标文件

# 7.9 加载可执行目标文件

# 7.10 动态链接共享库

# 7.11 从应用程序中加载和链接共享库

# 7.12 位置无关代码

# 7.13 库打桩机制

# 7.14 处理目标文件的工具

# 7.15 小结
