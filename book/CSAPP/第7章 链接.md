**链接（linking）** 是把多个代码与数据片段组合成一个可执行文件，使其能够被 **加载**（复制）到内存并执行的过程，可以执行于：
- **编译时（compile time）**：源代码被翻译成机器代码时；
- **加载时（load time）**：程序被 **加载器（loader）** 加载到内存并执行时；
- **运行时（run time）**：由应用程序来执行；
在现代系统中，链接由叫作 **链接器（linker）** 的程序自动执行的。

链接器使 **分离编译（separate compilation）** 成为可能：
- 大型程序可拆分为多个独立的更小、更好管理的模块；
- 可以独立修改和编译这些模块，修改某一模块只需重新编译该模块再链接；
- 不必重新编译全部源文件；

**什么需要理解链接？**
- **处理大型程序中的链接错误**：缺模块、缺库、库版本冲突等；
- **避免隐蔽的错误**：例如多个同名全局变量导致难以调试的运行时问题；
- **理解作用域实现原理**：如 global、local、static 实际影响；
- **理解系统关键机制**：程序加载、虚拟内存、内存映射等都依赖链接器生成的可执行文件；
- **使用共享库的能力**：动态链接带来节省空间、运行时升级、Web 服务动态内容等现代特性；

 本章将基于一个运行 Linux 并使用标准的 ELF-64(此后称为 ELF)的目标文件格式的 x86-64 的系统来讨论关于链接的各个方面，包括：
- 静态链接
- 加载时动态链接（共享库）
- 运行时动态链接（共享库）

---
# 7.1 编译器驱动程序
源代码从 `.c` 文件变成最终可以运行的 **可执行文件**，依靠大多数编译系统所提供的 **编译驱动程序（compiler driver）**，它需要经过多个独立的工具：  **预处理器 → 编译器 → 汇编器 → 链接器**。

但平时在 GNU 编译系统中只需要一句：`gcc -Og -o prog main.c sum.c`，**GCC 驱动程序统一调用了所有步骤**。它收到命令后，会按顺序自动调用：
1. **预处理器 cpp**
2. **编译器 cc1**
3. **汇编器 as**
4. **链接器 ld**
每一步都把上一阶段的输出当成输入，最终生成程序 **prog**。

## 实际流程
下面是 GCC 在构建程序时真实执行的命令（简化版）：

---
### (1) 预处理（cpp）
处理 `#include`、`#define`、删除注释，生成纯 C 文件：
```
cpp main.c → main.i
```
输出：`main.i`（展开完所有宏的 C 代码）

---
### (2) 编译（cc1）
把 C 转成汇编：
```
cc1 main.i → main.s
```
输出：`main.s`（汇编语言文件）

---
### (3) 汇编（as）
把汇编转成机器码，生成可重定位目标文件：
```
as main.s → main.o
```
输出：`main.o`（二进制，未链接）
对 `sum.c` 做同样的流程生成 `sum.o`。

---
### (4) 链接（ld）
把多个 `.o` 文件 + 系统提供的库文件合并，生成最终可执行文件：
```
ld main.o sum.o + system objects → prog
```
这个阶段解决函数调用的地址问题，为程序分配最终内存布局。
输出：`prog`（可执行文件）

---

## 执行：加载器负责把程序搬到内存
当运行：
```sh
./prog
```
shell 会调用 **加载器 loader**：
1. 把可执行文件的代码段、数据段读入内存
2. 设置栈和堆
3. 跳到程序入口点 `_start`
4. 程序开始运行

# 7.2 静态链接
**静态链接器（static linker）** 的输入（如 Linux LD）：
- 一组可重定位目标文件；
	- 各种不同的代码；
	- 各种不同的 **数据节（section）**，每一节都是一个连续的字节序列：
		- 指令在一节中；
		- 已初始化的全局变量在另一节中；
		- 未初始化的变量在另外一节中；
- 命令行参数；
输出：一个完全链接的、可以加载和运行的可执行目标文件。

为了构造可执行文件，连接器必须完成两个主要任务：
- **符号解析（symbol resolution）**。目标文件定义和引用的 **符号**，每个符号对应于一个函数、一个全局变量或一个静态变量。而符号解析的目的就是将每个符号的 **引用** 和一个符号的 **定义** 关联起来；
- **重定位（relocation）** 
# 7.3 目标文件

# 7.4 可重定位目标文件

# 7.5 符号和符号表

# 7.6 符号解析

# 7.7 重定位

# 7.8 可执行目标文件

# 7.9 加载可执行目标文件

# 7.10 动态链接共享库

# 7.11 从应用程序中加载和链接共享库

# 7.12 位置无关代码

# 7.13 库打桩机制

# 7.14 处理目标文件的工具

# 7.15 小结
