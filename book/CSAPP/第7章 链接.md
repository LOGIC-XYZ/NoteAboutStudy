**链接（linking）** 是把多个代码与数据片段组合成一个可执行文件，使其能够被 **加载**（复制）到内存并执行的过程，可以执行于：
- **编译时（compile time）**：源代码被翻译成机器代码时；
- **加载时（load time）**：程序被 **加载器（loader）** 加载到内存并执行时；
- **运行时（run time）**：由应用程序来执行；
在现代系统中，链接由叫作 **链接器（linker）** 的程序自动执行的。

链接器使 **分离编译（separate compilation）** 成为可能：
- 大型程序可拆分为多个独立的更小、更好管理的模块；
- 可以独立修改和编译这些模块，修改某一模块只需重新编译该模块再链接；
- 不必重新编译全部源文件；

**什么需要理解链接？**
- **处理大型程序中的链接错误**：缺模块、缺库、库版本冲突等；
- **避免隐蔽的错误**：例如多个同名全局变量导致难以调试的运行时问题；
- **理解作用域实现原理**：如 global、local、static 实际影响；
- **理解系统关键机制**：程序加载、虚拟内存、内存映射等都依赖链接器生成的可执行文件；
- **使用共享库的能力**：动态链接带来节省空间、运行时升级、Web 服务动态内容等现代特性；

 本章将基于一个运行 Linux 并使用标准的 ELF-64(此后称为 ELF)的目标文件格式的 x86-64 的系统来讨论关于链接的各个方面，包括：
- 静态链接
- 加载时动态链接（共享库）
- 运行时动态链接（共享库）

---
# 7.1 编译器驱动程序
源代码从 `.c` 文件变成最终可以运行的 **可执行文件**，依靠大多数编译系统所提供的 **编译驱动程序（compiler driver）**，它需要经过多个独立的工具：  **预处理器 → 编译器 → 汇编器 → 链接器**。

但平时在 GNU 编译系统中只需要一句：`gcc -Og -o prog main.c sum.c`，**GCC 驱动程序统一调用了所有步骤**。它收到命令后，会按顺序自动调用：
1. **预处理器 cpp**
2. **编译器 cc1**
3. **汇编器 as**
4. **链接器 ld**
每一步都把上一阶段的输出当成输入，最终生成程序 **prog**。

## 实际流程
下面是 GCC 在构建程序时真实执行的命令（简化版）：

---
### (1) 预处理（cpp）
处理 `#include`、`#define`、删除注释，生成纯 C 文件：
```
cpp main.c → main.i
```
输出：`main.i`（展开完所有宏的 C 代码）

---
### (2) 编译（cc1）
把 C 转成汇编：
```
cc1 main.i → main.s
```
输出：`main.s`（汇编语言文件）

---
### (3) 汇编（as）
把汇编转成机器码，生成可重定位目标文件：
```
as main.s → main.o
```
输出：`main.o`（二进制，未链接）
对 `sum.c` 做同样的流程生成 `sum.o`。

---
### (4) 链接（ld）
把多个 `.o` 文件 + 系统提供的库文件合并，生成最终可执行文件：
```
ld main.o sum.o + system objects → prog
```
这个阶段解决函数调用的地址问题，为程序分配最终内存布局。
输出：`prog`（可执行文件）

---

## 执行：加载器负责把程序搬到内存
当运行：
```sh
./prog
```
shell 会调用 **加载器 loader**：
1. 把可执行文件的代码段、数据段读入内存
2. 设置栈和堆
3. 跳到程序入口点 `_start`
4. 程序开始运行

# 7.2 静态链接
**静态链接器（static linker）** 的输入（如 Linux LD）：
- 一组可重定位目标文件；
	- 各种不同的代码；
	- 各种不同的 **数据节（section）**，每一节都是一个连续的字节序列：
		- 指令在一节中；
		- 已初始化的全局变量在另一节中；
		- 未初始化的变量在另外一节中；
	- 引导链接器和加载器的数据结构；
- 命令行参数；
输出：一个完全链接的、可以加载和运行的可执行目标文件。

为了构造可执行文件，连接器必须完成两个主要任务：
- **符号解析（symbol resolution）**。目标文件定义和引用的 **符号**，每个符号对应于一个函数、一个全局变量或一个静态变量。而符号解析的目的就是将每个符号的 **引用** 和一个符号的 **定义** 关联起来；
- **重定位（relocation）** 。编译器和汇编器生成的是从地址 0 开始的代码和数据节（地址为假）。链接器通过把每个符号定义与一个内存位置关联起来，从而 **重定位** 这些节，然后修改所有对这些符号的引用，使得它们指向真实地址。（链接器使用汇编器产生的 **重定位条目 relocation entry** 的详细指令，直接执行）；

接下来的章节将更详细地描述这些实现，**本质上，目标文件就是一堆 “字节块” 的集合**，这些字节块分成几类：
- “代码块”；
- “数据块”（已初始化/未初始化）；
- “元数据块”（符号表、重定位表等）；
    
链接器所做的就是：
1. 按照规则把这些区块串接在一起；
2. 为每个块决定最终的内存位置；
3. 修改代码里的地址引用，让它们指向正确的真实地址；

链接器不是编译器，不负责生成指令，只是“把别人生成的片段拼起来”。

编译器 + 汇编器 会：
- 生成指令机器码；
- 决定局部变量布局；
- 决定函数栈帧结构；
- 创建重定位条目（告诉链接器具体该改哪里）；
    
链接器则按规则修改这些已准备好的机器码片段，但不会理解指令内容。

# 7.3 目标文件
目标文件有三种形式：
- **可重定位目标文件** -- 包含二进制代码和数据，由 **编译器/汇编器** 产生，不能直接执行，内部地址不是实际地址，等待链接器统一分配，其形式可以与其他可重定位目标文件合并起来，创建一个可执行目标文件；
- **可执行目标文件** -- 包含二进制代码和数据，由 **链接器** 产生，内部地址都是实际运行地址，其形式可以被直接加载到内存并执行；
- **共享目标文件** -- 一种特殊类型的可重定位目标文件，由 **编译器/汇编器** 产生，可以在加载或者运行时被动态地加载进内存并链接；

从技术上来说：
- **目标模块（object module）**：纯字节序列，本质就是一堆二进制数据。
- **目标文件（object file）**：把字节序列存成磁盘文件（`.o`、`.so`、`a.out`）。
实际使用中，书上会混用这两个词，不需要纠结本质差别。

> 目标文件是按照特定的目标文件格式来组织的，不同系统使用不同的目标文件格式，但结构思想相同。

常见目标文件格式：

|系统|格式|
|---|---|
|早期 Unix|`a.out`|
|Windows|PE（Portable Executable）|
|macOS|Mach-O|
|Linux / 现代 Unix|ELF（Executable and Linkable Format）|

# 7.4 可重定位目标文件
![[NoteAboutStudy/attachments/Pasted image 20251128220105.png]]
如图 7-3 为一个典型的 ELF 可重定位目标文件的格式。

# 7.5 符号和符号表

# 7.6 符号解析

# 7.7 重定位

# 7.8 可执行目标文件

# 7.9 加载可执行目标文件

# 7.10 动态链接共享库

# 7.11 从应用程序中加载和链接共享库

# 7.12 位置无关代码

# 7.13 库打桩机制

# 7.14 处理目标文件的工具

# 7.15 小结
