---
tags:
  - CSAPP
---
一个系统中的进程是与其他进程共享 CPU 和主存资源的：
 - 随着对 CPU 需求的增长，进程就会变慢；
 - 但是如果太多的进程需要太多的内存，就会导致一些无法运行，并且一个进程误写了另一个进程使用的内存，就可能会导致错误；

为了更有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，称为 **虚拟内存(VM)**：
> VM = **硬件异常** + **硬件地址翻译** + **主存** + **磁盘文件** + **内核软件** 的交互协作
> 为 **每个进程** 提供一个大的、连续的、私有的地址空间。

虚拟内存提供了三个重要的能力：
1. **把主存看作磁盘的高速缓存**
	- 主存只保存活动区域；
	- 磁盘保存完整地址空间；
	- 根据需要在磁盘和主存间传送数据（就不会内存不够了）；
2. **给每个进程提供一致的地址空间**
	- 不用关心物理内存是否碎片；
	- 简化了内存管理与程序设计；
3. **保护每个进程的地址空间不被破坏**
	- 一个进程不能访问其他的进程的内存；
	- 错误访问直接触发异常；

为什么需要理解虚拟内存：
- 虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中都扮演者重要的角色，是理解系统是如何工作的重要一环；
- 虚拟内存使得应用程序可以，按需创建/销毁内存、把文件映射成内存、多进程共享内存、通过读写内存来读写文件；
- 同时，每次应用程序引用一个变量、间接引用一个指针、或者调用像 `malloc/free` 这样的动态分配程序时，就会和虚拟内存发生交互。如果使用不当，就会导致错误；

本章将从 VM 如何工作 以及 程序如何使用 VM 两个部分来讲述：

---
# 9.1 物理和虚拟寻址
计算机系统的主存是一个 **由连续的字节大小的单元** 组成的数组，每个字节都有一个唯一的 **物理地址(Physical Address，PA)**。

CPU 访问内存最自然的方式就是通过物理地址，这种方式称为 **物理寻址(physical addressing)**，如图 9-1 所示为一个物理寻址的示例：
![[NoteAboutStudy/attachments/Pasted image 20260117204804.png]]
CPU 执行一条加载指令（读取从物理地址 4 处开始的 4 字节字），执行时会生成一个有效物理地址，通过内存总线传递给主存，然后主存返回数据给 CPU（CPU 会将它存放在一个寄存器中）。

现代处理器使用的是称为 **虚拟寻址(virtual addressing)** 的寻址形式，如图 9-2 所示：
![[NoteAboutStudy/attachments/Pasted image 20260117204945.png]]
CPU 通过生成一个 **虚拟地址(Virtual Address，VA)** 来访问内存，而 VA 在访问主存前会先被转换为 PA。

将一个虚拟地址转换为物理地址的过程称为 **地址翻译(address translation)**，地址翻译需要 CPU 硬件和操作系统之间的紧密合作：
 - CPU 芯片上称为 **内存管理单元(Memory Management Unit，MMU)** 硬件负责工作；
 - 利用由操作系统维护的存放在主存中的描述 VA -> PA 的映射关系的查询表来动态翻译虚拟地址；

# 9.2 地址空间
**地址空间(address space)** 是一个非负整数地址的有序集合（用于给内存字节编号的）。

如果地址空间中的整数是连续的，则称为 **线性地址空间(linear address space)**。为了简化讨论，总是假设使用的是线性地址空间。

在一个带虚拟内存的系统中，CPU 从一个有 $N=2^n$ 个地址的地址空间中生成虚拟地址，这个地址空间称为 **虚拟地址空间(virtual address space)**：{$0,1,2,……,N-1$}。

一个地址空间的大小是由最大地址所需要的位数来描述的，例如：
 - 最大虚拟地址需要 **n 位二进制数**表示
 - 地址总数是 **2ⁿ**
则称之为 $n$ 位地址空间（现代系统通常支持 32 位或者 64 位虚拟地址空间）。

**物理地址空间(physical address space)** 则对应系统中物理内存的 $M$ 个字节：{$0,1,2,……,M-1$} （M 不要求是 2 的幂，但为了简化讨论，通常还是假设 $M=2^m$）。

有了地址空间，主存中的每个字节都由一个选自 虚拟地址空间 的 VA 和 一个选自 物理地址空间 的 PA。

# 9.3 虚拟内存作为缓存的工具
从概念模型上看，虚拟内存可以被视为一个存放在磁盘上的、由 $N$ 个连续的字节大小的单元组成的数组，其中每个字节都有唯一的虚拟地址作为索引，且主存中缓存该数组中 “当前活跃” 的一部分。

和存储器层次结构中其他缓存一样，将数据分割为块，作为磁盘（较低层次）和主存（较高层次）之间的传输单元：
 - VM 系统将虚拟内存分割为大小固定的块，称为 **虚拟页(Virtual Page，VP)** ，每个的大小为 $P=2^p$ 字节；
 - 物理内存也被切割为同样大小的块，称为 **物理页(Physical Page，PP)** 或 **页帧(page frame)**，大小同样为 $P$ 字节；
VP 和 PP 一致，以确保地址翻译成立。

在任意时刻，所有虚拟页被划分为三个互斥集合：
 - **未分配** -- VM 系统尚未分配（或者创建）的页，没有数据，故不占用磁盘空间；
 - **未缓存** -- 未缓存在物理内存中的已分配页，页存在于磁盘上，但尚且不在主存中，访问时会触发缺页异常；
 - **缓存** -- 当前已缓存在物理内存中的已分配页，可直接访问；

---
## 9.3.1 DRAM 缓存的组织结构
为了清晰讲解存储层次结构中不同的缓存概念，将位于 CPU 和主存之间的 L1、L2 和 L3 高速缓存称为 SRAM 缓存，将虚拟内存系统的缓存称为 DRAM 缓存（它在主存中缓存虚拟页）。

DRAM 缓存一旦不命中，就要去访问磁盘，而访问磁盘代价极其昂贵：
 - 故 VP 通常很大，一次多搬运数据；
 - 故 缓存为全相联，即任何虚拟页都可以放置在任何物理页中；
 - 故 不命中的替换策略是操作系统使用复杂的替换算法；
 - 故 使用 ==写回==，而不是直写，避免每次写内存都要同步写磁盘，而是只发生在 DRAM ，再一次性写回；

## 9.3.2 页表
同任何缓存一样，虚拟内存系统需要一种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方：
 - 如果是，还需要知道该虚拟页存放在哪个物理页中；
 - 如果不命中，需要判断该虚拟页存放在磁盘的哪个位置，并在物理内存中选择一个牺牲页，然后将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页